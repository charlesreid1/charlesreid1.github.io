<!DOCTYPE html>
<html lang="en">
<head>
        <title>charlesreid1</title>
        <meta charset="utf-8" />

        <!--
        CSS styles
        -->
        <link href="/theme/css/bootstrap.css"       rel="stylesheet" type="text/css">
        <!--
        <link href="/theme/css/cyborg.css"          rel="stylesheet" type="text/css">
        <link href="/theme/css/cosmo.css"           rel="stylesheet" type="text/css">
        <link href="/theme/css/sandstone.css"       rel="stylesheet" type="text/css">
        -->
        <link href="/theme/css/slate.css"              rel="stylesheet" type="text/css">
        <link href="/theme/css/font-awesome.css"       rel="stylesheet" type="text/css"/>
        <link href="/theme/css/pygment-solarized.css"  rel="stylesheet" type="text/css"/>


        <!--
        my CSS styles
        -->
        <link href="/theme/css/main.css"            rel="stylesheet" type="text/css">
        <link href="/theme/css/dox.css"             rel="stylesheet" type="text/css">


        <!--
        include Angular first
        -->
        <script type="text/javascript" src="/theme/js/angular-1.3.15.js"></script>
        <script type="text/javascript" src="/theme/js/skrollr-0.6.29.js"></script>
        <script type="text/javascript" src="/theme/js/d3-3.5.5.js"></script>

        <!--
        this seems like a bad idea.
        but if I don't put jquery first, I get errors about unrecognized $s.
        -->
        <script type="text/javascript" src="/theme/js/jquery-1.11.2.js"></script>

</head>
<body id="index">
<nav class="navbar navbar-default">
    <div class="container-fluid">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#myNavbar">
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span> 
            </button>
            <a href="https://charlesreid1.github.io" class="navbar-brand">charlesreid1.github.io</a>
        </div>
        <div>
            <div class="collapse navbar-collapse" id="myNavbar">
                <ul class="nav navbar-nav">

                    <li>
                        <a href="https://charlesreid1.com/wiki">Wiki</a>
                    </li>
                    <li>
                        <a href="https://charlesreid1.com:3000/explore">Git.charlesreid1.com</a>
                    </li>
                    <li>
                        <a href="https://github.com/charlesreid1/charlesreid1-awesome/">charlesreid1 Awesome List</a>
                    </li>
                    <li>
                        <a href="https://charlesreid1.com/notes">Notes</a>
                    </li>
                    <li>
                        <a href="https://charlesreid1.github.io">Blog</a>
                    </li>
                    <li>
                        <a href="https://charlesreid1.com/contact">Contact Me</a>
                    </li>

                </ul>
            </div>
        </div>
    </div>
</nav>



<div class="container">

<header>
<div class="row">


    <div class="col-md-12">
        <div class="headtext" style="text-align: center;">
            <h1><b>
                Five Letter Words: Part 2: More Five-Word Algorithms
            </b></h1>
        
            <p class="lead">
                Posted 
                <time datetime="2017-09-02T21:00:00-07:00" pubdate>Saturday 09/02/2017</time>
                in 
                <a href="/category/computer-science.html">Computer Science</a>
                </p>
            <p>
            <span style="font-size: 14px">
                <a href="/five-letter-words-part-2-more-five-word-algorithms.html">permalink</a>
            </span>
            </p>
        </div>

    </div>

</div>
</header>


<div class="v50"></div>


<div class="row">
    <div class="col-md-12" style="text-align: left;">

        <div class="entry-content"><p><em>NOTE: The code covered in this post uses Python 3. The scripts can be converted to Python 2 with minimal effort,
but the author would encourage any user of Python 2 to "put on your big kid pants" and 
make the switch to Python 3. Let's all make this painful, drawn-out switch from Python 2 
to Python 3 a thing of the past, shall we?</em></p>
<h2>Table of Contents</h2>
<ul>
<li><a href="#five2-intro">Introduction</a></li>
<li><a href="#five2-distinct">Five-Letter Words with k Distinct Letters</a><ul>
<li><a href="#five2-variation">Examining a Variation</a></li>
</ul>
</li>
<li><a href="#five2-lex">Lexicographic Ordering of Letters</a><ul>
<li><a href="#five2-lexicographic">Five-Letter Words with Lexicographically Ordered Letters</a></li>
<li><a href="#five2-rlexicographic">Five-Letter Words with Lexicographically Reversed Letters</a></li>
</ul>
</li>
<li><a href="#five2-findpalindromes">Finding Palindromes</a><ul>
<li><a href="#five2-palindromes">Palindromes</a></li>
<li><a href="#five2-palindromepairs">Palindrome Pairs</a></li>
<li><a href="#five2-nearpalindromes">Near Palindromes</a></li>
</ul>
</li>
<li><a href="#five2-references">References</a></li>
</ul>
<p><a name="five2-intro"></a></p>
<h2>Introduction</h2>
<p>As mentioned in <a href="http://charlesreid1.github.io/five-letter-words-part-1-getting-familiar-with-the-list.html">Five Letter Words: Part 1</a>,
we covered Donald Knuth's list of five letter words, one of the data sets in the 
<a href="http://www3.cs.stonybrook.edu/~algorith/implement/graphbase/implement.shtml">Stanford Graph Base</a>
that is covered in greater detail in Knuth's coverage of graph theory in Volume 4, Facsimile 0
of his magnum opus, <u>The Art of Computer Programming</u>.</p>
<p>In the section where Knuth introduces the set of words, he also gives readers 
several exercises to get to know the list of words. This multi-part series of posts
(also see <a href="http://charlesreid1.github.io/five-letter-words-part-1-getting-familiar-with-the-list.html">Five Letter Words: Part 1</a>)
is covering some of the solutions to these exercises, and expanding on them 
to illustrate some of the interesting and surprising properties of this data set.</p>
<p><a name="five2-distinct"></a></p>
<h2>Five-Letter Words with k Distinct Letters</h2>
<p>In Exercise 27, Knuth asks the reader to make a list of words composed of 
a specific number of distinct letters (1, 2, 3, 4, or 5). </p>
<p>In the list of five-letter words, there are 0 words composed of a single letter,
4 words with two distinct letters (0.07%), 
163 words with three distinct letters (2.8%), 
1756 words with four distinct letters (30.5%), 
and 3834 words with five distinct letters (66.5%).</p>
<p>Here are a few examples:
<em> Two distinct letters: mamma, ahhhh, esses, ohhhh
</em> Three distinct letters: added, seems, sense, level, teeth
<em> Four distinct letters: which, there, these, where, three
</em> Five distinct letters: their, about, would, other, words</p>
<p>To find these, we can design an algorithm that does the following:
split each string into characters,
add them to a set data type (a set discards any duplicates), 
and get the size of the set. 
This will give us the number of unique letters in a given word,
and we can use a list of lists to store all words with 
a specified number of unique letters. </p>
<p>Once again, we're using our <code>get_words</code> function,
which we covered in <a href="http://charlesreid1.github.io/five-letter-words-part-1-getting-familiar-with-the-list.html">Part 1</a>.
See <a href="https://github.com/charlesreid1/five-letter-words/blob/master/get_words.py">get_words.py</a>
for that script.</p>
<p><a href="https://github.com/charlesreid1/five-letter-words/blob/master/distinct.py">distinct.py</a></p>
<div class="highlight"><pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">distinct.py</span>

<span class="sd">Donald Knuth, Art of Computer Programming, Volume 4 Facsimile 0</span>
<span class="sd">Exercise #27</span>

<span class="sd">How many SGB words contain exactly k distinct letters, for 1 &lt;= k &lt;= 5?</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">pprint</span> <span class="kn">import</span> <span class="n">pprint</span>
<span class="kn">from</span> <span class="nn">get_words</span> <span class="kn">import</span> <span class="n">get_words</span>

<span class="k">if</span> <span class="vm">__name__</span><span class="o">==</span><span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">words</span> <span class="o">=</span> <span class="n">get_words</span><span class="p">()</span>

    <span class="n">lengths</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>

    <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">words</span><span class="p">:</span>
        <span class="n">k</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">word</span><span class="p">))</span>
        <span class="n">lengths</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">word</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s2">&quot;-&quot;</span><span class="o">*</span><span class="mi">40</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="s2">&quot;Number of words with {0:d} letters: {1:d}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">lengths</span><span class="p">[</span><span class="n">i</span><span class="p">])))</span>
        <span class="k">print</span><span class="p">(</span><span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lengths</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">:</span><span class="mi">5</span><span class="p">]))</span>
</pre></div>


<p>The principal operation here is the statement that gets the length, k:</p>
<div class="highlight"><pre><span></span>k = len(set(word))
lengths[k].append(word)
</pre></div>


<p>The operation of turning a word into a set is <span class="math">\(O(M)\)</span>, where M is the number of 
letters in the word, and the algorithm performs this operation on each word in sequence,
so overall, the algorithm is <span class="math">\(O(N)\)</span>, where N is the number of words.</p>
<p>The storage space used by the algorithm is also <span class="math">\(O(N)\)</span>, since for each word,
the number of distinct letters <span class="math">\(k \in \{ 0 \dots 5 \}\)</span>.</p>
<p>If we were dealing with a lot of words, and needed to save some space,
we could represent the list of words with <span class="math">\(k\)</span> distinct letters using five bit vectors,
where each bit vector represents the words that are composed of <span class="math">\(k\)</span> distinct 
letters, and has a length of <span class="math">\(N\)</span>, the number of words. A 0 would indicate the word is 
not in the set (is not composed of <span class="math">\(k\)</span> letters), and a 1 would indicate the opposite.</p>
<p>But here, we keep it simple, since we have a small, known set of words.</p>
<p><a name="first2-variation"></a></p>
<h3>Examining a Variation</h3>
<p>While that's essentially all there is to this algorithm, 
and it takes all of 10 seconds to come up with the idea,
there are some nuances and some bookkeeping details, 
as there are with the design of any algorithm.</p>
<p>For example, compare the following two approaches;
Approach 1 is used in the program, Approach 2 is a less efficient approach:</p>
<div class="highlight"><pre><span></span>    # Approach 1:
    for word in words:
        k = len(set(word))
        lengths[k].append(word)


    # Approach 2:
    for k in range(1,5+1):
        if(len(set(word))==k):
            lengths[k].append(word)
</pre></div>


<p>While these are both <span class="math">\(O(N)\)</span> runtime, the latter approach is inefficient:
we loop over each word five times, and each time we perform the same operation
(turning the letters of a word into a set). </p>
<p>Is there ever a case where we would want an approach like #2?</p>
<p>The short answer is, never.</p>
<p>To give a longer answer, let's consider a case where approach #2 might provide an advantage.
Suppose we were considering a case where <span class="math">\(k\)</span> could be larger - 
a list of 15-letter words, for example, so k could be up to 15 - 
and we were only interested in a particular value, or small set of values, of <span class="math">\(k\)</span>, like 3 and 4.<br>
Approach 1 would store unnecessary intermediate results (the values of k for all words)
and therefore use extra space, compared with approach #2 where we could change the 
for loop to <code>for k in [3,4]:</code>.</p>
<p>Even here, though, approach #2 results in unnecessary work, because approach #1
is still computationally more efficient by looping over the list of words only once,
compared with approach #2, which would loop over the list of words twice.</p>
<p>We may further consider a case where approach #2 would give us an advantage,
and that is the case where we are copying data into the list <code>lengths</code>, instead of 
just storing a reference to a string. 
Because we only deal with references in Python, we aren't making copies in the 
code given above. But because strings are immutable, we could conceivably be 
making copies if we stored <code>word.upper()</code> instead of <code>word</code>.
Approach #2 would use less space, because it only considers the values of k 
that are of interest.</p>
<p>But even here, approach #1 requires only a small modification to wipe out
the space advantage of approach #2: add an if statement before calling the 
append function: <code>if k in [3,4]</code>. Now the calculation of turning a word
into a set of characters is performed only once for approach #1, 
and we don't end up storing unnecessary intermediate results.</p>
<p>The take-home lesson: even if the core idea behind an algorithm is
straightforward, there are still many ways to do it better or worse. </p>
<p><a name="five2-lex"></a></p>
<h2>Lexicographic Ordering of Letters</h2>
<p>Knuth points out that the word "first" contains letters that occur
in lexicograhpic order. Exercise #30 of <a href="https://charlesreid1.com/wiki/AOCP">AOCP</a>
Volume 4 Facsimile 0 asks us to find the first and last such word that occurs 
in Knuth's set of five letter words.</p>
<p>To do this, we'll take each word and turn it into a list of characters.
We'll then sort the characters, and turn the sorted list of characters 
back into a string. If the string constructed from sorted characters
equals the original string, we have our word, formed from lexicographically 
ordered letters.</p>
<p>We can also perform the reverse - search for words whose letters are 
in reverse lexicographic order. One such word is "spied". 
Implementing this task requires a bit more care, 
because of the fact that Python 3 returns generators where Python 2 
would return lists, but we can get around this with the <code>list()</code> function, 
as we shall see shortly.</p>
<p><a name="five2-lexicographic"></a></p>
<h3>Five-Letter Words with Lexicographically Ordered Letters</h3>
<p>Exercise 30 asks us to find the first and last word in the set of 
five letter words whose letters occur in sorted lexicographic order.
We begin by sorting all of the words, and we find the first such word
is "abbey", while the last such word is "pssst".</p>
<p>There are 105 total words that fit this description. 
As we might expect, a majority of them begin with 
letters at the beginning of the alphabet:</p>
<ul>
<li>abbey</li>
<li>abbot</li>
<li>abhor</li>
<li>abort</li>
<li>abuzz</li>
<li>achoo</li>
<li>adder</li>
<li>adept</li>
<li>adios</li>
<li>adopt</li>
<li>aegis</li>
<li>affix</li>
<li>afoot</li>
<li>aglow</li>
<li>ahhhh</li>
<li>allot</li>
<li>allow</li>
<li>alloy</li>
<li>ammos</li>
<li>annoy</li>
<li>beefs</li>
<li>beefy</li>
<li>beeps</li>
<li>beers</li>
<li>beery</li>
<li>befit</li>
<li>begin</li>
<li>begot</li>
<li>bells</li>
<li>belly</li>
<li>below</li>
<li>berry</li>
<li>bills</li>
<li>billy</li>
<li>bitty</li>
<li>blowy</li>
<li>boors</li>
<li>boost</li>
<li>booty</li>
<li>bossy</li>
<li>ceils</li>
<li>cello</li>
<li>cells</li>
</ul>
<p>The full output is here:</p>
<p><a href="https://github.com/charlesreid1/five-letter-words/blob/master/output/lexico">lexico output</a></p>
<p>The code to find these words is given below:</p>
<p><a href="https://github.com/charlesreid1/five-letter-words/blob/master/lexico.py">lexico.py</a></p>
<div class="highlight"><pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">lexico.py</span>

<span class="sd">Donald Knuth, Art of Computer Programming, Volume 4 Facsimile 0</span>
<span class="sd">Exercise #30</span>

<span class="sd">Each letter of the word &quot;first&quot; appears in correct lexicographic order.</span>
<span class="sd">Find the first and last such words in the SGB words.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">get_words</span> <span class="kn">import</span> <span class="n">get_words</span>

<span class="k">def</span> <span class="nf">in_sorted_order</span><span class="p">(</span><span class="n">word</span><span class="p">):</span>
    <span class="n">chars</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">word</span><span class="p">)</span>
    <span class="k">if</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">chars</span><span class="p">)</span><span class="o">==</span><span class="nb">str</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">chars</span><span class="p">))):</span>
        <span class="k">return</span> <span class="bp">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">False</span>

<span class="k">if</span> <span class="vm">__name__</span><span class="o">==</span><span class="s2">&quot;__main__&quot;</span><span class="p">:</span>

    <span class="n">words</span> <span class="o">=</span> <span class="n">get_words</span><span class="p">()</span>
    <span class="n">words</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">words</span><span class="p">)</span>

    <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;-&quot;</span><span class="o">*</span><span class="mi">40</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;ALL lexicographically sorted words:&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">words</span><span class="p">:</span>
        <span class="k">if</span><span class="p">(</span><span class="n">in_sorted_order</span><span class="p">(</span><span class="n">word</span><span class="p">)):</span>
            <span class="k">print</span><span class="p">(</span><span class="n">word</span><span class="p">)</span>
            <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;{0:d} total.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">count</span><span class="p">))</span>

    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;-&quot;</span><span class="o">*</span><span class="mi">40</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">words</span><span class="p">:</span>
        <span class="k">if</span><span class="p">(</span><span class="n">in_sorted_order</span><span class="p">(</span><span class="n">word</span><span class="p">)):</span>
            <span class="k">print</span><span class="p">(</span><span class="s2">&quot;First lexicographically sorted word:&quot;</span><span class="p">)</span>
            <span class="k">print</span><span class="p">(</span><span class="n">word</span><span class="p">)</span>
            <span class="k">break</span>

    <span class="n">words</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>

    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;-&quot;</span><span class="o">*</span><span class="mi">40</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">words</span><span class="p">:</span>
        <span class="k">if</span><span class="p">(</span><span class="n">in_sorted_order</span><span class="p">(</span><span class="n">word</span><span class="p">)):</span>
            <span class="k">print</span><span class="p">(</span><span class="s2">&quot;Last lexicographically sorted word:&quot;</span><span class="p">)</span>
            <span class="k">print</span><span class="p">(</span><span class="n">word</span><span class="p">)</span>
            <span class="k">break</span>
</pre></div>


<p>The heart of the method here is the <code>in_sorted_order()</code> method:
this performs the task, as described above. We take the word 
passed to the function (a string), and turn it into a list 
using the <code>list()</code> function. We then turn this list 
back into a string (which is the same as the variable <code>word</code>),
and compare it to the <em>sorted</em> list of characters, turned back 
into a string, using the call <code>str(sorted(chars))</code>.</p>
<p>If the two match, we have not affected the order of characters
by sorting them in lexicographic (alphabetic) order,
and therefore the original string was in sorted order,
and we return True. Otherwise, we return False.</p>
<p>Here's that method one more time:</p>
<div class="highlight"><pre><span></span>def in_sorted_order(word):
    chars = list(word)
    if(str(chars)==str(sorted(chars))):
        return True
    else:
        return False
</pre></div>


<p><a name="five2-lexicographic"></a></p>
<h3>Five-Letter Words with Lexicographically Reversed Letters</h3>
<p>There are significantly fewer five-letter words whose letters are in 
<em>reverse</em> lexicographic order - 37, compared to the 105 in sorted order.
Here is the full list:</p>
<ul>
<li>mecca</li>
<li>offed</li>
<li>ohhhh</li>
<li>plied</li>
<li>poked</li>
<li>poled</li>
<li>polka</li>
<li>skied</li>
<li>skiff</li>
<li>sniff</li>
<li>soled</li>
<li>solid</li>
<li>sonic</li>
<li>speed</li>
<li>spied</li>
<li>spiff</li>
<li>spoke</li>
<li>spoof</li>
<li>spook</li>
<li>spool</li>
<li>spoon</li>
<li>toked</li>
<li>toned</li>
<li>tonic</li>
<li>treed</li>
<li>tried</li>
<li>troll</li>
<li>unfed</li>
<li>upped</li>
<li>urged</li>
<li>vroom</li>
<li>wheee</li>
<li>wooed</li>
<li>wrong</li>
<li>yoked</li>
<li>yucca</li>
<li>zoned</li>
</ul>
<p>The code to do this requires only minor modifications to the original, sorted order code.</p>
<p>To reverse the procedure, we just need to modify the <code>in_sorted_order()</code> function
to reverse the sorted list of characters before we reassemble it into a string.
We can feed the output of the call to <code>sorted()</code> to the <code>reversed()</code> function.
However, in Python 3, this returns a generator object, which is lazy - 
it does not automatically enumerate every character. Unless, of course, 
we force it to.</p>
<p>That's where the call to <code>list()</code> comes in handy - by passing a generator 
to <code>list()</code>, we force Python to enumerate the output of the reversed, sorted list 
generator. Then we turn the reversed, sorted list into a reversed, sorted string:</p>
<div class="highlight"><pre><span></span>def in_reverse_sorted_order(word):
    chars = list(word)
    # Note: reversed returns a generator,
    # so we have to pass it to list()
    # to explicitly enumerate the reversed results.
    if(str(chars)==str(list(reversed(sorted(chars))))):
        return True
    else:
        return False
</pre></div>


<p>Meanwhile, the rest of the script can stay virtually the same.</p>
<p><a href="https://github.com/charlesreid1/five-letter-words/blob/master/reverse_lexico.py">reverse_lexico.py</a></p>
<div class="highlight"><pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">reverse_lexico.py</span>

<span class="sd">Donald Knuth, Art of Computer Programming, Volume 4 Facsimile 0</span>
<span class="sd">Variation on Exercise #30</span>

<span class="sd">Each letter of the word &quot;spied&quot; appears in reversed lexicographic order.</span>
<span class="sd">Find more words whose letters appear in reverse lexicographic order.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">get_words</span> <span class="kn">import</span> <span class="n">get_words</span>

<span class="k">def</span> <span class="nf">in_reverse_sorted_order</span><span class="p">(</span><span class="n">word</span><span class="p">):</span>
    <span class="n">chars</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">word</span><span class="p">)</span>
    <span class="c1"># Note: reversed returns a generator, </span>
    <span class="c1"># so we have to pass it to list() </span>
    <span class="c1"># to explicitly enumerate the reversed results.</span>
    <span class="k">if</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">chars</span><span class="p">)</span><span class="o">==</span><span class="nb">str</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">chars</span><span class="p">))))):</span>
        <span class="k">return</span> <span class="bp">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">False</span>

<span class="k">if</span> <span class="vm">__name__</span><span class="o">==</span><span class="s2">&quot;__main__&quot;</span><span class="p">:</span>

    <span class="n">words</span> <span class="o">=</span> <span class="n">get_words</span><span class="p">()</span>
    <span class="n">words</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">words</span><span class="p">)</span>

    <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;-&quot;</span><span class="o">*</span><span class="mi">40</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;ALL lexicographically reversed words:&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">words</span><span class="p">:</span>
        <span class="k">if</span><span class="p">(</span><span class="n">in_reverse_sorted_order</span><span class="p">(</span><span class="n">word</span><span class="p">)):</span>
            <span class="k">print</span><span class="p">(</span><span class="n">word</span><span class="p">)</span>
            <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;{0:d} total.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">count</span><span class="p">))</span>

    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;-&quot;</span><span class="o">*</span><span class="mi">40</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">words</span><span class="p">:</span>
        <span class="k">if</span><span class="p">(</span><span class="n">in_reverse_sorted_order</span><span class="p">(</span><span class="n">word</span><span class="p">)):</span>
            <span class="k">print</span><span class="p">(</span><span class="s2">&quot;First reverse lexicographically sorted word:&quot;</span><span class="p">)</span>
            <span class="k">print</span><span class="p">(</span><span class="n">word</span><span class="p">)</span>
            <span class="k">break</span>

    <span class="n">words</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>

    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;-&quot;</span><span class="o">*</span><span class="mi">40</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">words</span><span class="p">:</span>
        <span class="k">if</span><span class="p">(</span><span class="n">in_reverse_sorted_order</span><span class="p">(</span><span class="n">word</span><span class="p">)):</span>
            <span class="k">print</span><span class="p">(</span><span class="s2">&quot;Last lexicographically sorted word:&quot;</span><span class="p">)</span>
            <span class="k">print</span><span class="p">(</span><span class="n">word</span><span class="p">)</span>
            <span class="k">break</span>
</pre></div>


<p><a name="five2-findpalindromes"></a></p>
<h2>Finding Palindromes</h2>
<p>Palindromes are words or sets of words that have a reflective property,
namely, they spell the same thing forward and reverse (e.g., "race car",
or "Ere I was able, I saw Malta", or "Doc, note I dissent - a fast never prevents a fatness. I diet on cod.").</p>
<p>In Exercise 29, Knuth asks the reader to perform a straightforward task - 
find the palindromes in the list of five letter words. (An example of one such
word is "kayak".) But Knuth goes further, and points out that palindromes 
can <em>also</em> be formed from pairs of words.  He gives the example "regal lager".
He asks the reader to find all palindrome pairs as well.</p>
<p>When working on these exercises, we became curious about palindromic near-misses.
How many words are <em>almost</em> palindromes? (Example: "going" is very close to a 
palindrome, if we just changed the n to an o or vice-versa.)
In fact, we already have all the tools we need at our disposal,
as we already covered a script to perform a Euclidean distance calculation.</p>
<p>We will cover Python code to find words that fit into each of these categories,
and provide some interesting examples. (One of the most surprising things
to us was just how many words meet these criteria!)</p>
<p><a name="five2-palindromes"></a></p>
<h3>Palindromes</h3>
<p>The first task is finding palindromes in the set of five letter words.
There are 18 such words. They are given below:</p>
<ul>
<li>level</li>
<li>refer</li>
<li>radar</li>
<li>madam</li>
<li>rotor</li>
<li>civic</li>
<li>sexes</li>
<li>solos</li>
<li>sagas</li>
<li>kayak</li>
<li>minim</li>
<li>tenet</li>
<li>shahs</li>
<li>stats</li>
<li>stets</li>
<li>kaiak</li>
<li>finif</li>
<li>dewed </li>
</ul>
<p>The code to check if a word is a palindrome consists of two simple logical test:
Is the character at position 0 equal to the character at position 4?
Is the character at position 1 equal to the character at position 3?
If both of these are true, the word is a palindrome. Here's the Python function
to check if a word is a palindrome:</p>
<p><a href="https://github.com/charlesreid1/five-letter-words/blob/master/palindromes.py">palindromes.py</a></p>
<div class="highlight"><pre><span></span>def is_palindrome(word):
    test1 = word[0]==word[4]
    test2 = word[1]==word[3]
    if(test1 and test2):
        return True
    return False
</pre></div>


<p>and the main driver method, which actually runs the function on each word:</p>
<div class="highlight"><pre><span></span>if __name__==&quot;__main__&quot;:
    words = get_words()

    kp = 0
    palindromes = []

    # Check for palindromes
    for i in range(len(words)):
        if(is_palindrome(words[i])):
            kp += 1
            palindromes.append(words[i])

    print(&quot;-&quot;*40)
    print(&quot;Palindromes: \n&quot;)
    print(&quot;, &quot;.join(palindromes))
    print(&quot;There are {0:d} palindromes.&quot;.format(kp))
</pre></div>


<p><a name="five2-palindromepairs"></a></p>
<h3>Palindrome Pairs</h3>
<p>There are 34 palindromic pairs, if we disallow palindromes from being
considered palindromic pairs with themselves. These are:</p>
<ul>
<li>parts, strap</li>
<li>lived, devil</li>
<li>speed, deeps</li>
<li>sleep, peels</li>
<li>straw, warts</li>
<li>faced, decaf</li>
<li>spots, stops</li>
<li>fires, serif</li>
<li>lever, revel</li>
<li>smart, trams</li>
<li>ports, strop</li>
<li>pools, sloop</li>
<li>stool, loots</li>
<li>draws, sward</li>
<li>mined, denim</li>
<li>spins, snips</li>
<li>alley, yella</li>
<li>loops, spool</li>
<li>sleek, keels</li>
<li>repel, leper</li>
<li>snaps, spans</li>
<li>depot, toped</li>
<li>timed, demit</li>
<li>debut, tubed</li>
<li>laced, decal</li>
<li>stink, knits</li>
<li>regal, lager</li>
<li>tuber, rebut</li>
<li>remit, timer</li>
<li>pacer, recap</li>
<li>snoot, toons</li>
<li>namer, reman</li>
<li>hales, selah</li>
<li>tarps, sprat</li>
</ul>
<p>The code to check for palindrome pairs is a little more involved,
but also consists of a few logical tests to see if letters in 
one position of the first word match letters in another position of 
the second word:</p>
<p><a href="https://github.com/charlesreid1/five-letter-words/blob/master/palindromes.py">palindromes.py</a></p>
<div class="highlight"><pre><span></span>def is_palindrome_pair(word1,word2):
    test0 = word1[0]==word2[4]
    test1 = word1[1]==word2[3]
    test2 = word1[2]==word2[2]
    test3 = word1[3]==word2[1]
    test4 = word1[4]==word2[0]
    if(test0 and test1 and test2 and test3 and test4):
        return True
    return False
</pre></div>


<p>and the main driver method:</p>
<div class="highlight"><pre><span></span>if __name__==&quot;__main__&quot;:
    words = get_words()

    kpp = 0
    palindrome_pairs = []

    # Check for palindrome pairs
    for i in range(len(words)):
        for j in range(i,len(words)):
            if(is_palindrome_pair(words[i],words[j])):
                # Palindromes shouldn&#39;t count as palindrome pairs
                if(words[i] is not words[j]):
                    kpp += 1
                    palindrome_pairs.append((words[i],words[j]))

    print(&quot;-&quot;*40)
    print(&quot;Palindrome Pairs: \n&quot;)
    for pair in palindrome_pairs:
        print(&quot;, &quot;.join(pair))
    print(&quot;There are {0:d} palindrome pairs.&quot;.format(kpp))
</pre></div>


<p><a name="five2-nearpalindromes"></a></p>
<h3>Near Palindromes</h3>
<p>A near-palindrome is a word that would be a palindrome,
if one of its letters were slightly modified. We use a 
"tolerance" parameter to specify how much modification 
we are willing to live with to consider a word a 
near-palindrome.</p>
<p>There are several ways to do this, but we'll keep it simple:
we consider the totla number of changes to all characters in the word
required to make a word a palindrome, and test whether the changes
required to make the word a palindrome are less than or equal to 
a specified parameter, tolerance.</p>
<p>For example, if our tolerance were 1, we would consider the 
words "going" and "moron" to be near-palindromes; 
if our tolerance were 2, we would consider the words
"tsars" and "jewel" to be near-palindromes.</p>
<p>Here is the list of 37 off-by-one palindromes:</p>
<ul>
<li>going</li>
<li>seeds</li>
<li>tight</li>
<li>trust</li>
<li>suits</li>
<li>sends</li>
<li>plump</li>
<li>slums</li>
<li>sighs</li>
<li>erase</li>
<li>serfs</li>
<li>soaps</li>
<li>sewer</li>
<li>soups</li>
<li>sever</li>
<li>slams</li>
<li>scabs</li>
<li>moron</li>
<li>ceded</li>
<li>scads</li>
<li>suets</li>
<li>fugue</li>
<li>seder</li>
<li>tryst</li>
<li>educe</li>
<li>twixt</li>
<li>tutus</li>
<li>shags</li>
<li>slims</li>
<li>abaca</li>
<li>anima</li>
<li>celeb</li>
<li>selfs</li>
<li>scuds</li>
<li>tikis</li>
<li>topos</li>
<li>rajas</li>
</ul>
<p>and the list of off-by-two palindromes:</p>
<ul>
<li>often</li>
<li>stars</li>
<li>sight</li>
<li>visit</li>
<li>towns</li>
<li>climb</li>
<li>flame</li>
<li>reads</li>
<li>sings</li>
<li>hatch</li>
<li>tends</li>
<li>naval</li>
<li>robot</li>
<li>reeds</li>
<li>cocoa</li>
<li>stout</li>
<li>spins</li>
<li>onion</li>
<li>sinks</li>
<li>edged</li>
<li>spurs</li>
<li>jewel</li>
<li>snaps</li>
<li>silks</li>
<li>nasal</li>
<li>theft</li>
<li>pagan</li>
<li>reefs</li>
<li>stirs</li>
<li>snips</li>
<li>tufts</li>
<li>truss</li>
<li>strut</li>
<li>spans</li>
<li>smelt</li>
<li>spars</li>
<li>flake</li>
<li>rusts</li>
<li>skims</li>
<li>sways</li>
<li>runts</li>
<li>tsars</li>
<li>tress</li>
<li>feted</li>
<li>rends</li>
<li>romps</li>
<li>cilia</li>
<li>ephod</li>
<li>fluke</li>
<li>reset</li>
<li>farad</li>
<li>peter</li>
<li>natal</li>
<li>thugs</li>
<li>newel</li>
<li>paean</li>
<li>emend</li>
<li>snoot</li>
<li>fiche</li>
<li>porno</li>
<li>flume</li>
<li>toons</li>
<li>roans</li>
<li>offen</li>
<li>klunk</li>
<li>feued</li>
<li>nihil</li>
<li>pavan</li>
<li>relet</li>
<li>heigh</li>
<li>revet</li>
<li>sicks</li>
<li>spoor</li>
</ul>
<p>The check for near-palindromes follows the palindrome test 
fairly closely, except instead of checking if letters in two positions
are equal, we check of those two letters are a certain specified 
distance from one another.</p>
<p>Here is the code for finding near-palindromes:</p>
<div class="highlight"><pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">near_palindromes.py</span>

<span class="sd">Donald Knuth, Art of Computer Programming, Volume 4 Facsimile 0</span>
<span class="sd">Variation on Exercise #29</span>

<span class="sd">Find SGB words that are near-palindromes</span>
<span class="sd">(edit distance of one or two letters away from a palindrome).</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">get_words</span> <span class="kn">import</span> <span class="n">get_words</span>
<span class="kn">from</span> <span class="nn">euclidean_distance</span> <span class="kn">import</span> <span class="n">euclidean_distance</span>
<span class="kn">from</span> <span class="nn">pprint</span> <span class="kn">import</span> <span class="n">pprint</span>

<span class="k">def</span> <span class="nf">is_near_palindrome</span><span class="p">(</span><span class="n">word</span><span class="p">,</span><span class="n">lo</span><span class="p">,</span><span class="n">hi</span><span class="p">):</span>
    <span class="n">d1</span> <span class="o">=</span> <span class="n">euclidean_distance</span><span class="p">(</span><span class="n">word</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">word</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span>
    <span class="n">d2</span> <span class="o">=</span> <span class="n">euclidean_distance</span><span class="p">(</span><span class="n">word</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">word</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>

    <span class="k">if</span><span class="p">(</span> <span class="p">(</span><span class="n">d1</span><span class="o">+</span><span class="n">d2</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">lo</span> <span class="ow">and</span> <span class="p">(</span><span class="n">d1</span><span class="o">+</span><span class="n">d2</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">hi</span> <span class="p">):</span>
        <span class="k">return</span> <span class="bp">True</span>

    <span class="k">return</span> <span class="bp">False</span>

<span class="k">if</span> <span class="vm">__name__</span><span class="o">==</span><span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">words</span> <span class="o">=</span> <span class="n">get_words</span><span class="p">()</span>

    <span class="n">knp</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">near_palindromes</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># Euclidean distance tolerance</span>
    <span class="n">lo</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="n">hi</span> <span class="o">=</span> <span class="mf">1.0</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">words</span><span class="p">)):</span>
        <span class="k">if</span><span class="p">(</span><span class="n">is_near_palindrome</span><span class="p">(</span><span class="n">words</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">lo</span><span class="p">,</span><span class="n">hi</span><span class="p">)):</span>
            <span class="n">knp</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">near_palindromes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">words</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;-&quot;</span><span class="o">*</span><span class="mi">40</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;Near Palindromes: </span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">near_palindromes</span><span class="p">))</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;The number of near-palindromes is {0:d}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">near_palindromes</span><span class="p">)))</span>
</pre></div>


<p><a name="five2-references"></a></p>
<h2>References</h2>
<ol>
<li>
<p>Knuth, Donald. <u>The Art of Computer Programming</u>. Upper Saddle River, NJ: Addison-Wesley, 2008.</p>
</li>
<li>
<p>Knuth, Donald. <u>The Stanford GraphBase: A Platform for Combinatorial Computing</u>. New York: ACM Press, 1994. 
&lt;<a href="http://www-cs-faculty.stanford.edu/~knuth/sgb.html">http://www-cs-faculty.stanford.edu/~knuth/sgb.html</a>&gt;</p>
</li>
<li>
<p>"Five Letter Words." Git repository, git.charlesreid1.com. Charles Reid. Updated 1 September 2017.
&lt;<a href="http://git.charlesreid1.com/cs/five-letter-words">http://git.charlesreid1.com/cs/five-letter-words</a>&gt;</p>
</li>
</ol>
<script type="text/javascript">if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width < 768) ? "left" : align;
        indent = (screen.width < 768) ? "0em" : indent;
        linebreak = (screen.width < 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' && location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
</script></div>

    </div>
</div>

<div class="v20"></div>

<div class="row">
    <div class="col-md-12" style="text-align: left;">

        <div class="tags">
            <p>Tags:&nbsp;&nbsp;&nbsp;
                    <a href="/tag/python.html">python</a>
                    &nbsp;&nbsp;
                    <a href="/tag/computer-science.html">computer science</a>
                    &nbsp;&nbsp;
                    <a href="/tag/graphs.html">graphs</a>
                    &nbsp;&nbsp;
                    <a href="/tag/algorithms.html">algorithms</a>
                    &nbsp;&nbsp;
                    <a href="/tag/art-of-computer-programming.html">art of computer programming</a>
                    &nbsp;&nbsp;
                    <a href="/tag/knuth.html">knuth</a>
                    &nbsp;&nbsp;
                    <a href="/tag/language.html">language</a>
                    &nbsp;&nbsp;
        </div>

    </div>
</div>


<div class="v200"></div>

</div>


<script type="text/javascript" src="/theme/js/jquery-1.11.2.js"></script>
<script type="text/javascript" src="/theme/js/bootstrap-3.3.4.js"></script>
<script type="text/javascript" src="/theme/js/d3-3.5.5.js"></script>
<!--
<script type="text/javascript" src="/theme/js/leaflet-0.7.3.js"></script>
<script type="text/javascript" src="/theme/js/leaflet.ajax.min.js"></script>
--><script type="text/javascript" src="/theme/js/jquery-1.11.2.js"></script>
<script type="text/javascript" src="/theme/js/bootstrap-3.3.4.js"></script>

<footer id="contentinfo" class="body">
<p>&nbsp;</p>
<p>&nbsp;</p>
<center>
	<hr />
</center>
<p>&nbsp;</p>
<p style="text-align: center">
    <span class="fa-stack fa-lg">
        <i class="fa fa-square fa-stack-2x" style="color:#000;"></i>
        <i class="fa fa-terminal fa-stack-1x fa-inverse"></i>
    </span>
    Made from the command line with vim by 
    <a href="http://charlesreid1.com">charlesreid1</a><br />
    with help from <a href="https://getbootstrap.com/">Bootstrap</a> and <a href="http://getpelican.com">Pelican</a>.
</p>

<br />

<p style="text-align: center">
    <a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/">
    <span class="fa-stack fa-lg">
        <i class="fa fa-square fa-stack-2x" style="color:#000;"></i>
        <i class="fa fa-creative-commons fa-stack-1x fa-inverse"></i>
    </span>
    </a>
    <br />
    Licensed under the <a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/">Creative Commons Attribution-NonCommercial 4.0 License</a>.
</p>

<!-- Start of StatCounter Code for Default Guide -->
<script type="text/javascript">
var sc_project=11611748;
var sc_invisible=1;
var sc_security="9fcba820";
</script>
<script type="text/javascript"
src="https://www.statcounter.com/counter/counter.js"
async></script>

<noscript><div class="statcounter"><a title="Web Analytics"
href="http://statcounter.com/" target="_blank"><img
class="statcounter"
src="//c.statcounter.com/11611748/0/9fcba820/1/" alt="Web
Analytics"></a></div></noscript>
<!-- End of StatCounter Code for Default Guide -->
</footer><!-- /#contentinfo -->
</body>
</html>