<!DOCTYPE html>
<html lang="en">
<head>
        <title>charlesreid1</title>
        <meta charset="utf-8" />

        <!--
        CSS styles
        -->
        <link href="/theme/css/bootstrap.css"       rel="stylesheet" type="text/css">
        <!--
        <link href="/theme/css/cyborg.css"          rel="stylesheet" type="text/css">
        <link href="/theme/css/cosmo.css"           rel="stylesheet" type="text/css">
        <link href="/theme/css/sandstone.css"       rel="stylesheet" type="text/css">
        -->
        <link href="/theme/css/slate.css"              rel="stylesheet" type="text/css">
        <link href="/theme/css/font-awesome.css"       rel="stylesheet" type="text/css"/>
        <link href="/theme/css/pygment-solarized.css"  rel="stylesheet" type="text/css"/>


        <!--
        my CSS styles
        -->
        <link href="/theme/css/main.css"            rel="stylesheet" type="text/css">
        <link href="/theme/css/dox.css"             rel="stylesheet" type="text/css">


        <!--
        include Angular first
        -->
        <script type="text/javascript" src="/theme/js/angular-1.3.15.js"></script>
        <script type="text/javascript" src="/theme/js/skrollr-0.6.29.js"></script>
        <script type="text/javascript" src="/theme/js/d3-3.5.5.js"></script>

        <!--
        this seems like a bad idea.
        but if I don't put jquery first, I get errors about unrecognized $s.
        -->
        <script type="text/javascript" src="/theme/js/jquery-1.11.2.js"></script>

</head>
<body id="index">
<nav class="navbar navbar-default">
    <div class="container-fluid">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#myNavbar">
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span> 
            </button>
            <a href="/" class="navbar-brand">charlesreid1.com</a>
        </div>
        <div>
            <div class="collapse navbar-collapse" id="myNavbar">
                <ul class="nav navbar-nav">

                    <li>
                        <a href="https://charlesreid1.com/wiki">Wiki</a>
                    </li>
                    <li>
                        <a href="https://charlesreid1.com:3000/explore">Git.charlesreid1.com</a>
                    </li>
                    <li>
                        <a href="https://github.com/charlesreid1/charlesreid1-awesome/">charlesreid1 Awesome List</a>
                    </li>
                    <li>
                        <a href="https://charlesreid1.com/notes">Notes</a>
                    </li>
                    <li>
                        <a href="https://charlesreid1.github.io">Blog</a>
                    </li>
                    <li>
                        <a href="https://charlesreid1.com/contact">Contact Me</a>
                    </li>

                </ul>
            </div>
        </div>
    </div>
</nav>



<div class="container">

<header>
<div class="row">


    <div class="col-md-12">
        <div class="headtext" style="text-align: center;">
            <h1><b>
                Fixing Bottlenecks in the Guava Traveling Salesperson Problem Code
            </b></h1>
        
            <p class="lead">
                Posted 
                <time datetime="2017-03-29T14:00:00-07:00" pubdate>Wednesday 03/29/2017</time>
                in 
                <a href="/category/java.html">Java</a>
                </p>
            <p>
            <span style="font-size: 14px">
                <a href="/fixing-bottlenecks-in-the-guava-traveling-salesperson-problem-code.html">permalink</a>
            </span>
            </p>
        </div>

    </div>

</div>
</header>


<div class="v50"></div>


<div class="row">
    <div class="col-md-12" style="text-align: left;">

        <div class="entry-content"><ul>
<li><a href="#tsp2-intro">Intro</a></li>
<li><a href="#tsp2-graphs">The Graphs We Are Solving</a><ul>
<li><a href="#tsp2-viz-graphs">Visualizations of Graphs</a></li>
</ul>
</li>
<li><a href="#tsp2-guava-tsp-soln">Guava TSP Solution</a><ul>
<li><a href="#tsp2-timing-guava-tsp">Timing the TSP Solution</a></li>
</ul>
</li>
<li><a href="#tsp2-improving">Improving the Guava TSP Solution</a><ul>
<li><a href="#tsp2-flaw">The Flaw</a></li>
<li><a href="#tsp2-fixing">Fixing the Flaw</a></li>
<li><a href="#tsp2-pessimist">The Pessimist Algorithm</a></li>
</ul>
</li>
<li><a href="#tsp2-timing">Timing Results</a></li>
<li><a href="#tsp2-future">Future Work</a></li>
</ul>
<p><a name="tsp2-intro"></a></p>
<h2>Intro</h2>
<p>In a prior blog post we introduced you to the traveling salesperson problem (TSP),
which involves finding the shortest path through every city in a group of cities
connected by a network of roads. Using Google Guava, we have implemented a solution 
to the TSP in Java.</p>
<p>Our philosophy toward timing, profiling, and optimization is that it is always best 
to work from data - and timing is the first place to begin collecting data.
As we will show in this blog post, simply timing your function for different problem sizes
can reveal scaling behavior that indicates bottlenecks, bugs, or inefficiencies in the algorithm.</p>
<p>In this post, we use simple timing tools and a spreadsheet 
to plot scaling behavior and identify bottlenecks in the 
traveling salesperson problem code. Fixing the bottleneck
led to a reduction in cost of <strong>two orders of magnitude</strong>.</p>
<p>Here's a preview:</p>
<p><img alt="TSP Guava Solution scaling results - initial and pessimist algorithms" src="/images/tsp-guava-initial-pessimist.png"></p>
<p>In this post we'll cover what we did to time the problem,
the initial results, and the algorithm improvement that led to 
the massive performance improvement.</p>
<p>But first, let's look at some of the graphs that are being solved.</p>
<p><a name="tsp2-graphs"></a></p>
<h2>The Graphs We Are Solving</h2>
<p>Let's start by having a look at some of the graphs we will be solving,
and the representation of the problem.</p>
<p><a name="tsp2-viz-graphs"></a></p>
<h3>Visualizations of Graphs</h3>
<p>The first few graphs start out simple: here is a randomly generated 4-node traveling salesman problem
(we wil cover the code that generates the graph pictured here in a moment):</p>
<p><img alt="TSP graph with 4 nodes" src="/images/graphviz_tsp_4.png"></p>
<p><strong>Shortest Route: [0, 2, 3, 1] Distance: 112.0</strong></p>
<p>Here is another randomly generated graph with 5 nodes:</p>
<p><img alt="TSP graph with 5 nodes" src="/images/graphviz_tsp_5.png"></p>
<p><strong>Shortest Route: [0, 4, 2, 1, 3]   Distance: 130.0</strong></p>
<p>With 6 nodes:</p>
<p><img alt="TSP graph with 6 nodes" src="/images/graphviz_tsp_6.png"></p>
<p><strong>Shortest Route: [0, 2, 4, 1, 5, 3]    Distance: 163.0</strong></p>
<p>But problem of this sise are still trivially easy for a processor to handle.
Our inefficient, first-pass algorithm started to show signs of eating up CPU cycles 
at around 9 nodes (albeit less than 1 second). Here is the graph with 9 nodes:</p>
<p><img alt="TSP graph with 9 nodes" src="/images/graphviz_tsp_9.png"></p>
<p><strong>Shortest Route: [0, 6, 1, 7, 3, 2, 5, 8, 4]   Distance: 166.0</strong></p>
<p>With 12 nodes:</p>
<p><img alt="TSP graph with 12 nodes" src="/images/graphviz_tsp_12.png"></p>
<p><strong>Shortest Route: [0, 7, 5, 4, 1, 8, 6, 10, 11, 9, 3, 2]    Distance: 236.0</strong></p>
<p>At 14 nodes, even the efficient algorithm crosses the 1 second threshold.</p>
<p><img alt="TSP graph with 14 nodes" src="/images/graphviz_tsp_14.png"></p>
<p><strong>Shortest Route: [0, 2, 6, 10, 13, 12, 7, 4, 1, 11, 5, 3, 9, 8]    Distance: 277.0</strong></p>
<p>We tested randomly-generated, fully-connected graphs of up to 18 nodes, 
and the algorithm was able to compute solutions within a few minutes.
Here is an 18-node graph:</p>
<p><img alt="TSP graph with 18 nodes" src="/images/graphviz_tsp_18.png"></p>
<p><strong>Shortest Route: [0, 3, 10, 6, 12, 5, 11, 2, 14, 8, 13, 4, 7, 1, 9]    Distance: 267.0</strong></p>
<p><a name="tsp2-guava-tsp-soln"></a></p>
<h2>The Guava TSP Solution</h2>
<p>In a prior post we covered the implementation of a solution to the TSP 
using Guava's Network objects. This implementation utilized a recursive
depth-first search algorithm to search for the shortest path among all nodes.</p>
<p>To recap, here was our pseudocode for the TSP solution:</p>
<div class="highlight"><pre><span></span>explore(neighbors):

    if(no more unvisited neighbors):
        # This is the base case.
        if total distance is less than current minimum:
            save path and new minimum

    else:
        # This is the recursive case.
        for neighbor in unvisited neighbors:
            visit neighbor
            explore(new_neighbors)
            unvisit neighbor
</pre></div>


<p>And here is what the recursive backtracking <code>explore()</code> method looked like
when implemented in Java:</p>
<div class="highlight"><pre><span></span>    <span class="cm">/** Recursive backtracking method: explore possible solutions starting at this node, having made nchoices */</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">explore</span><span class="o">(</span><span class="n">Node</span> <span class="n">node</span><span class="o">,</span> <span class="kt">int</span> <span class="n">nchoices</span><span class="o">)</span> <span class="o">{</span>

        <span class="k">if</span><span class="o">(</span><span class="n">nchoices</span> <span class="o">==</span> <span class="n">graphSize</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// </span>
            <span class="c1">// BASE CASE</span>
            <span class="c1">//</span>
            <span class="k">if</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">this_distance</span> <span class="o">&lt;</span> <span class="k">this</span><span class="o">.</span><span class="na">min_distance</span> <span class="o">||</span> <span class="k">this</span><span class="o">.</span><span class="na">min_distance</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// Solution base case</span>
                <span class="k">this</span><span class="o">.</span><span class="na">min_distance</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">this_distance</span><span class="o">;</span>
                <span class="n">printSolution</span><span class="o">();</span>
            <span class="o">}</span>

        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="c1">//</span>
            <span class="c1">// RECURSIVE CASE</span>
            <span class="c1">//  </span>
            <span class="n">Set</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span> <span class="n">neighbors</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="na">adjacentNodes</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>
            <span class="k">for</span><span class="o">(</span><span class="n">Node</span> <span class="n">neighbor</span> <span class="o">:</span> <span class="n">neighbors</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">if</span><span class="o">(</span><span class="n">neighbor</span><span class="o">.</span><span class="na">visited</span> <span class="o">==</span> <span class="kc">false</span><span class="o">)</span> <span class="o">{</span>

                    <span class="kt">int</span> <span class="n">distance_btwn</span> <span class="o">=</span> <span class="o">-</span><span class="mi">10000</span><span class="o">;</span>

                    <span class="k">for</span><span class="o">(</span> <span class="n">Edge</span> <span class="n">edge</span> <span class="o">:</span> <span class="n">graph</span><span class="o">.</span><span class="na">edgesConnecting</span><span class="o">(</span><span class="n">node</span><span class="o">,</span> <span class="n">neighbor</span><span class="o">)</span> <span class="o">)</span> <span class="o">{</span>
                        <span class="n">distance_btwn</span> <span class="o">=</span> <span class="n">edge</span><span class="o">.</span><span class="na">value</span><span class="o">;</span>
                    <span class="o">}</span>

                    <span class="c1">// Make a choice</span>
                    <span class="k">this</span><span class="o">.</span><span class="na">route</span><span class="o">[</span><span class="n">nchoices</span><span class="o">]</span> <span class="o">=</span> <span class="n">neighbor</span><span class="o">.</span><span class="na">id</span><span class="o">;</span>
                    <span class="n">neighbor</span><span class="o">.</span><span class="na">visit</span><span class="o">();</span>
                    <span class="k">this</span><span class="o">.</span><span class="na">this_distance</span> <span class="o">+=</span> <span class="n">distance_btwn</span><span class="o">;</span>

                    <span class="c1">// Explore the consequences</span>
                    <span class="n">explore</span><span class="o">(</span><span class="n">neighbor</span><span class="o">,</span><span class="n">nchoices</span><span class="o">+</span><span class="mi">1</span><span class="o">);</span>

                    <span class="c1">// Unmake the choice</span>
                    <span class="k">this</span><span class="o">.</span><span class="na">route</span><span class="o">[</span><span class="n">nchoices</span><span class="o">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
                    <span class="n">neighbor</span><span class="o">.</span><span class="na">unvisit</span><span class="o">();</span>
                    <span class="k">this</span><span class="o">.</span><span class="na">this_distance</span> <span class="o">-=</span> <span class="n">distance_btwn</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="c1">// Move on to the next choice (continue loop)</span>
            <span class="o">}</span>               
        <span class="o">}</span> <span class="c1">// End base/recursive case</span>
    <span class="o">}</span>
</pre></div>


<p>Note: full TSP code available at <a href="http://git.charlesreid1.com/charlesreid1/tsp">http://git.charlesreid1.com/charlesreid1/tsp</a>.</p>
<p><a name="tsp2-timing-guava-tsp"></a></p>
<h3>Timing the TSP Solution</h3>
<p>To time the Guava solution to the TSP, we utilized Java's system time
to measure the amount of time it took to compute solutions, 
excluding the time spent on graph construction.</p>
<p>Here is the code that performs the timing of the call to the explore method:</p>
<div class="highlight"><pre><span></span>    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">IllegalArgumentException</span> <span class="o">{</span> 

        <span class="o">...</span>

        <span class="kt">double</span> <span class="n">conn</span> <span class="o">=</span> <span class="mf">1.00</span><span class="o">;</span>
        <span class="n">TSP</span> <span class="n">t</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TSP</span><span class="o">(</span><span class="n">N</span><span class="o">,</span><span class="n">conn</span><span class="o">);</span>

        <span class="kt">long</span> <span class="n">start</span> <span class="o">=</span> <span class="n">System</span><span class="o">.</span><span class="na">nanoTime</span><span class="o">();</span>
        <span class="n">t</span><span class="o">.</span><span class="na">solve</span><span class="o">();</span>
        <span class="kt">long</span> <span class="n">end</span> <span class="o">=</span> <span class="n">System</span><span class="o">.</span><span class="na">nanoTime</span><span class="o">();</span>
        <span class="kt">long</span> <span class="n">duration</span> <span class="o">=</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="o">;</span>

        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span><span class="s">&quot;Elapsed time %03f s\n &quot;</span><span class="o">,</span> <span class="o">(</span><span class="n">duration</span><span class="o">/</span><span class="mf">1E9</span><span class="o">)</span> <span class="o">);</span>
    <span class="o">}</span>
</pre></div>


<p>The elapsed time is computed using <code>System.nanoTime()</code>.</p>
<p>Writing a script to feed variable size graphs and time the resulting code 
showed some pretty awful scaling behavior: </p>
<p><img alt="Java Guava TSP Solution Scaling" src="/images/tsp-java-scaling.png"></p>
<p>This scaling behavior reveals a bottleneck in the algorithm:
the algorithm scales the same way the problem size scales.
A more efficient algorithm would be capable of ruling out 
more of the solution space as the graph size grows,
allowing the algorithm to scale better at large problem sizes.</p>
<p>This led to some reconsideration of the algorithm.</p>
<p><a name="tsp2-improving"></a></p>
<h2>Improving the Guava TSP Solution</h2>
<p>The original TSP algorithm implemented a subtle flaw - 
not by implementing a mistake in the calculation, 
but by ignoring an important piece of information.</p>
<p><a name="tsp2-theflaw"></a></p>
<h3>The Flaw</h3>
<p>As the recursive depth-first search traverses the graph, the algorithm is checking if all nodes have been traversed.
When all nodes have been traversed, it then compares the distance of that journey to the current shortest journey.
If the new journey is shorter, it is saved as the new shortest journey, otherwise it is ignored and we move on.</p>
<p>What this ignores is the fact that any path, at any point, can be checked to see if it is 
longer than the current minimum, and if it is, any possibilities that follow from it can be skipped.</p>
<p>For example, consider the TSP on a graph of six cities, A B C D E F.</p>
<p>Suppose that the algorithm is in the midst of the recursive backtracking solution,
and has a current minimum distance and minimum path of the route <code>A-B-E-D-C-F</code>, which is 24 miles.</p>
<p>Now suppose that the algorithm is searching for solutions that begin with the choice <code>A-E-C</code>,
and the distance <code>A-E-C</code> is 28 miles.</p>
<p>The naive algorithm ignores this information, and continues choosing from among the 
3 remaining cities, computing the total length for <span class="math">\(3! = 6\)</span> additional routes, and finding 
that all six of them do not work.</p>
<p>The smart algorithm checks <em>each time it chooses a new node</em> whether the length of the current route
exceeds the current minimum route distance (if one has been found/set).
If not, the algorithm keeps going, but if so, it skips choosing neighbors 
and returns directly to the parent caller.</p>
<p><a name="tsp2-fixing"></a></p>
<h3>Fixing the Flaw</h3>
<p>Fixing the flaw is surpsingly easy: we just add an if statement.</p>
<p>Illustrating first with the pseudocode:</p>
<div class="highlight"><pre><span></span>explore(neighbors):

    if(no more unvisited neighbors):
        # This is the base case.
        if total distance is less than current minimum:
            save path and new minimum

    else:
        # This is the recursive case.
        if current distance is greater than current minimum:
            skip
        else:
            for neighbor in unvisited neighbors:
                visit neighbor
                explore(new_neighbors)
                unvisit neighbor
</pre></div>


<p>In our Java implementation, the algorithm simply prints out solutions as it goes,
then returns to the calling function whether a solution was found or not.
Thus, we can "skip" a set of solutions by just returning to the calling function,
using a <code>return</code> statement.</p>
<div class="highlight"><pre><span></span>        <span class="k">if</span><span class="o">(</span><span class="n">nchoices</span> <span class="o">==</span> <span class="n">graphSize</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// </span>
            <span class="c1">// BASE CASE</span>
            <span class="c1">//</span>
            <span class="k">if</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">this_distance</span> <span class="o">&lt;</span> <span class="k">this</span><span class="o">.</span><span class="na">min_distance</span> <span class="o">||</span> <span class="k">this</span><span class="o">.</span><span class="na">min_distance</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// Solution base case:</span>
                <span class="k">this</span><span class="o">.</span><span class="na">min_distance</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">this_distance</span><span class="o">;</span>
                <span class="n">printSolution</span><span class="o">();</span>
            <span class="o">}</span>

        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="c1">//</span>
            <span class="c1">// RECURSIVE CASE</span>
            <span class="c1">//  </span>

            <span class="cm">/* </span>
<span class="cm">             * The following lines result in a huge computational cost savings.</span>
<span class="cm">            */</span>
            <span class="k">if</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">min_distance</span><span class="o">&gt;</span><span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="k">this</span><span class="o">.</span><span class="na">this_distance</span><span class="o">&gt;</span><span class="k">this</span><span class="o">.</span><span class="na">min_distance</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// Just give up already. It&#39;s meaningless. There&#39;s no point.</span>
                <span class="k">return</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="c1">// Everything else stays exactly the same</span>
            <span class="n">Set</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span> <span class="n">neighbors</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="na">adjacentNodes</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>
            <span class="k">for</span><span class="o">(</span><span class="n">Node</span> <span class="n">neighbor</span> <span class="o">:</span> <span class="n">neighbors</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">if</span><span class="o">(</span><span class="n">neighbor</span><span class="o">.</span><span class="na">visited</span> <span class="o">==</span> <span class="kc">false</span><span class="o">)</span> <span class="o">{</span>

                    <span class="kt">int</span> <span class="n">distance_btwn</span> <span class="o">=</span> <span class="o">-</span><span class="mi">10000</span><span class="o">;</span>

                    <span class="k">for</span><span class="o">(</span> <span class="n">Edge</span> <span class="n">edge</span> <span class="o">:</span> <span class="n">graph</span><span class="o">.</span><span class="na">edgesConnecting</span><span class="o">(</span><span class="n">node</span><span class="o">,</span> <span class="n">neighbor</span><span class="o">)</span> <span class="o">)</span> <span class="o">{</span>
                        <span class="n">distance_btwn</span> <span class="o">=</span> <span class="n">edge</span><span class="o">.</span><span class="na">value</span><span class="o">;</span>
                    <span class="o">}</span>

                    <span class="c1">// Make a choice</span>
                    <span class="k">this</span><span class="o">.</span><span class="na">route</span><span class="o">[</span><span class="n">nchoices</span><span class="o">]</span> <span class="o">=</span> <span class="n">neighbor</span><span class="o">.</span><span class="na">id</span><span class="o">;</span>
                    <span class="n">neighbor</span><span class="o">.</span><span class="na">visit</span><span class="o">();</span>
                    <span class="k">this</span><span class="o">.</span><span class="na">this_distance</span> <span class="o">+=</span> <span class="n">distance_btwn</span><span class="o">;</span>

                    <span class="c1">// Explore the consequences</span>
                    <span class="n">explore</span><span class="o">(</span><span class="n">neighbor</span><span class="o">,</span><span class="n">nchoices</span><span class="o">+</span><span class="mi">1</span><span class="o">);</span>

                    <span class="c1">// Unmake the choice</span>
                    <span class="k">this</span><span class="o">.</span><span class="na">route</span><span class="o">[</span><span class="n">nchoices</span><span class="o">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
                    <span class="n">neighbor</span><span class="o">.</span><span class="na">unvisit</span><span class="o">();</span>
                    <span class="k">this</span><span class="o">.</span><span class="na">this_distance</span> <span class="o">-=</span> <span class="n">distance_btwn</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="c1">// Move on to the next choice (continue loop)</span>
            <span class="o">}</span>               
        <span class="o">}</span> <span class="c1">// End base/recursive case</span>
    <span class="o">}</span>
</pre></div>


<p><a name="tsp2-pessimist"></a></p>
<h3>The Pessimist Algorithm</h3>
<p>This algorithm is dubbed The Pessimist Algorithm. Let's see how it works.
Here is that new if statement:</p>
<div class="highlight"><pre><span></span><span class="k">if</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">min_distance</span><span class="o">&gt;</span><span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="k">this</span><span class="o">.</span><span class="na">this_distance</span><span class="o">&gt;</span><span class="k">this</span><span class="o">.</span><span class="na">min_distance</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// Just give up already. It&#39;s meaningless. There&#39;s no point.</span>
    <span class="k">return</span><span class="o">;</span>
<span class="o">}</span>
</pre></div>


<p>This if statement tests two conditions - first, we check if a first minimum distance has actually been found,
and second, we check if the distance of the current path is greater than the minimum distance.
If it is, we give up continuing our search down this path, and just return back to the calling function.</p>
<p>This introduces a small computational cost - 
we now have an if statement to check every time the <code>explore()</code> method is called -
but it results in such significant cost savings that it does not matter.</p>
<p><a name="tsp-timing"></a></p>
<h2>Timing Results</h2>
<p>Shown below is a graph of the walltime for various problem sizes,
showing both the original algorithm and the pessimist algorithm
and their scaling behavior. </p>
<p>The pessimist algorithm led to a <em>drastic</em> improvement in scale-up -
the results are striking.</p>
<p><img alt="TSP Guava Solution scaling results - initial and pessimist algorithms" src="/images/tsp-guava-initial-pessimist.png"></p>
<p>And here are the results in a table form:</p>
<div class="highlight"><pre><span></span>-----------------------------------------------------------------------------------------
| Number of Nodes N | Initial Algorithm Walltime [s] | Pessimist Algorithm Walltime [s] |
|-------------------|--------------------------------|----------------------------------|
| 4                 | 0.005                          | 0.006                            |
| 5                 | 0.006                          | 0.006                            |
| 6                 | 0.009                          | 0.008                            |
| 7                 | 0.017                          | 0.011                            |
| 8                 | 0.029                          | 0.020                            |
| 9                 | 0.083                          | 0.023                            |
| 10                | 0.305                          | 0.053                            |
| 11                | 1.443                          | 0.118                            |
| 12                | 15.808                         | 0.149                            |
| 13                | 180.078                        | 0.524                            |
| 14                |                                | 1.276                            |
| 15                |                                | 3.905                            |
| 16                |                                | 216.827                          |
| 17                |                                | 106.992                          |
| 18                |                                | 337.930                          |
-----------------------------------------------------------------------------------------
</pre></div>


<p>For a problem with 13 nodes, the initial algorithm took 3 minutes; 
the pessimist algorithm didn't even break the one second mark!</p>
<h2>Future Work</h2>
<p>Now that we've got the algorithm running faster and more efficiently,
we can tackle larger problems and explore the impact of problem topology
on solutions, and we can rest assured we have an efficient algorithm
that can scale to larger and more interesting problems.</p>
<p>There are further improvements we could make to the algorithm to improve it, though.
By examining the solutions that are found, we can see that the solutions
usually, but not always, connects from each neighbor to its next-closest neighbor.
If, when iterating over neighbors, we start by searching the nearest neighbors first,
we can potentially get to the minimum solution faster, which would allow us
to more quickly rule out larger portions of the solution space that are infeasible.</p>
<p>This would induce an additional overhead cost of sorting, since the Guava library
returns the edges that connect to a node as an unordered Set. These edges would 
have to be added to a container and sorted to implement the nearest-neighbor search.</p>
<p>However, we saw with the pessimist solution that a small increase in complexity
can rule out large enough portions of the solution space to make it worthwhile,
so it may be that the cost of sorting each edge pays off in the computational savings that result.</p>
<script type="text/javascript">if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width < 768) ? "left" : align;
        indent = (screen.width < 768) ? "0em" : indent;
        linebreak = (screen.width < 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' && location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
</script></div>

    </div>
</div>

<div class="v20"></div>

<div class="row">
    <div class="col-md-12" style="text-align: left;">

        <div class="tags">
            <p>Tags:&nbsp;&nbsp;&nbsp;
                    <a href="/tag/computer-science.html">computer science</a>
                    &nbsp;&nbsp;
                    <a href="/tag/guava.html">guava</a>
                    &nbsp;&nbsp;
                    <a href="/tag/graph.html">graph</a>
                    &nbsp;&nbsp;
                    <a href="/tag/tsp.html">TSP</a>
                    &nbsp;&nbsp;
                    <a href="/tag/performance.html">performance</a>
                    &nbsp;&nbsp;
        </div>

    </div>
</div>


<div class="v200"></div>

</div>


<script type="text/javascript" src="/theme/js/jquery-1.11.2.js"></script>
<script type="text/javascript" src="/theme/js/bootstrap-3.3.4.js"></script>
<script type="text/javascript" src="/theme/js/d3-3.5.5.js"></script>
<!--
<script type="text/javascript" src="/theme/js/leaflet-0.7.3.js"></script>
<script type="text/javascript" src="/theme/js/leaflet.ajax.min.js"></script>
--><script type="text/javascript" src="/theme/js/jquery-1.11.2.js"></script>
<script type="text/javascript" src="/theme/js/bootstrap-3.3.4.js"></script>

<footer id="contentinfo" class="body">
<p>&nbsp;</p>
<p>&nbsp;</p>
<center>
	<hr />
</center>
<p>&nbsp;</p>
<p style="text-align: center">
    <span class="fa-stack fa-lg">
        <i class="fa fa-square fa-stack-2x" style="color:#000;"></i>
        <i class="fa fa-terminal fa-stack-1x fa-inverse"></i>
    </span>
    Made from the command line with vim by 
    <a href="http://charlesreid1.com">charlesreid1</a><br />
    with help from <a href="https://getbootstrap.com/">Bootstrap</a> and <a href="http://getpelican.com">Pelican</a>.
</p>

<br />

<p style="text-align: center">
    <a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/">
    <span class="fa-stack fa-lg">
        <i class="fa fa-square fa-stack-2x" style="color:#000;"></i>
        <i class="fa fa-creative-commons fa-stack-1x fa-inverse"></i>
    </span>
    </a>
    <br />
    Licensed under the <a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/">Creative Commons Attribution-NonCommercial 4.0 License</a>.
</p>

</footer><!-- /#contentinfo -->
</body>
</html>