<!DOCTYPE html>
<html lang="en">
<head>
        <title>charlesreid1</title>
        <meta charset="utf-8" />

        <!--
        CSS styles
        -->
        <link href="/theme/css/bootstrap.css"       rel="stylesheet" type="text/css">
        <link href="/theme/css/slate.css"              rel="stylesheet" type="text/css">
        <link href="/theme/css/font-awesome.css"       rel="stylesheet" type="text/css"/>
        <link href="/theme/css/pygment-solarized.css"  rel="stylesheet" type="text/css"/>

        <!--
        my CSS styles
        -->
        <link href="/theme/css/main.css"            rel="stylesheet" type="text/css">
        <link href="/theme/css/dox.css"             rel="stylesheet" type="text/css">


        <!--
        include Angular first
        -->
        <script type="text/javascript" src="/theme/js/angular-1.3.15.js"></script>
        <script type="text/javascript" src="/theme/js/skrollr-0.6.29.js"></script>
        <script type="text/javascript" src="/theme/js/d3-3.5.5.js"></script>

        <!--
        this seems like a bad idea.
        but if I don't put jquery first, I get errors about unrecognized $s.
        -->
        <script type="text/javascript" src="/theme/js/jquery-1.11.2.js"></script>

</head>
<body id="index">
<nav class="navbar navbar-default">
    <div class="container-fluid">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#myNavbar">
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span> 
            </button>
            <a href="https://charlesreid1.github.io" class="navbar-brand">charlesreid1.github.io</a>
        </div>
        <div>
            <div class="collapse navbar-collapse" id="myNavbar">
                <ul class="nav navbar-nav">

                    <li>
                        <a href="https://charlesreid1.com/wiki">Wiki</a>
                    </li>
                    <li>
                        <a href="https://git.charlesreid1.com/explore">git.charlesreid1.com</a>
                    </li>
                    <li>
                        <a href="https://github.com/charlesreid1/charlesreid1-awesome/">charlesreid1 Awesome List</a>
                    </li>
                    <li>
                        <a href="https://charlesreid1.com/life">Life</a>
                    </li>
                    <li>
                        <a href="https://charlesreid1.github.io">Blog</a>
                    </li>
                    <li>
                        <a href="/contact">Contact Me</a>
                    </li>

                </ul>
            </div>
        </div>
    </div>
</nav>



<div class="container">

    <div class="row">
        <div class="col-md-12 col-centered" style="text-align: center;">
            <div class="v50"></div>
            <div class="cosmojumbo">
                <h1 class="jumbojumbo">charlesreid1.com blog<h1>
            </div>
        </div>
    </div>


    <div class="v50"></div>


    <div class="row">

        <div class="col-md-8" style="text-align: center;">

  	            	<article>
<header>
<div class="row">


    <div class="col-md-12">
        <div class="headtext" style="text-align: center;">
            <h1><b>
                Computing Square Roots: Part 1: Using Newton's Method
            </b></h1>
        
            <p class="lead">
                Posted 
                <time datetime="2017-07-14T18:00:00-07:00" pubdate>Friday 07/14/2017</time>
                in 
                <a href="/category/mathematics.html">Mathematics</a>
                </p>
            <p>
            <span style="font-size: 14px">
                <a href="/computing-square-roots-part-1-using-newtons-method.html">permalink</a>
            </span>
            </p>
        </div>

    </div>

</div>
</header>


<div class="v50"></div>


<div class="row">
    <div class="col-md-12" style="text-align: left;">

        <div class="entry-content"><h2>Table of Contents</h2>
<ul>
<li>
<p><a href="#newton-roots">Newton's Method for Finding Roots of Equations</a></p>
</li>
<li>
<p><a href="#newton-square-roots">Newton's Method for Finding Square Roots</a></p>
</li>
<li>
<p><a href="#newton-program">Newton's Method for Finding Square Roots: Program</a></p>
</li>
<li>
<p><a href="#newton-accuracy">Accuracy</a></p>
</li>
<li>
<p><a href="#newton-speed">Speed</a></p>
</li>
<li>
<p><a href="#newton-next">Next Steps</a></p>
</li>
<li>
<p><a href="#newton-refs">References</a></p>
</li>
</ul>
<p><a name="newton-roots"></a></p>
<h2>Newton's Method for Finding Roots of Equations</h2>
<p>Suppose we have a function <span class="math">\(f(x)\)</span> and we want to 
compute values of <span class="math">\(x\)</span> for which <span class="math">\(f(x)=0\)</span>. These values 
of <span class="math">\(x\)</span> are called the <strong>roots</strong> of <span class="math">\(f(x)\)</span>.</p>
<p>We can compute the roots using Newton's Method,
which utilizes the derivative of the function
to iteratively compute the roots of the function.</p>
<p>Newton's method begins with an initial guess.
It evaluates the derivative of the fnction at the 
initial guess, which gives the slope of the tangent line,
and computes the root of the tangent line as the next
approximation of the root of the function.</p>
<p>This is based on the point-slope formula,</p>
<div class="math">$$
y - y_0 = m(x - x_0) 
$$</div>
<p>Now the left side becomes </p>
<div class="math">$$
f(x) - f(x_0) = f'(x_0)(x - x_0)
$$</div>
<p>and at the root, we know <span class="math">\(f(x)=0\)</span>, so rearranging this equation
into an expression for the root <span class="math">\(x\)</span> gives: </p>
<div class="math">$$
x = x_0 - \dfrac{f(x_0)}{f'(x_0)}
$$</div>
<p>Now, this is the equation for the next approximation for the root.
To turn this into an iterative procedure, we write this as</p>
<div class="math">$$
x_{i+1} = x_{i} - \dfrac{f(x_i)}{f'(x_i)}
$$</div>
<p>Newton's Method then allows us to evaluate the 
above expression as many times as we would like
to achive the desired accuracy. </p>
<p>Two caveats with Newton's Method: </p>
<ul>
<li>The function must be relatively well-behaved; 
    Newton's Method does not converge for functions with
    large, high-order derivatives.</li>
<li>The convergence of the method depends on the accuracy 
    of the initial guess. If you can make a good guess, do it!</li>
</ul>
<p><a name="newton-square-roots"></a></p>
<h2>Newton's Method for Finding Square Roots</h2>
<p>Note that we can use the procedure and equation from above
to compute the numerical value of a given function to an arbitrary
degree of accuracy, so long as we have the derivative (and a program 
that can keep track of arbitrary digits).</p>
<p>Suppose we want to use Newton's Method to compute <span class="math">\(\sqrt{2}\)</span>.
Then we can solve for the roots of the following function:</p>
<div class="math">$$
f(x) = x^2 - a
$$</div>
<p>for <span class="math">\(a = 2\)</span>.</p>
<p>Note that the derivative of this function is computed using the power rule,
which is trivial to implement, so we can also use this method to compute
general <span class="math">\(n^{th}\)</span> roots of <span class="math">\(a\)</span>, by solving for roots of:</p>
<div class="math">$$
f(x) = x^n - a
$$</div>
<p>For a monomial with nonzero power, the derivative is always l<span class="math">\(f'(x) = n x^{n-1}\)</span>, 
so in the square root case we have <span class="math">\(f'(x) = 2x\)</span>. Now we plug these two functions
into the iterative formula for Newton's Method to get:</p>
<div class="math">$$
\begin{array}
a x_{i+1} &amp;=&amp; x_{i} - \dfrac{f(x_n)}{f'(x_n)} \\
x_{i+1} &amp;=&amp; x_{i} - \dfrac{x_i^2 - a}{2 x_i }
\end{array}
$$</div>
<p><a name="newton-program"></a></p>
<h2>Newton's Method for Finding Square Roots: Program</h2>
<p>This can be implemented in a programming language to yield an iterative
method for computing square roots. We can either specify a tolerance (better),
or a number of iterations. Here is a static method for computing
a square root using Newton's method. The user specifies the value of <span class="math">\(a\)</span>,
the number they want to compute the square root of; <span class="math">\(x_0\)</span>, the initial guess;
and a tolerance, which controls the number of decimal places of accuracy of the 
final answer.</p>
<div class="highlight"><pre><span></span>    <span class="cm">/** Compute a square root using Newton&#39;s Method, to a specified tolerance.</span>
<span class="cm">     *</span>
<span class="cm">     * @param a Compute the square root of a.</span>
<span class="cm">     * @param x0 Initial guess.</span>
<span class="cm">     * @param tol Tolerance (stopping criteria).</span>
<span class="cm">     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">double</span> <span class="nf">nmsqrttol</span><span class="o">(</span><span class="kt">double</span> <span class="n">a</span><span class="o">,</span> <span class="kt">double</span> <span class="n">x0</span><span class="o">,</span> <span class="kt">double</span> <span class="n">tol</span><span class="o">)</span> <span class="o">{</span> 
        <span class="kt">double</span> <span class="n">xi</span><span class="o">,</span> <span class="n">xip1</span><span class="o">,</span> <span class="n">err</span><span class="o">;</span>
        <span class="n">xi</span> <span class="o">=</span> <span class="n">xip1</span> <span class="o">=</span> <span class="n">x0</span><span class="o">;</span>
        <span class="n">err</span> <span class="o">=</span> <span class="n">x0</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">err</span> <span class="o">&gt;</span> <span class="n">tol</span><span class="o">)</span> <span class="o">{</span> 
            <span class="n">xip1</span> <span class="o">=</span> <span class="n">xi</span> <span class="o">-</span> <span class="o">(</span><span class="n">xi</span><span class="o">*</span><span class="n">xi</span><span class="o">-</span><span class="n">a</span><span class="o">)/(</span><span class="mi">2</span><span class="o">*</span><span class="n">xi</span><span class="o">);</span>
            <span class="n">err</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span> <span class="n">xip1</span> <span class="o">-</span> <span class="n">xi</span> <span class="o">);</span>
            <span class="n">xi</span> <span class="o">=</span> <span class="n">xip1</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">xip1</span><span class="o">;</span>
    <span class="o">}</span>
</pre></div>


<p>(There is no check for infinite loops because our function is a smooth
polynomial and Newton's Method will always converge.) </p>
<p>Here is sample output from a program that varies the tolerance and prints
the corresponding value of the square root that was computed:</p>
<div class="highlight"><pre><span></span>$ javac SquareRoot.java <span class="o">&amp;&amp;</span> java SquareRoot
Actual value sqrt<span class="o">(</span><span class="m">2</span><span class="o">)</span> <span class="o">=</span> <span class="m">1</span>.4142135623730951
Testing Newton<span class="err">&#39;</span>s Method, Specifying Tolerance:
Tol         sqrt<span class="o">(</span><span class="m">2</span><span class="o">)</span>
<span class="m">0</span>.1         <span class="m">1</span>.4166666666666667
<span class="m">0</span>.01        <span class="m">1</span>.4142156862745099
<span class="m">0</span>.001       <span class="m">1</span>.4142135623746899
<span class="m">0</span>.0001      <span class="m">1</span>.4142135623746899
1e-05       <span class="m">1</span>.4142135623746899
1e-06       <span class="m">1</span>.4142135623730951
1e-07       <span class="m">1</span>.4142135623730951
1e-08       <span class="m">1</span>.4142135623730951
</pre></div>


<p><a name="newton-accuracy"></a></p>
<h2>Accuracy</h2>
<p>Now that we've coded up Newton's Method, we can determine the number of accurate 
digits. There are a couple of ways to do this, but I went with a string comparison 
method. I start with a text file containing thousands of digits of the square root of 2,
then I compute the square root of 2 using Newton's Method. The longest common substring
gives me the number of accurate digits, plus "1.", so if I subtract 2 I get the 
total number of accurate digits after the decimal place. </p>
<div class="highlight"><pre><span></span>javac SquareRoot.java &amp;&amp; java SquareRoot
Tolerance = 0.1     Number of accurate digits = 2
Tolerance = 0.01        Number of accurate digits = 5
Tolerance = 0.001       Number of accurate digits = 11
Tolerance = 0.0001      Number of accurate digits = 11
Tolerance = 1e-05       Number of accurate digits = 11
Tolerance = 1e-06       Number of accurate digits = 15
Tolerance = 1e-07       Number of accurate digits = 15
Tolerance = 1e-08       Number of accurate digits = 15
Tolerance = 1e-09       Number of accurate digits = 15
Tolerance = 1e-10       Number of accurate digits = 15
Tolerance = 1e-11       Number of accurate digits = 15
Tolerance = 1e-12       Number of accurate digits = 15
Tolerance = 1e-13       Number of accurate digits = 15
Tolerance = 1e-14       Number of accurate digits = 15
</pre></div>


<p><a name="newton-speed"></a></p>
<h2>Speed</h2>
<p>It is also important to measure performance, in the form of speed. How fast is 
Newton's Method relative to the built-in square root function in the math library?</p>
<p>Turns out the performance of Newton's Method is much worse than the built-in math library's 
square root function. The Newton's Method defined above is around 100 times slower. 
Here are the results of a simple timing test, in which we compute the square root
10 million times, timing how long it takes, and divide by the number of operations
to yield the time per operation (or rather, as it is slightly easier to grasp, 
the time per 1k operations);:</p>
<div class="highlight"><pre><span></span>    <span class="c">/** Time Newton&#39;s Method.</span>
<span class="c">     *</span>
<span class="c">     * How long does it take to achieve 10 digits of accuracy? */</span>
    <span class="nt">public</span> <span class="nt">static</span> <span class="nt">void</span> <span class="nt">testTime</span><span class="o">()</span> <span class="p">{</span> 

        <span class="err">int</span> <span class="err">Nops</span><span class="p">;</span>
        <span class="err">double</span> <span class="err">a</span><span class="p">;</span>
        <span class="err">double</span> <span class="err">initialGuess</span><span class="p">;</span>
        <span class="err">double</span> <span class="err">tol</span><span class="p">;</span>
        <span class="err">double</span> <span class="err">time</span><span class="p">;</span>

        <span class="err">Tim</span> <span class="err">tim</span><span class="p">;</span>

        <span class="err">Nops</span> <span class="err">=</span> <span class="err">10000000</span><span class="p">;</span>
        <span class="err">a</span> <span class="err">=</span> <span class="err">2</span><span class="p">;</span>
        <span class="err">initialGuess</span> <span class="err">=</span> <span class="err">1</span><span class="p">;</span>
        <span class="err">tol</span> <span class="err">=</span> <span class="err">1E-8</span><span class="p">;</span>
        <span class="err">tim</span> <span class="err">=</span> <span class="err">new</span> <span class="err">Tim()</span><span class="p">;</span>
        <span class="err">tim.tic()</span><span class="p">;</span>
        <span class="err">for(int</span> <span class="err">i=0</span><span class="p">;</span> <span class="err">i&lt;Nops</span><span class="p">;</span> <span class="err">i++)</span> <span class="err">{</span> 
            <span class="err">nmsqrttol(a,</span> <span class="err">initialGuess,</span> <span class="err">tol)</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="nt">tim</span><span class="p">.</span><span class="nc">toc</span><span class="o">();</span>
        <span class="nt">time</span> <span class="o">=</span> <span class="nt">1000</span><span class="o">*</span><span class="nt">tim</span><span class="p">.</span><span class="nc">elapsedms</span><span class="o">()/</span><span class="nt">Nops</span><span class="o">;</span>
        <span class="nt">System</span><span class="p">.</span><span class="nc">out</span><span class="p">.</span><span class="nc">println</span><span class="o">(</span><span class="s2">&quot;Newton&#39;s Method Time (ms) per 1k operations: &quot;</span><span class="o">+</span><span class="nt">time</span><span class="o">);</span>


        <span class="nt">Nops</span> <span class="o">=</span> <span class="nt">10000000</span><span class="o">;</span>
        <span class="nt">a</span> <span class="o">=</span> <span class="nt">2</span><span class="o">;</span>
        <span class="nt">tim</span> <span class="o">=</span> <span class="nt">new</span> <span class="nt">Tim</span><span class="o">();</span>
        <span class="nt">tim</span><span class="p">.</span><span class="nc">tic</span><span class="o">();</span>
        <span class="nt">for</span><span class="o">(</span><span class="nt">int</span> <span class="nt">i</span><span class="o">=</span><span class="nt">0</span><span class="o">;</span> <span class="nt">i</span><span class="o">&lt;</span><span class="nt">Nops</span><span class="o">;</span> <span class="nt">i</span><span class="o">++)</span> <span class="p">{</span> 
            <span class="err">Math.sqrt(a)</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="nt">tim</span><span class="p">.</span><span class="nc">toc</span><span class="o">();</span>
        <span class="nt">time</span> <span class="o">=</span> <span class="nt">1000</span><span class="o">*</span><span class="nt">tim</span><span class="p">.</span><span class="nc">elapsedms</span><span class="o">()/</span><span class="nt">Nops</span><span class="o">;</span>
        <span class="nt">System</span><span class="p">.</span><span class="nc">out</span><span class="p">.</span><span class="nc">println</span><span class="o">(</span><span class="s2">&quot;Math Library Time (ms) per 1k operations: &quot;</span><span class="o">+</span><span class="nt">time</span><span class="o">);</span>

    <span class="err">}</span>
</pre></div>


<p>and the results:</p>
<div class="highlight"><pre><span></span>javac SquareRoot.java &amp;&amp; java SquareRoot
Newton&#39;s Method Time (ms) per 1k operations: 0.016
Math Library Time (ms) per 1k operations: 3.0E-4
</pre></div>


<p>While the accuracy of Newton's Method for square roots may not be that great,
it ain't bad, for 9 lines of code. </p>
<p><a name="newton-next"></a></p>
<h2>Next Steps</h2>
<p>In a blog post to follow, we'll compare the speed and accuracy of square root computations using Newton's Method
to an alternative approach involving the continued fraction representation of square roots. This particularly interesting
technique can also be used to solve the Pell equation, a quadratic Diophantine equation of the form:</p>
<div class="math">$$
x^2 - D y^2 = 1
$$</div>
<p>But more on that in a future post...</p>
<p><a name="newton-refs"></a></p>
<h2>References</h2>
<ol>
<li>
<p>Press, William et al. "Numerical Recipes in C." Cambridge Unviersity Press (2007).</p>
</li>
<li>
<p>"SquareRoot.java". Charles Reid. git.charlesreid1.com.
&lt;<a href="https://git.charlesreid1.com/cs/java/src/master/numerics/newtons-method">https://git.charlesreid1.com/cs/java/src/master/numerics/newtons-method</a>&gt;</p>
</li>
</ol>
<script type="text/javascript">if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width < 768) ? "left" : align;
        indent = (screen.width < 768) ? "0em" : indent;
        linebreak = (screen.width < 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
</script></div>

    </div>
</div>

<div class="v20"></div>

<div class="row">
    <div class="col-md-12" style="text-align: left;">

        <div class="tags">
            <p>Tags:&nbsp;&nbsp;&nbsp;
                    <a href="/tag/computer-science.html">computer science</a>
                    &nbsp;&nbsp;
                    <a href="/tag/java.html">java</a>
                    &nbsp;&nbsp;
                    <a href="/tag/mathematics.html">mathematics</a>
                    &nbsp;&nbsp;
                    <a href="/tag/square-roots.html">square roots</a>
                    &nbsp;&nbsp;
                    <a href="/tag/numerical-methods.html">numerical methods</a>
                    &nbsp;&nbsp;
                    <a href="/tag/newtons-method.html">newtons method</a>
                    &nbsp;&nbsp;
        </div>

    </div>
</div>


<div class="v200"></div>
  	            	</article>
  	            	<article>
<header>
<div class="row">


    <div class="col-md-12">
        <div class="headtext" style="text-align: center;">
            <h1><b>
                CSE 143 Final Project: Hilbert Sort: 3. The Code
            </b></h1>
        
            <p class="lead">
                Posted 
                <time datetime="2017-06-30T20:00:00-07:00" pubdate>Friday 06/30/2017</time>
                in 
                <a href="/category/computer-science.html">Computer Science</a>
                </p>
            <p>
            <span style="font-size: 14px">
                <a href="/cse-143-final-project-hilbert-sort-3-the-code.html">permalink</a>
            </span>
            </p>
        </div>

    </div>

</div>
</header>


<div class="v50"></div>


<div class="row">
    <div class="col-md-12" style="text-align: left;">

        <div class="entry-content"><h1>Table of Contents</h1>
<p>This is the third in a series of three posts 
detailing the Hilbert Sort problem,
its solution, and its implementation.
This post deals with the code to solve the
Hilbert Sort problem.</p>
<ul>
<li>
<p><a href="#hilbert3-pseudocode">Pseudocode</a></p>
</li>
<li>
<p><a href="#hilbert3-code">Code</a></p>
<ul>
<li><a href="#hilbert3-utility">Utility Classes</a></li>
<li><a href="#hilbert3-recursive">Recursive Sort Function</a></li>
<li><a href="#hilbert3-main">Main Method</a></li>
</ul>
</li>
<li>
<p><a href="#hilbert2-references">References</a></p>
</li>
</ul>
<p><a name="hilbert3-pseudocode"></a></p>
<h1>Hilbert Sort: Pseudocode</h1>
<p>From our prior post, here is the psudocode for our Hilbert Sort function:</p>
<div class="highlight"><pre><span></span>define hilbert_sort( unsorted queue, square dimension ):
    create southwest queue
    create northwest queue
    create northeast queue
    create southeast queue
    for each point:
        if in southwest:
            create new point using X -&gt; Y, Y -&gt; X
            add to southwest queue
        if in northwest:
            create new point using X -&gt; 2X, Y -&gt; 2Y - S
            add to northwest queue
        if in northeast:
            create new point using X -&gt; 2X - S, Y -&gt; 2Y - S
            add to northeast queue
        if in southeast:
            create new point using X -&gt; S - 2Y, Y -&gt; 2S - 2X
            add to southeast queue

        hilbertsort(southwest queue, square dimension)
        hilbertsort(northwest queue, square dimension)
        hilbertsort(northeast queue, square dimension)
        hilbertsort(southeast queue, square dimension)

        create new results queue
        add points from southwest into results queue
        add points from northwest into results queue
        add points from northeast into results queue
        add points from southeast into results queue
        return results queue
</pre></div>


<p>Because we are manually sorting, and we want order to be preserved,
we should be using a queue to organize points as we sort them.
That way, we add them in sorted order, and we are then able to remove
them in sorted order.</p>
<p><a name="hilbert3-code"></a></p>
<h1>Hilbert Sort: Code</h1>
<p>We begin by covering a utility class used by the Hilbert Sort method
to store <span class="math">\((X,Y)\)</span> points. This is a simple example of a composition 
design pattern. Next, we cover the bulk of the problem solution: 
the recursive sort method that partiions points into quadrants.
Finally, we cover the main method, which demonstrates reading data
from an input file and passing it to the sort method.</p>
<p><a name="hilbert3-utility"></a></p>
<h2>Hilbert Sort: Utility Classes</h2>
<p>To organize <span class="math">\((X,Y)\)</span> point data, we use a simple class
using composition. This is defined next to the HilbertSort 
class.</p>
<div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm"> * An (x,y) Point class. </span>
<span class="cm"> */</span>
<span class="kr">class</span> <span class="nx">Point</span> <span class="p">{</span>
    <span class="kr">int</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">;</span> <span class="c1">// (x,y) point.</span>
    <span class="nb">String</span> <span class="nx">name</span><span class="p">;</span> <span class="c1">// Each (x,y) point has a name in the file. Used for output.</span>
    <span class="cm">/** Constructor. */</span>
    <span class="kr">public</span> <span class="nx">Point</span><span class="p">(</span><span class="kr">int</span> <span class="nx">x</span><span class="p">,</span> <span class="kr">int</span> <span class="nx">y</span><span class="p">,</span> <span class="nb">String</span> <span class="nx">name</span><span class="p">)</span> <span class="p">{</span> 
        <span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="nx">x</span><span class="p">;</span> <span class="k">this</span><span class="p">.</span><span class="nx">y</span> <span class="o">=</span> <span class="nx">y</span><span class="p">;</span> <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="cm">/** String representation (x,y). */</span>
    <span class="kr">public</span> <span class="nb">String</span> <span class="nx">toString() {</span> 
        <span class="k">return</span> <span class="s2">&quot;(&quot;</span><span class="o">+</span><span class="k">this</span><span class="p">.</span><span class="nx">x</span><span class="o">+</span><span class="s2">&quot;,&quot;</span><span class="o">+</span><span class="k">this</span><span class="p">.</span><span class="nx">y</span><span class="o">+</span><span class="s2">&quot;,&quot;</span><span class="o">+</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="o">+</span><span class="s2">&quot;)&quot;</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p><a name="hilbert3-recursive"></a></p>
<h2>Recursive Sort Function</h2>
<p>Following is the recursive sort method, which (like merge sort)
consists of a split step, which partitions an <span class="math">\(S \times S\)</span> 
square into quadrants and distributes points in the square into their
corresponding quadrants, and a merge step, which stitches together
each quadrant in the correct order. </p>
<div class="highlight"><pre><span></span>    /** Recursive implementation of a Hilbert sort. */
    public static Queue&lt;Point&gt; hilbertSort(Queue&lt;Point&gt; inputP, int S) {
        // Recursive method:
        // Apply the Hilbert geometrical quadrant division 
        // to sort points by when they are visited by a Hilbert curve.
        //
        // Base case: 
        // There are 1 or fewer points in each quadrant.
        // Keep splitting into quadrants until we reach the base case. 
        if(inputP.size()&lt;1) {
            return new LinkedList&lt;Point&gt;();
        } else if(inputP.size()==1) {
            return inputP;
        }

        // split by quadrant
        Queue&lt;Point&gt; qSW = new LinkedList&lt;Point&gt;();
        Queue&lt;Point&gt; qNW = new LinkedList&lt;Point&gt;();
        Queue&lt;Point&gt; qNE = new LinkedList&lt;Point&gt;();
        Queue&lt;Point&gt; qSE = new LinkedList&lt;Point&gt;();

        // Sort points by dividing into quadrants
        for(Point p : inputP) { 

            // Prepare for the tricky part.
            //
            // Rotate the quadrant, and points in it,
            // so that everything is now translated to fit
            // how the template of the Hilbert curve is being drawn.
            // (SW-&gt;NW-&gt;NE-SE)

            boolean inSWquadrant = (2*p.x &lt;= S) &amp;&amp; (2*p.y &lt;= S);
            boolean inNWquadrant = (2*p.x &lt;= S) &amp;&amp; (2*p.y &gt;= S);

            boolean inNEquadrant = (2*p.x &gt;= S) &amp;&amp; (2*p.y &gt;= S);
            boolean inSEquadrant = (2*p.x &gt;= S) &amp;&amp; (2*p.y &lt;= S);

            // Each time we sort (x,y) points into quadrants,
            // we also transform each coordinate point 
            // in such a way that it rescales to an S x S square,
            // but does not modify the order of the points. 
            //
            // Note that we can keep everything as integers by
            // continuing to look at an S x S square,
            // and double the x and y values to shift them over/up.
            //
            // Two easy cases:
            if(inNWquadrant) {
                // Northwest quadrant: 
                // - shift y down by S/2
                // - keep x and y in same order
                qNW.add( new Point(2*p.x, 2*p.y-S, p.name) );

            } else if(inNEquadrant) {
                // Northeast quadrant:
                // - shift x and y down by S/2
                // - keep x and y in same order
                qNE.add( new Point(2*p.x - S, 2*p.y - S, p.name) );

            } else if(inSWquadrant) { 
                // Southwest quadrant:
                // - x and y need to swap places 
                // - that&#39;s it.
                qSW.add( new Point(2*p.y, 2*p.x, p.name) );

            } else if(inSEquadrant) { 
                // Southeast quadrant:
                // - trickiest quadrant.
                // - We want to preserve S - x, distance from right side
                // - we want to use it as the new y coordinate
                qSE.add( new Point(S - 2*p.y, 2*(S - p.x), p.name) );

            }

        }
        // Sort til you reach the base case.
        qSW = hilbertSort(qSW, S); 
        qNW = hilbertSort(qNW, S); 
        qNE = hilbertSort(qNE, S); 
        qSE = hilbertSort(qSE, S);

        Queue&lt;Point&gt; result = new LinkedList&lt;Point&gt;();
        for(Point q : qSW) result.add(q);
        for(Point q : qNW) result.add(q);
        for(Point q : qNE) result.add(q); 
        for(Point q : qSE) result.add(q);

        return result;
    }
</pre></div>


<p><a name="hilbert3-main"></a></p>
<h2>Main Method</h2>
<p>The last part of the code is the portion that loads the points and their labels 
from a file, and populates a Queue of Point objects from it.
This queue of points is then sorted and returned in order.</p>
<div class="highlight"><pre><span></span>    /** Main driver. */
    public static void main(String[] args) { 

        Scanner stdin = new Scanner(new BufferedReader(new InputStreamReader(System.in)));

        int n = stdin.nextInt();
        int S = stdin.nextInt();

        // n lines of 3 tokens each
        Queue&lt;Point&gt; inputPoints = new LinkedList&lt;Point&gt;();
        for(int i=0; i&lt;n; i++) { 
            int x0 = stdin.nextInt();
            int y0 = stdin.nextInt();
            String label = stdin.next();
            inputPoints.add(new Point(x0,y0,label));
        }
        Queue&lt;Point&gt; sortedPoints = hilbertSort(inputPoints, S);
        for(Point p : sortedPoints) { 
            System.out.println(p.name);
        }
    }
</pre></div>


<p><a name="hilbert3-refs"></a></p>
<h1>References</h1>
<ol>
<li>
<p>"ACM Pacific Region Programming Competition." Association of Computing Machinery. Accessed 19 June 2017.
&lt;<a href="http://acmicpc-pacnw.org/">http://acmicpc-pacnw.org/</a>&gt;</p>
</li>
<li>
<p>"Hilbert Sort." Git repository, git.charlesreid1.com. Charles Reid. Updated 16 June 2017.
&lt;<a href="https://git.charlesreid1.com/cs/finalproject-143/src/master/hilbert/HilbertSort.java">https://git.charlesreid1.com/cs/finalproject-143/src/master/hilbert/HilbertSort.java</a>&gt;</p>
</li>
</ol>
<script type="text/javascript">if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width < 768) ? "left" : align;
        indent = (screen.width < 768) ? "0em" : indent;
        linebreak = (screen.width < 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
</script></div>

    </div>
</div>

<div class="v20"></div>

<div class="row">
    <div class="col-md-12" style="text-align: left;">

        <div class="tags">
            <p>Tags:&nbsp;&nbsp;&nbsp;
                    <a href="/tag/programming.html">programming</a>
                    &nbsp;&nbsp;
                    <a href="/tag/computer-science.html">computer science</a>
                    &nbsp;&nbsp;
                    <a href="/tag/final-project.html">final project</a>
                    &nbsp;&nbsp;
                    <a href="/tag/competitive-programming.html">competitive programming</a>
                    &nbsp;&nbsp;
                    <a href="/tag/hilbert-sort.html">hilbert sort</a>
                    &nbsp;&nbsp;
                    <a href="/tag/java.html">java</a>
                    &nbsp;&nbsp;
        </div>

    </div>
</div>


<div class="v200"></div>
  	            	</article>
  	            	<article>
<header>
<div class="row">


    <div class="col-md-12">
        <div class="headtext" style="text-align: center;">
            <h1><b>
                CSE 143 Final Project: Hilbert Sort: 2. The Solution Algorithm
            </b></h1>
        
            <p class="lead">
                Posted 
                <time datetime="2017-06-27T11:00:00-07:00" pubdate>Tuesday 06/27/2017</time>
                in 
                <a href="/category/computer-science.html">Computer Science</a>
                </p>
            <p>
            <span style="font-size: 14px">
                <a href="/cse-143-final-project-hilbert-sort-2-the-solution-algorithm.html">permalink</a>
            </span>
            </p>
        </div>

    </div>

</div>
</header>


<div class="v50"></div>


<div class="row">
    <div class="col-md-12" style="text-align: left;">

        <div class="entry-content"><h1>Table of Contents</h1>
<p>This is the second in a series of three posts 
detailing the Hilbert Sort problem,
its solution, and its implementation.
This post solves the problem.</p>
<ul>
<li><a href="#hilbert2-problem">Hilbert Sort Problem</a></li>
<li><a href="#hilbert2-space">Space Is The Place</a></li>
<li><a href="#hilbert2-reflections">The Reflections</a><ul>
<li><a href="#hilbert2-quad">Reflected Quadrants</a></li>
<li><a href="#hilbert2-scaling">Scaling</a></li>
<li><a href="#hilbert2-reflection">Reflection</a></li>
</ul>
</li>
<li><a href="#hilbert2-reflection-solution">Solving the Reflection Problem</a></li>
<li><a href="#hilbert2-procedure">Procedure</a></li>
<li><a href="#hilbert2-references">References</a></li>
</ul>
<p><a name="hilbert2-problem"></a></p>
<h1>Hilbert Sort Problem</h1>
<p>In the prior post, we covered the Hilbert Sort problem, 
but we state it once more succinctly here before 
detailing a solution to the problem.</p>
<p>The Hilbert Sort problem asks the following: 
given a set of labeled <span class="math">\((x,y)\)</span> points,
how can we sort the points according to 
the order in which they are visited 
by a space-filling Hilbert curve?</p>
<p>Revisiting the example input and output provided, the input provides 
the number of points and size of the grid on the first line, 
followed by each point's coordinates and label.</p>
<div class="highlight"><pre><span></span><span class="n">Input</span><span class="o">:</span>
    <span class="mi">14</span> <span class="mi">25</span>
    <span class="mi">5</span> <span class="mi">5</span> <span class="n">Honolulu</span>
    <span class="mi">5</span> <span class="mi">10</span> <span class="n">PugetSound</span>
    <span class="mi">5</span> <span class="mi">20</span> <span class="n">Victoria</span>
    <span class="mi">10</span> <span class="mi">5</span> <span class="n">Berkeley</span>
    <span class="mi">10</span> <span class="mi">10</span> <span class="n">Portland</span>
    <span class="mi">10</span> <span class="mi">15</span> <span class="n">Seattle</span>
    <span class="mi">10</span> <span class="mi">20</span> <span class="n">Vancouver</span>
    <span class="mi">15</span> <span class="mi">5</span> <span class="n">LasVegas</span>
    <span class="mi">15</span> <span class="mi">10</span> <span class="n">Sacramento</span>
    <span class="mi">15</span> <span class="mi">15</span> <span class="n">Kelowna</span>
    <span class="mi">15</span> <span class="mi">20</span> <span class="n">PrinceGeorge</span>
    <span class="mi">20</span> <span class="mi">5</span> <span class="n">Phoenix</span>
    <span class="mi">20</span> <span class="mi">10</span> <span class="n">SaltLakeCity</span>
    <span class="mi">20</span> <span class="mi">20</span> <span class="n">Calgary</span>

<span class="n">Output</span><span class="o">:</span>
    <span class="n">Honolulu</span>
    <span class="n">Berkeley</span>
    <span class="n">Portland</span>
    <span class="n">PugetSound</span>
    <span class="n">Victoria</span>
    <span class="n">Vancouver</span>
    <span class="n">Seattle</span>
    <span class="n">Kelowna</span>
    <span class="n">PrinceGeorge</span>
    <span class="n">Calgary</span>
    <span class="n">SaltLakeCity</span>
    <span class="n">Sacramento</span>
    <span class="n">LasVegas</span>
    <span class="n">Phoenix</span>
</pre></div>


<p><a name="hilbert2-space"></a></p>
<h1>Space is the Place</h1>
<p>To solve the Hilbert Sort problem, we have to avoid the temptation
to think about the Hilbert curve and the way that it is constructed.
While we spent quite a bit of time talking about the Hilbert curve
and how it is constructed, the curve itself is not what we are 
interested in - we are interested in the order in which the points
are visited. </p>
<p>Also remember, the motivation of solving the Hilbert Sort problem is to 
arrange spatial <span class="math">\((x,y)\)</span> points so closer points are nearer together.</p>
<p>No matter how many iterations of the Hilbert curve we end up drawing,
we always apply the same procedure: cut the square into four quadrants, 
reflect the southwest corner about the bottom left to top right diagonal,
and reflect the southeast corner about the bottom right to top left diagonal.</p>
<p>We will always visit points in the southwest quadrant before we visit 
points in the northwest quadrant; we will always visit points in the northwest
corner before we visit points in the northeast corner; etc.</p>
<p><a name="hilbert2-reflections"></a></p>
<h1>The Reflections</h1>
<p>The trickiest part of the Hilbert Sort problem is the reflection that happens 
to the lower left and lower right quadrants.</p>
<p><a name="hilbert2-quad"></a></p>
<h2>Reflected Quadrants</h2>
<p>Start with the first step of the Hilbert sort - take a square with points contained in it. 
Split the square into four quadrants (with the intention of creating four sub-problems).
However, to conform to the Hilbert Curve construction process,
the lower left and lower right squares must be reflected.
The lower left square is reflected about the bottom left to upper right diagonal,
while the lower right square is reflected about the bottom right to upper left diagonal.</p>
<p>Convince yourself of this by studying the curve construction procedure as illustrated
by Hilbert himself in his 1890 paper (a.k.a., Hilbert Illustrates A Hilbert Curve):</p>
<p><img alt="Hilbert Illustrates Construction of Hilbert Curve" src="/images/HilbertCurve-OriginalPaper.png"></p>
<p>We are working toward a recursive method - and recursive methods call themselves repeatedly,
apply to subproblems that are trivially similar. However, to translate this into a recursive 
problem, we have to deal with the rotations within the current recursive step, 
in such a way that we don't need to know the orientation of the prior square 
to know the order in which to visit the squares - it is always southwest, northwest, notheast, southwest.</p>
<p>After we split the squares into quadrants, 
after we toss out any quadrants with no points, 
we walk through each of the four quadrants in order 
(southwest, northwest, northeast, southwest).
If there is a single point in the quadrant,
we add it to the priority queue.</p>
<p>It is here that we take care of the rotation - 
before we recursively call the Hilbert sort method
on the quadrant itself.</p>
<p><a name="hilbert2-scaling"></a></p>
<h2>Scaling</h2>
<p>We have a prescribed order for the four quadrants 
in the current recursive level, and the current recursive level
is working its way through each of those four quadrants.
But remember, our algorithm only cares about the order of points.
It does not care about the <span class="math">\((x,y)\)</span> location. 
So we can ireflect <span class="math">\((x,y)\)</span> points by changing their 
<span class="math">\((x,y)\)</span> coordinate locations. Ultimately
we are only changing the program's internal representation
of each point, not the original data on disk, 
so we can think of <span class="math">\((x,y)\)</span> as mutable for our purposes.</p>
<p>This is an important part of our solution:
scaling (and reflecting) each quadrant before 
recursively calling the Hilbert sort method 
on the points contained in it.</p>
<p>If we are considering a single quadrant 
of dimensions <span class="math">\(\frac{S}{2} \times \frac{S}{2}\)</span>,
containing points <span class="math">\((x,y)\)</span>, we may be able to 
pass in the corners of our square, plus the 
<span class="math">\((x,y)\)</span> points contained in it.
However, as our squares get smaller,
the distance between points gets smaller as well,
so this has an upper limit as to how many points 
it can sort.</p>
<p>On the other hand, we can avoid passing all that information around
and using doubles, by just rescaling everything to the given
quadrant. We want each recursive level to completely forget 
about where in the recursive stack it is, how large its square is
relative to the original, etc. All it should be doing is 
solving the same problem repeatedly - which is what recursion
is best at. If we double the sides of the square, we get 
a shape with original size <span class="math">\(S \times S\)</span>. To keep the points 
shifted correctly we double their <span class="math">\((x,y)\)</span> coordinates 
to <span class="math">\((2x, 2y)\)</span>.</p>
<p>Once this transformation is performed, we are ready to call
the Hilbert Sort function recursively - for the 
northwest and northeast quadrants only. The southwest and 
southeast quadrants still have a ways to go.</p>
<p><a name="hilbert2-reflection"></a></p>
<h2>Reflection</h2>
<p>In addition to the scale-up transformation, southwest and southeast 
qaudrant points must be reflected about their diagonals.</p>
<p>Here's an example of what the process looks like in action:</p>
<p><img alt="Hilbert Sort Poster Flowchart" src="/images/hilbert-poster.png"></p>
<p><a name="hilbert2-reflection-solution"></a></p>
<h1>Solving the Reflection Problem</h1>
<p>The above section described where in the process the reflection 
of the <span class="math">\((x,y)\)</span> points should happen. The process of applying the 
reflection differs between the southwest and southeast quadrants.</p>
<p>In the southwest quadrant, points are being reflected about the 
diagonal line <span class="math">\(y=x\)</span>, so the reflection of <span class="math">\((x,y)\)</span> points in the 
southwest quadrant can be performed by swapping the 
<span class="math">\(x\)</span> and <span class="math">\(y\)</span> values of all of the points in that quadrant.</p>
<p>In the southeast quadrant, the points are refelected about the 
diagonal <span class="math">\(y = -x\)</span>, but it is not quite <span class="math">\(y = -x\)</span>, given that there is
an offset of a half-quadrant width on the left. </p>
<p>After an <span class="math">\((x,y)\)</span> point is transformed, it has a height equal to
the distance from the point's x coordinate to the start of the qudarant.
In equations,</p>
<div class="math">$$
y = S - x
$$</div>
<p>Further, after an <span class="math">\((x,y)\)</span> point is transformed, the distance from the 
top of the bounding box to the former y coordinate 
is the new x coordinate, </p>
<div class="math">$$
x = \frac{S}{2} - y
$$</div>
<p>The relative x coordinates of each point 
(relative meaning, 0 starts at the beginning of the curent square,
rather than the whole square) are 
the x coordinates minus the half-quadrant width.</p>
<p>Once these reflections are performed, we pass the 
resulting <span class="math">\((x,y)\)</span> points on to a new Hilbert sort.
The new Hilbert sort will be operating on an <span class="math">\(S x S\)</span> 
square, as before. Importantly, the <span class="math">\((x,y)\)</span> points have been
transformed in such a way that the order in which the Hilbert
curve visits each point has not been affected.</p>
<p><a name="hilbert2-procedure"></a></p>
<h1>Hilbert Sort Procedure</h1>
<p>The implementation strategy is, obviously, recursive. What we want to do at each level is:
<em> Start with a square and points contained in the square. 
</em> Cut the square under consideration into four quadrants.
* Apply a transformation to each square so that it is re-oriented in a manner that matches our original Hilbert curve.</p>
<p>Once each of those squares goes through all of its respective recursive calls, 
it will return a sorted list of points. Then we will know what to do - 
we collect each of the sorted points from each of the four quadrants in order, 
maintain that order, and return those sorted quadrants.</p>
<p>To nail down the details, treat the square under consideration as ranging from 
<span class="math">\((0,0)\)</span> to <span class="math">\((S,S)\)</span>.</p>
<p>Each time we cut a square into quadrants, we re-orient ourselves as to where 
<span class="math">\((0,0)\)</span> is located and which quadrants will be visited in which order.
If we are in the lower left quadrant, <span class="math">\(x\)</span> is below <span class="math">\(\frac{S}{2}\)</span> and 
<span class="math">\(y\)</span> is below <span class="math">\(\frac{S}{2}\)</span>, so we rotate and reflect by swapping x and y:</p>
<div class="highlight"><pre><span></span>        X -&gt; Y
        Y -&gt; X
</pre></div>


<p>If we are in the upper left quadrant, x is below <span class="math">\(\frac{S}{2}\)</span>, y is above <span class="math">\(\frac{S}{2}\)</span>, 
so subtract <span class="math">\(\frac{S}{2}\)</span> from y and we're done.</p>
<div class="highlight"><pre><span></span>        X -&gt; X
        Y -&gt; Y-(S/2)
</pre></div>


<p>If we are in the upper right quadrant, x is above <span class="math">\(\frac{S}{2}\)</span>, y is above <span class="math">\(\frac{S}{2}\)</span>, 
so subtract <span class="math">\(\frac{S}{2}\)</span> from both</p>
<div class="highlight"><pre><span></span>        X -&gt; X - S/2
        Y -&gt; Y - S/2
</pre></div>


<p>If we are in the lower right quadrant, our x and y values are now 
relative to the quadrant bounding box. The distance to the top of the 
bounding box to the y coordinate becomes our new x coordinate, while the 
distance from the right of the bounding box S to the x coordinate becomes 
our new y coordinate:</p>
<div class="highlight"><pre><span></span>        X -&gt; S/2 - Y
        Y -&gt; S - X
</pre></div>


<p>Recursion always requires a base case and a recursive case. Our "base case" is the 
simple comparison of one or no points in each of our four quadrants. If we get to 
this base case, we know the order in which the Hilbert Curve will visit each of 
those points.</p>
<p>If we are not at the base case, if we have a large number of points to sort, 
we can bin together all the points in a given quadrant, and consider the order
in which those points go with an additional level of finer granularity. </p>
<p><a name="hilbert2-pseudocode"></a></p>
<h1>Pseudocode</h1>
<div class="highlight"><pre><span></span>set square dimension S

create unsorted queue
load points into unsorted queue

create sorted queue
sorted queue = hilbert_sort( unsorted queue, square dimension )
</pre></div>


<p>Now here is the Hilbert sort function:</p>
<div class="highlight"><pre><span></span>define hilbert_sort( unsorted queue, square dimension ):
    create southwest queue
    create northwest queue
    create northeast queue
    create southeast queue
    for each point:
        if in southwest:
            create new point using X -&gt; Y, Y -&gt; X
            add to southwest queue
        if in northwest:
            create new point using X -&gt; 2X, Y -&gt; 2Y - S
            add to northwest queue
        if in northeast:
            create new point using X -&gt; 2X - S, Y -&gt; 2Y - S
            add to northeast queue
        if in southeast:
            create new point using X -&gt; S - 2Y, Y -&gt; 2S - 2X
            add to southeast queue

        hilbertsort(southwest queue, square dimension)
        hilbertsort(northwest queue, square dimension)
        hilbertsort(northeast queue, square dimension)
        hilbertsort(southeast queue, square dimension)

        create new results queue
        add points from southwest into results queue
        add points from northwest into results queue
        add points from northeast into results queue
        add points from southeast into results queue
        return results queue
</pre></div>


<p><a name="hilbert2-refs"></a></p>
<h1>References</h1>
<ol>
<li>
<p>"ACM Pacific Region Programming Competition." Association of Computing Machinery. Accessed 19 June 2017.
&lt;<a href="http://acmicpc-pacnw.org/">http://acmicpc-pacnw.org/</a>&gt;</p>
</li>
<li>
<p>"ber die stetige Abbildung einer Linie auf ein Flchenstck." D. Hilbert. 
<strong>Mathematische Annalen</strong> 38 (1891), 459460. <a href="/files/HilbertCurve.pdf">(pdf)</a></p>
</li>
<li>
<p>"Hilbert Curve." Wikipedia: The Free Encyclopedia. Wikimedia Foundation. Edited 29 April 2017. Accessed 23 June 2017.
&lt;<a href="https://en.wikipedia.org/wiki/Hilbert_curve">https://en.wikipedia.org/wiki/Hilbert_curve</a>&gt;</p>
</li>
</ol>
<script type="text/javascript">if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width < 768) ? "left" : align;
        indent = (screen.width < 768) ? "0em" : indent;
        linebreak = (screen.width < 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
</script></div>

    </div>
</div>

<div class="v20"></div>

<div class="row">
    <div class="col-md-12" style="text-align: left;">

        <div class="tags">
            <p>Tags:&nbsp;&nbsp;&nbsp;
                    <a href="/tag/programming.html">programming</a>
                    &nbsp;&nbsp;
                    <a href="/tag/computer-science.html">computer science</a>
                    &nbsp;&nbsp;
                    <a href="/tag/final-project.html">final project</a>
                    &nbsp;&nbsp;
                    <a href="/tag/competitive-programming.html">competitive programming</a>
                    &nbsp;&nbsp;
                    <a href="/tag/hilbert-sort.html">hilbert sort</a>
                    &nbsp;&nbsp;
        </div>

    </div>
</div>


<div class="v200"></div>
  	            	</article>

<div class="row">
    <div class="col-md-4 col-centered" style="text-align: center;">

        <div class="pagination">
            <a class="prev" href="/index8.html">&larr; Older</a>
        
            <a class="next" href="/index6.html">Newer &rarr;</a>
          <br />
        </div>

    </div>
</div>

<div class="v50"></div>


        </div>

        <div class="col-md-4" style="text-align: center;">
<a name="a_archive"></a>


        <div class="well">

            <h2>October 2018</h2>

            <p class="archive">
            <a href="/first-post-of-the-fall-part-1-data-commons.html">First Post of the Fall, Part 1: Data Commons</a>
            </p>

        </div>

        <div class="v20"></div>


        <div class="well">

            <h2>May 2018</h2>

            <p class="archive">
            <a href="/current-projects.html">Current Projects</a>
            </p>

        </div>

        <div class="v20"></div>


        <div class="well">

            <h2>March 2018</h2>

            <p class="archive">
            <a href="/charlesreid1com-stack.html">Charlesreid1.com Stack</a>
            </p>

        </div>

        <div class="v20"></div>


        <div class="well">

            <h2>February 2018</h2>

            <p class="archive">
            <a href="/d3-calendar-visualizations.html">D3 Calendar Visualizations</a>
            </p>
            <p class="archive">
            <a href="/project-euler-problem-172.html">Project Euler Problem 172</a>
            </p>

        </div>

        <div class="v20"></div>


        <div class="well">

            <h2>January 2018</h2>

            <p class="archive">
            <a href="/4x4-rubiks-cube-part-4-sequence-order.html">4x4 Rubik's Cube: Part 4: Sequence Order</a>
            </p>
            <p class="archive">
            <a href="/4x4-rubiks-cube-part-3-factoring-permutations.html">4x4 Rubik's Cube: Part 3: Factoring Permutations</a>
            </p>
            <p class="archive">
            <a href="/4x4-rubiks-cube-part-2-permutations.html">4x4 Rubik's Cube: Part 2: Permutations</a>
            </p>
            <p class="archive">
            <a href="/4x4-rubiks-cube-part-1-representations.html">4x4 Rubik's Cube: Part 1: Representations</a>
            </p>
            <p class="archive">
            <a href="/lets-generate-permutations.html">Let's Generate Permutations!</a>
            </p>

        </div>

        <div class="v20"></div>


        <div class="well">

            <h2>September 2017</h2>

            <p class="archive">
            <a href="/five-letter-words-part-3-letter-coverage-and-dynamic-programming.html">Five Letter Words: Part 3: Letter Coverage and Dynamic Programming</a>
            </p>
            <p class="archive">
            <a href="/five-letter-words-part-2-more-five-word-algorithms.html">Five Letter Words: Part 2: More Five-Word Algorithms</a>
            </p>
            <p class="archive">
            <a href="/five-letter-words-part-1-getting-familiar-with-the-list.html">Five Letter Words: Part 1: Getting Familiar With The List</a>
            </p>

        </div>

        <div class="v20"></div>


        <div class="well">

            <h2>August 2017</h2>

            <p class="archive">
            <a href="/eulers-theorem-the-totient-function-and-calculating-totients-by-hand.html">Euler's Theorem, the Totient Function, and Calculating Totients By Hand</a>
            </p>

        </div>

        <div class="v20"></div>


        <div class="well">

            <h2>July 2017</h2>

            <p class="archive">
            <a href="/mad-combinatoric-castles.html">Mad Combinatoric Castles</a>
            </p>
            <p class="archive">
            <a href="/project-euler-problem-1.html">Project Euler Problem 1</a>
            </p>
            <p class="archive">
            <a href="/shortest-lattice-paths-and-multiset-permutations.html">Shortest Lattice Paths and Multiset Permutations</a>
            </p>
            <p class="archive">
            <a href="/computing-square-roots-part-2-using-continued-fractions.html">Computing Square Roots: Part 2: Using Continued Fractions</a>
            </p>
            <p class="archive">
            <a href="/computing-square-roots-part-1-using-newtons-method.html">Computing Square Roots: Part 1: Using Newton's Method</a>
            </p>

        </div>

        <div class="v20"></div>


        <div class="well">

            <h2>June 2017</h2>

            <p class="archive">
            <a href="/cse-143-final-project-hilbert-sort-3-the-code.html">CSE 143 Final Project: Hilbert Sort: 3. The Code</a>
            </p>
            <p class="archive">
            <a href="/cse-143-final-project-hilbert-sort-2-the-solution-algorithm.html">CSE 143 Final Project: Hilbert Sort: 2. The Solution Algorithm</a>
            </p>
            <p class="archive">
            <a href="/cse-143-final-project-hilbert-sort-1-the-problem.html">CSE 143 Final Project: Hilbert Sort: 1. The Problem</a>
            </p>
            <p class="archive">
            <a href="/cse-143-final-project-classy.html">CSE 143 Final Project: Classy</a>
            </p>
            <p class="archive">
            <a href="/cse-143-final-project-checkers.html">CSE 143 Final Project: Checkers</a>
            </p>

        </div>

        <div class="v20"></div>


        <div class="well">

            <h2>May 2017</h2>

            <p class="archive">
            <a href="/teaching-recursion-with-the-n-queens-problem.html">Teaching Recursion with the N Queens Problem</a>
            </p>
            <p class="archive">
            <a href="/undergraduate-research-project-wireless-sensor-networks-for-internet-of-things-applications-part-2-the-technologies.html">Undergraduate Research Project: Wireless Sensor Networks for Internet of Things Applications (Part 2: The Technologies)</a>
            </p>
            <p class="archive">
            <a href="/undergraduate-research-project-wireless-sensor-networks-for-internet-of-things-applications-part-1-the-project.html">Undergraduate Research Project: Wireless Sensor Networks for Internet of Things Applications (Part 1: The Project)</a>
            </p>

        </div>

        <div class="v20"></div>


        <div class="well">

            <h2>April 2017</h2>

            <p class="archive">
            <a href="/stunnel.html">Stunnel</a>
            </p>
            <p class="archive">
            <a href="/traveling-schoolteacher-problem.html">Traveling Schoolteacher Problem</a>
            </p>
            <p class="archive">
            <a href="/the-z-machine-a-simple-turing-machine.html">The Z-Machine: A Simple Turing Machine</a>
            </p>
            <p class="archive">
            <a href="/awsome-day-seattle-notes-part-2-networking-security-and-miscellany.html">AWSome Day Seattle Notes: Part 2: Networking, Security, and Miscellany</a>
            </p>
            <p class="archive">
            <a href="/awsome-day-seattle-notes-part-1-the-basics.html">AWSome Day Seattle Notes: Part 1: The Basics</a>
            </p>
            <p class="archive">
            <a href="/setting-up-a-self-hosted-github-clone-with-gitea.html">Setting Up a Self-Hosted Github Clone with Gitea</a>
            </p>
            <p class="archive">
            <a href="/better-timing-of-guava-traveling-salesperson-problem-code-timing-scripts.html">Better Timing of Guava Traveling Salesperson Problem Code: Timing Scripts</a>
            </p>

        </div>

        <div class="v20"></div>


        <div class="well">

            <h2>March 2017</h2>

            <p class="archive">
            <a href="/fixing-bottlenecks-in-the-guava-traveling-salesperson-problem-code.html">Fixing Bottlenecks in the Guava Traveling Salesperson Problem Code</a>
            </p>
            <p class="archive">
            <a href="/python-vs-perl-n-queens-problem.html">Python vs. Perl: N Queens Problem</a>
            </p>
            <p class="archive">
            <a href="/solving-the-traveling-salesperson-problem-with-java-and-guava.html">Solving the Traveling Salesperson Problem with Java and Guava</a>
            </p>
            <p class="archive">
            <a href="/perl-vs-java-n-queens-problem.html">Perl vs. Java: N Queens Problem</a>
            </p>
            <p class="archive">
            <a href="/enigma-cipher-implementation-part-4-combinatorics.html">Enigma Cipher Implementation: Part 4: Combinatorics</a>
            </p>
            <p class="archive">
            <a href="/enigma-cipher-implementation-part-3-enigma-in-java-without-objects.html">Enigma Cipher Implementation: Part 3: Enigma in Java Without Objects</a>
            </p>
            <p class="archive">
            <a href="/enigma-cipher-implementation-part-2-pseudocode.html">Enigma Cipher Implementation: Part 2: Pseudocode</a>
            </p>
            <p class="archive">
            <a href="/enigma-cipher-implementation-part-1-how-it-works.html">Enigma Cipher Implementation: Part 1: How It Works</a>
            </p>

        </div>

        <div class="v20"></div>



<div class="v100"></div>
        </div>

    </div>



</div>



<script type="text/javascript" src="/theme/js/jquery-1.11.2.js"></script>
<script type="text/javascript" src="/theme/js/bootstrap-3.3.4.js"></script>
<script type="text/javascript" src="/theme/js/d3-3.5.5.js"></script>
<!--
<script type="text/javascript" src="/theme/js/leaflet-0.7.3.js"></script>
<script type="text/javascript" src="/theme/js/leaflet.ajax.min.js"></script>
--><script type="text/javascript" src="/theme/js/jquery-1.11.2.js"></script>
<script type="text/javascript" src="/theme/js/bootstrap-3.3.4.js"></script>

<footer id="contentinfo" class="body">
<p>&nbsp;</p>
<p>&nbsp;</p>
<center>
	<hr />
</center>
<p>&nbsp;</p>
<p style="text-align: center">
    <span class="fa-stack fa-lg">
        <i class="fa fa-square fa-stack-2x" style="color:#000;"></i>
        <i class="fa fa-terminal fa-stack-1x fa-inverse"></i>
    </span>
    Made from the command line with vim by 
    <a href="http://charlesreid1.com">charlesreid1</a><br />
    with help from <a href="https://getbootstrap.com/">Bootstrap</a> and <a href="http://getpelican.com">Pelican</a>.
</p>

<br />

<p style="text-align: center">
    <a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/">
    <span class="fa-stack fa-lg">
        <i class="fa fa-square fa-stack-2x" style="color:#000;"></i>
        <i class="fa fa-creative-commons fa-stack-1x fa-inverse"></i>
    </span>
    </a>
    <br />
    Licensed under the <a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/">Creative Commons Attribution-NonCommercial 4.0 License</a>.
</p>

<!-- Start of StatCounter Code for Default Guide -->
<script type="text/javascript">
var sc_project=11611748;
var sc_invisible=1;
var sc_security="9fcba820";
</script>
<script type="text/javascript"
src="https://www.statcounter.com/counter/counter.js"
async></script>

<noscript><div class="statcounter"><a title="Web Analytics"
href="http://statcounter.com/" target="_blank"><img
class="statcounter"
src="//c.statcounter.com/11611748/0/9fcba820/1/" alt="Web
Analytics"></a></div></noscript>
<!-- End of StatCounter Code for Default Guide -->
</footer><!-- /#contentinfo -->
</body>
</html>