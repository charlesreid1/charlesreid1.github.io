<!DOCTYPE html>
<html lang="en">
<head>
        <title>charlesreid1</title>
        <meta charset="utf-8" />

        <!--
        CSS styles
        -->
        <link href="https://charlesreid1.github.io/theme/css/bootstrap.css"       rel="stylesheet" type="text/css">
        <link href="https://charlesreid1.github.io/theme/css/slate.css"              rel="stylesheet" type="text/css">
        <link href="https://charlesreid1.github.io/theme/css/font-awesome.css"       rel="stylesheet" type="text/css"/>
        <link href="https://charlesreid1.github.io/theme/css/pygment-solarized.css"  rel="stylesheet" type="text/css"/>

        <!--
        my CSS styles
        -->
        <link href="https://charlesreid1.github.io/theme/css/main.css"            rel="stylesheet" type="text/css">
        <link href="https://charlesreid1.github.io/theme/css/dox.css"             rel="stylesheet" type="text/css">


        <!--
        include Angular first
        -->
        <script type="text/javascript" src="https://charlesreid1.github.io/theme/js/angular-1.3.15.js"></script>
        <script type="text/javascript" src="https://charlesreid1.github.io/theme/js/skrollr-0.6.29.js"></script>
        <script type="text/javascript" src="https://charlesreid1.github.io/theme/js/d3-3.5.5.js"></script>

        <!--
        this seems like a bad idea.
        but if I don't put jquery first, I get errors about unrecognized $s.
        -->
        <script type="text/javascript" src="https://charlesreid1.github.io/theme/js/jquery-1.11.2.js"></script>

</head>
<body id="index">
<nav class="navbar navbar-default">
    <div class="container-fluid">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#myNavbar">
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span> 
            </button>
            <a href="https://charlesreid1.github.io" class="navbar-brand">charlesreid1.github.io</a>
        </div>
        <div>
            <div class="collapse navbar-collapse" id="myNavbar">
                <ul class="nav navbar-nav">

                    <li>
                        <a href="https://charlesreid1.com/wiki">Wiki</a>
                    </li>
                    <li>
                        <a href="https://git.charlesreid1.com/explore">Git</a>
                    </li>
                    <li>
                        <a href="http://spotify.charlesreid1.com">Music</a>
                    </li>
                    <li>
                        <a href="https://charlesreid1.com/life">Life</a>
                    </li>
                    <li>
                        <a href="https://charlesreid1.github.io">Blog</a>
                    </li>
                    <li>
                        <a href="https://charlesreid1.com/about">About Me</a>
                    </li>

                </ul>
            </div>
        </div>
    </div>
</nav>



<div class="container">

    <div class="row">
        <div class="col-md-12 col-centered" style="text-align: center;">
            <div class="v50"></div>
            <div class="cosmojumbo">
                <h1 class="jumbojumbo">charlesreid1.com blog<h1>
            </div>
        </div>
    </div>


    <div class="v50"></div>


    <div class="row">

        <div class="col-md-8" style="text-align: center;">

  	            	<article>
<header>
<div class="row">


    <div class="col-md-12">
        <div class="headtext" style="text-align: center;">
            <h1><b>
                4x4 Rubik's Cube: Part 1: Representations
            </b></h1>
        
            <p class="lead">
                Posted 
                <time datetime="2018-01-11T15:00:00-08:00" pubdate>Thursday 01/11/2018</time>
                in 
                <a href="https://charlesreid1.github.io/category/rubiks-cube.html">Rubiks Cube</a>
                </p>
            <p>
            <span style="font-size: 14px">
                <a href="https://charlesreid1.github.io/4x4-rubiks-cube-part-1-representations.html">permalink</a>
            </span>
            </p>
        </div>

    </div>

</div>
</header>


<div class="v50"></div>


<div class="row">
    <div class="col-md-12" style="text-align: left;">

        <div class="entry-content"><p><em>This is Part 1 of a 4-part blog post 
on the mathematics of the 4x4 Rubik's Cube, 
its relation to algorithms, and some 
curious properties of Rubik's Cubes.</em></p>
<p>You are currently reading Part 1 of this blog post: <strong>Part 1: Representations</strong></p>
<p>See Part 2 of this blog post here: <a href="https://charlesreid1.github.io/4x4-rubiks-cube-part-2-permutations.html">Part 2: Permutations</a></p>
<p>See Part 3 of this blog post here: <a href="https://charlesreid1.github.io/4x4-rubiks-cube-part-3-factoring-permutations.html">Part 3: Factoring Permutations</a></p>
<p>See Part 4 of this blog post here: <a href="#">Part 4: Sequence Order</a></p>
<h1>Table of Contents</h1>
<ul>
<li>
<p><a href="#rubiks1-intro">Introduction: Why the Rubik's Cube</a></p>
<ul>
<li><a href="#rubiks1-intro-why">Why the 4x4 Rubik's Cube</a></li>
</ul>
</li>
<li>
<p><a href="#rubiks1-how">How the Rubik's Cube Works</a></p>
<ul>
<li><a href="#rubiks1-how-pieces">The Pieces</a></li>
<li><a href="#rubiks1-how-face">Face Notation</a></li>
<li><a href="#rubiks1-how-color">Color Notation</a></li>
<li><a href="#rubiks1-how-move">Move Notation</a><ul>
<li><a href="#rubiks1-how-move-regular">Regular Face Rotations</a></li>
<li><a href="#rubiks1-how-move-reverse">Reverse Face Rotations</a></li>
<li><a href="#rubiks1-how-move-double">Double Face Rotations</a></li>
<li><a href="#rubiks1-how-move-second">Second Layer Face Rotations</a></li>
</ul>
</li>
</ul>
</li>
<li>
<p><a href="#rubiks1-computer">Computer Representation of a Rubik's Cube</a></p>
<ul>
<li><a href="#rubiks1-computer-operations">Operations and Functionality</a></li>
<li><a href="#rubiks1-computer-face">Face Numbering</a></li>
</ul>
</li>
<li>
<p><a href="#rubiks1-tuple">Tuple</a></p>
<ul>
<li><a href="#rubiks1-tuple-requirements">Tuple Representation Requirements</a></li>
<li><a href="#rubiks1-tuple-representation">Tuple Representation</a></li>
</ul>
</li>
<li>
<p><a href="#rubiks1-preview">Preview of Part 2</a></p>
</li>
<li>
<p><a href="#rubiks1-references">References</a></p>
</li>
</ul>
<p><br />
<br />
<br /></p>
<p><a name="rubiks1-intro"></a></p>
<h1>Introduction: Why The Rubik's Cube</h1>
<p>In this series of four posts, we'll take a look at the 
4x4 Rubik's Cube. The Rubik's Cube is an interesting
puzzle that has some profound mathematical connections
to group theory and combinatorics.</p>
<p>Group theory is a branch of mathematics that applies to 
any system that exhibits symmetry; combinatorics is the 
mathematics of counting things.</p>
<p>The Rubik's Cube gives us the opportunity to apply
concepts in group theory and combinatorics to 
better understand how the cube works, and to learn
how to apply these principles to real world systems.</p>
<p>Finally, we will wrap up by discussing some of the 
algorithms that are required to deal with a 
Rubik's Cube computationally.</p>
<p>In the next two posts, we'll talk more about the
mathematical representation of permutations of 
the Rubik's Cube, and how to use this representation 
to understand some of the properties of move 
sequences when applied to the cube.</p>
<p><a name="rubiks1-intro-why"></a></p>
<h2>Why The 4x4 Rubik's Cube</h2>
<p>The 4x4 Rubik's cube, also known as the Rubik's Revenge cube, 
is larger than the standard 3x3 Rubik's Cube - 96 faces, instead of 
the ususal 36. The 4x4 cube exhibits some particularly interesting 
properties as a result of having an even number of squares on each edge. </p>
<p><a name="rubiks1-how"></a></p>
<h1>How the Rubik's Cube Works</h1>
<p>Let's start with a discussion of cube mechanics, since this 
is important to coming up with an accurate mathematical model
of the cube.</p>
<p><a name="rubiks1-how-pieces"></a></p>
<h2>The Pieces</h2>
<p>The 4x4 Rubik's Cube consists of six faces of sixteen squares 
each, for a total of 96 face squares. These face squares are 
not completely interchangeable, however - the 4x4 cube is actually
composed of three types of pieces, called "cubies".</p>
<p><img src="images/cube1.jpg" width="300"/>
<strong>Figure 1: Corner pieces are green.</strong></p>
<p>The first type of piece is a <strong>corner piece</strong>, which contains 
3 faces. Note that it is impossible for the corner pieces
to change their chirality (direction of rotation).
There are 8 corner pieces, each of which can be oriented
in 3 different ways. </p>
<p><img src="images/cube2.jpg" width="300"/>
<strong>Figure 2: Double edge pieces are blue.</strong></p>
<p>The second type of piece is a <strong>double edge (dedge) piece</strong>.
Each edge is composed of two double edges. There are 
24 total double edge pieces, which can be further classified
into 12 left-handed and 12 right-handed dedge pieces.</p>
<p><img src="images/cube3.jpg" width="300"/>
<strong>Figure 3: Center pieces are blue.</strong></p>
<p>Lastly, there are 4 <strong>center pieces</strong> in the center of each
face, for a total of 24 center pieces. Note that each of the 
center pieces of a given color are interchangeable, unlike 
the double edge pieces or corners.</p>
<p><a name="rubiks1-how-face"></a></p>
<h2>Face Notation</h2>
<p>To refer to particular faces on the cube, we use six
letters to indicate different faces:</p>
<p><code>U</code> - upper face (the top of the cube)</p>
<p><code>D</code> - downward face (the bottom of the cube0</p>
<p><code>F</code> - front face (the front of the cube)</p>
<p><code>B</code> - back face (the back side of the cube)</p>
<p><code>L</code> - left face of the cube (on the left side when facing the front F face)</p>
<p><code>R</code> - right face of the cube</p>
<p>This will help refer to how we will rotate the cube.</p>
<p><a name="rubiks1-how-color"></a></p>
<h2>Color Notation</h2>
<p>In the solved state, each cube face has one of six colors.
The orientation of these colors relative to one another
is always fixed; the red and orange colored faces, for example,
are never adjacent. This is due to the nature of the mechanical
pieces that compose the Rubik's Cube.</p>
<p>The standard faces for each color on a solved cube are:</p>
<ul>
<li><code>U</code> = White</li>
<li><code>D</code> = Yellow</li>
<li><code>F</code> = Green</li>
<li><code>B</code> = Blue (Back-Blue)</li>
<li><code>L</code> = Orange</li>
<li><code>R</code> = Red (Red-Right)</li>
</ul>
<p>Note that on a 3x3 cube, we can always determine the
final color a face will have, because the six center pieces
on each side of a 3x3 cube always remain fixed.</p>
<p>On a 4x4 cube, however, all four center squares can rotate 
and move, meaning all 24 center squares are totally 
interchangeable, and there is no link between the 
center colors on a 4x4 cube and the final color
that will be on that face when the cube is solved.</p>
<p><a name="rubiks1-how-move"></a></p>
<h2>Move Notation</h2>
<p>Using the face notation explained above, we can denote 
multiple types of moves on the 4x4 Rubik's Cube.</p>
<p>We have 36 total moves that we can make on the 4x4 Rubik's Cube,
which can be grouped by the dozen:</p>
<div class="highlight"><pre><span></span>L l r R
U u d D
B b f F

L&#39; l&#39; r&#39; R&#39;
U&#39; u&#39; d&#39; D&#39;
B&#39; b&#39; f&#39; F&#39;

2L 2L&#39; 2R 2R&#39;
2U 2U&#39; 2D 2D&#39;
2B 2B&#39; 2F 2F&#39;
</pre></div>


<p>Let's go through the details of the notation.</p>
<p><a name="rubiks1-how-move-regular"></a></p>
<h3>Regular Face Rotations</h3>
<p>The regular face turns are denoted with capital letters:
<code>L R U D B F</code> refer to a single clockwise rotation of the 
respective face. Here, "clockwise" means <em>the direction
that is clockwise when facing the given face head-on.</em></p>
<p><a name="rubiks1-how-move-reverse"></a></p>
<h3>Reverse Face Rotations</h3>
<p>The <code>'</code> apostrophe following moves, as in <code>L' R' U' D' B' F'</code>,
indicates that the move shoud be a <em>counter-clockwise</em> 
rotation of the given face, instead of clockwise.</p>
<p><a name="rubiks1-how-move-double"></a></p>
<h3>Double Face Rotations</h3>
<p>Rotations that are indicated using a lowercase letter
refer to two-layer rotations: <code>l r u d b f</code>.</p>
<p><img src="images/cube4.jpg" width="300"/>
<strong>Figure 4: Cube state after move <code>u</code>.</strong></p>
<p>That is, the lowercase <code>u</code> refers to the <em>clockwise</em> 
rotation of the top two layers of the cube; 
the lowercase <code>r</code> refers to the <em>clockwise</em> 
rotation of the rightmost two
layers of the cube; and so on.</p>
<p>The apostrophe also serves to indicate a 
<em>counter-clockwise</em> rotation: <code>'l r' u' d' b' f'</code>
indicate counter clockwise rotations of the two
left, two right, two upper, two bottom, two back,
and two front layers, respectively.</p>
<p>We have covered the first 24 moves - 
clockwise and counter-clockwise rotations
of single and double layers.</p>
<p><a name="rubiks1-how-move-second"></a></p>
<h3>Second Layer Face Rotations</h3>
<p><img src="images/cube5.jpg" width="300"/>
<strong>Figure 5: Cube state after move <code>2U</code>.</strong></p>
<p>The <code>2</code> notation indicates a rotation of the second layer only. 
For example, <code>2U</code> refers to the clockwise rotation of the second 
layer from the top. This is equivalent to the move sequence 
<code>u U'</code>.</p>
<p>Likewise, the apostrophe indicates a counterclockwise rotation.</p>
<p><a name="rubiks1-computer"></a></p>
<h1>Computer Representation of a Rubik's Cube</h1>
<p>The computer representation we are using is the 
<a href="https://github.com/dwalton76/rubiks-cube-NxNxN-solver">rubiks-cube-NxNxN-solver</a>
library by Github user <a href="https://github.com/dwalton76/">@dwalton</a>.</p>
<p>We have modified this library to provide additional
functionality needed in the project; the fork used 
in this project is available at git.charlesreid1.com:
<a href="https://git.charlesreid1.com/charlesreid1/rubiks-cube-nnn-solver">rubiks-cube-nnn-solver</a></p>
<p>Using this library, here's how we create a 4x4
Rubik's Revenge cube:</p>
<div class="highlight"><pre><span></span><span class="n">In</span> <span class="p">[</span><span class="mi">1</span><span class="p">]:</span> <span class="kn">from</span> <span class="nn">rubikscubennnsolver.RubiksCube444</span> <span class="kn">import</span> <span class="n">RubiksCube444</span><span class="p">,</span> <span class="n">solved_4x4x4</span>

<span class="n">In</span> <span class="p">[</span><span class="mi">2</span><span class="p">]:</span> <span class="n">order</span> <span class="o">=</span> <span class="s1">&#39;URFDLB&#39;</span>

<span class="n">In</span> <span class="p">[</span><span class="mi">3</span><span class="p">]:</span> <span class="n">cube</span> <span class="o">=</span> <span class="n">RubiksCube444</span><span class="p">(</span><span class="n">solved_4x4x4</span><span class="p">,</span> <span class="n">order</span><span class="p">)</span>

<span class="n">In</span> <span class="p">[</span><span class="mi">4</span><span class="p">]:</span> <span class="n">cube</span><span class="o">.</span><span class="n">print_cube</span><span class="p">()</span>
         <span class="n">U</span> <span class="n">U</span> <span class="n">U</span> <span class="n">U</span>
         <span class="n">U</span> <span class="n">U</span> <span class="n">U</span> <span class="n">U</span>
         <span class="n">U</span> <span class="n">U</span> <span class="n">U</span> <span class="n">U</span>
         <span class="n">U</span> <span class="n">U</span> <span class="n">U</span> <span class="n">U</span>

<span class="n">L</span> <span class="n">L</span> <span class="n">L</span> <span class="n">L</span>  <span class="n">F</span> <span class="n">F</span> <span class="n">F</span> <span class="n">F</span>  <span class="n">R</span> <span class="n">R</span> <span class="n">R</span> <span class="n">R</span>  <span class="n">B</span> <span class="n">B</span> <span class="n">B</span> <span class="n">B</span>
<span class="n">L</span> <span class="n">L</span> <span class="n">L</span> <span class="n">L</span>  <span class="n">F</span> <span class="n">F</span> <span class="n">F</span> <span class="n">F</span>  <span class="n">R</span> <span class="n">R</span> <span class="n">R</span> <span class="n">R</span>  <span class="n">B</span> <span class="n">B</span> <span class="n">B</span> <span class="n">B</span>
<span class="n">L</span> <span class="n">L</span> <span class="n">L</span> <span class="n">L</span>  <span class="n">F</span> <span class="n">F</span> <span class="n">F</span> <span class="n">F</span>  <span class="n">R</span> <span class="n">R</span> <span class="n">R</span> <span class="n">R</span>  <span class="n">B</span> <span class="n">B</span> <span class="n">B</span> <span class="n">B</span>
<span class="n">L</span> <span class="n">L</span> <span class="n">L</span> <span class="n">L</span>  <span class="n">F</span> <span class="n">F</span> <span class="n">F</span> <span class="n">F</span>  <span class="n">R</span> <span class="n">R</span> <span class="n">R</span> <span class="n">R</span>  <span class="n">B</span> <span class="n">B</span> <span class="n">B</span> <span class="n">B</span>

         <span class="n">D</span> <span class="n">D</span> <span class="n">D</span> <span class="n">D</span>
         <span class="n">D</span> <span class="n">D</span> <span class="n">D</span> <span class="n">D</span>
         <span class="n">D</span> <span class="n">D</span> <span class="n">D</span> <span class="n">D</span>
         <span class="n">D</span> <span class="n">D</span> <span class="n">D</span> <span class="n">D</span>
</pre></div>


<p><a name="rubiks1-computer-operations"></a></p>
<h2>Operations and Functionality</h2>
<p>Some important functionality:</p>
<ul>
<li>Obtaining each side</li>
<li>Applying rotation</li>
<li>Applying sequence of rotations</li>
<li>Each side</li>
<li>Side face numberings, centers, edges</li>
</ul>
<p>To obtain each side, use the <code>sides</code> attribute:</p>
<div class="highlight"><pre><span></span>In [8]: print(cube.sides)
OrderedDict([(&#39;U&#39;, &lt;rubikscubennnsolver.RubiksSide.Side object at 0x11172d358&gt;), 
             (&#39;L&#39;, &lt;rubikscubennnsolver.RubiksSide.Side object at 0x11172d240&gt;), 
             (&#39;F&#39;, &lt;rubikscubennnsolver.RubiksSide.Side object at 0x11172d5c0&gt;), 
             (&#39;R&#39;, &lt;rubikscubennnsolver.RubiksSide.Side object at 0x11172d5f8&gt;), 
             (&#39;B&#39;, &lt;rubikscubennnsolver.RubiksSide.Side object at 0x11172d518&gt;), 
             (&#39;D&#39;, &lt;rubikscubennnsolver.RubiksSide.Side object at 0x11172d390&gt;)])
</pre></div>


<p>Each Side object has a long list of methods, including methods
to obtain the index numbers of corner, edge, or center faces 
on a particular side.</p>
<p>To apply a rotation of a single face, 
use the <code>rotate()</code> method and pass the 
name of the face:</p>
<div class="highlight"><pre><span></span>In [10]: cube.rotate(&quot;U&quot;)

In [11]: cube.print_cube()
         U U U U
         U U U U
         U U U U
         U U U U

F F F F  R R R R  B B B B  L L L L
L L L L  F F F F  R R R R  B B B B
L L L L  F F F F  R R R R  B B B B
L L L L  F F F F  R R R R  B B B B

         D D D D
         D D D D
         D D D D
         D D D D
</pre></div>


<p>Unfortunately, the rotate method does not 
take sequences of moves, but this is easily
resolved:</p>
<div class="highlight"><pre><span></span>In [12]: cube = RubiksCube444(solved_4x4x4, order)

In [13]: sequence = &quot;U L U&#39; L&#39;&quot;

In [14]: for move in sequence.split():
    ...:     cube.rotate(move)
    ...:

In [15]: cube.print_cube()
         L U U U
         U U U U
         U U U U
         U B B L

D F F F  R L L F  U R R R  B B B B
L L L L  F F F F  R R R R  B B B U
L L L L  F F F F  R R R R  B B B U
L L L L  F F F F  R R R R  B B B U

         D D D D
         D D D D
         D D D D
         B D D D
</pre></div>


<p><a name="rubiks1-computer-face"></a></p>
<h2>Face Numbering</h2>
<p>Here is the numerical representation of the faces,
which we will make extensive use of:</p>
<div class="highlight"><pre><span></span>In [6]: cube.print_cube_layout()
             01 02 03 04
             05 06 07 08
             09 10 11 12
             13 14 15 16

17 18 19 20  33 34 35 36  49 50 51 52  65 66 67 68
21 22 23 24  37 38 39 40  53 54 55 56  69 70 71 72
25 26 27 28  41 42 43 44  57 58 59 60  73 74 75 76
29 30 31 32  45 46 47 48  61 62 63 64  77 78 79 80

             81 82 83 84
             85 86 87 88
             89 90 91 92
             93 94 95 96
</pre></div>


<p><a name="rubiks1-tuple"></a></p>
<h1>Tuple Representation</h1>
<p>We have a goal of finding a way of representing the 
state of the 4x4 Rubik's Revenge using a tuple, 
which is a mathematical object that will enable us
to investigate properties of sequences, moves, and 
rotations.</p>
<p>It is important to note that the mechanics of the
cube restrict some of the 96 total faces to only 
occur in particular configurations. By using a 
tuple of 96 integers, we are overspecifying the 
state of the cube, and we would be able to do much 
better if our goal were a minimal representation 
of the Rubik's Cube state.</p>
<p>However, our goal is <em>not</em> a minimal representation
of the cube, but a <em>unique</em> representation of the cube.
As we will see in a later post, the schema we use
does not actually matter, so long as we can 
represent each unique state of the cube using a sequence
of integers of arbitrary length.</p>
<p><a name="rubiks1-tuple-requirements"></a></p>
<h2>Tuple Representation Requirements</h2>
<p>The 4x4 cube, in the solved state, has a few characteristics that can be used
to indicate a particular permutation or configuration:</p>
<ul>
<li>Face indciators <code>UDFBLR</code></li>
<li>Colors <code>WYGBRO</code></li>
<li>Integers 1-96 to number each face</li>
</ul>
<p>Here is how the faces representation looks:</p>
<div class="highlight"><pre><span></span>In [17]: cube.print_cube()
         U U U U
         U U U U
         U U U U
         U U U U

L L L L  F F F F  R R R R  B B B B
L L L L  F F F F  R R R R  B B B B
L L L L  F F F F  R R R R  B B B B
L L L L  F F F F  R R R R  B B B B

         D D D D
         D D D D
         D D D D
         D D D D
</pre></div>


<p>The equivalent color representation is:</p>
<div class="highlight"><pre><span></span>         W W W W
         W W W W
         W W W W
         W W W W

O O O O  G G G G  R R R R  B B B B
O O O O  G G G G  R R R R  B B B B
O O O O  G G G G  R R R R  B B B B
O O O O  G G G G  R R R R  B B B B

         Y Y Y Y
         Y Y Y Y
         Y Y Y Y
         Y Y Y Y
</pre></div>


<p>However, the tuple representation <em>cannot</em> use 
colors to represent the state of the cube.
This is because a tuple representation using 
"R" to represent each red face would give us no
way of distinguishing between the (non-interchangeable)
red faces on the cube. For example, if the 
red-green double edge piece were replaced 
with a red-blue double edge piece, oriented
with the red face at the same location,
the n-tuple needs to reflect that this face
has a different value than it did the prior move.</p>
<p>For this reason, we must use an integer to index 
each distinct face:</p>
<div class="highlight"><pre><span></span>             01 02 03 04
             05 06 07 08
             09 10 11 12
             13 14 15 16

17 18 19 20  33 34 35 36  49 50 51 52  65 66 67 68
21 22 23 24  37 38 39 40  53 54 55 56  69 70 71 72
25 26 27 28  41 42 43 44  57 58 59 60  73 74 75 76
29 30 31 32  45 46 47 48  61 62 63 64  77 78 79 80

             81 82 83 84
             85 86 87 88
             89 90 91 92
             93 94 95 96
</pre></div>


<p>We can rearrange this into a 96-tuple:</p>
<div class="highlight"><pre><span></span>(1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96)
</pre></div>


<p>If we apply a rotation, for example <code>U R</code>, 
we will end up with a different cube:</p>
<div class="highlight"><pre><span></span>             13 09 05 01
             14 10 06 02
             15 11 07 03
             48 44 40 36

33 34 35 84  61 57 53 49  16 66 67 68  17 18 19 20
21 22 23 24  37 38 39 88  62 58 54 50  12 70 71 72
25 26 27 28  41 42 43 92  63 59 55 51  08 74 75 76
29 30 31 32  45 46 47 96  64 60 56 52  04 78 79 80

             81 82 83 77
             85 86 87 73
             89 90 91 69
             93 94 95 65
</pre></div>


<p>This particular sequence of moves results in 
a cube state uniquely represented by the following 
96-tuple:</p>
<div class="highlight"><pre><span></span>(13 9 5 1 14 10 6 2 15 11 7 3 48 44 40 36 33 34 35 84 21 22 23 24 25 26 27 28 29 30 31 32 61 57 53 49 37 38 39 88 41 42 43 92 45 46 47 96 16 66 67 68 62 58 54 50 63 59 55 51 64 60 56 52 17 18 19 20 12 70 71 72 8 74 75 76 4 78 79 80 81 82 83 77 85 86 87 73 89 90 91 69 93 94 95 65)
</pre></div>


<p><a name="rubiks1-tuple-representation"></a></p>
<h2>Tuple Representation</h2>
<p>Now, we have managed to find a unique representation for any given cube state 
by labeling each individual face 1-96.</p>
<p>But we aren't quite done yet. It turns out that our 
statement, that our representation should treat each
face as unique, is not strictly true for all 96 faces.</p>
<p>The square pieces are completely interchangeable, due to 
the fact that they are not connected to any other faces
(and therefore have no orientation or way of differentiating
them from one another).</p>
<p>If we are doing anything that involves counting 
configurations, it is important to account for this fact,
by treating the following groups of face indices as
interchangeable:</p>
<div class="highlight"><pre><span></span>(6, 7, 10, 11)
(22, 23, 26, 27)
(38, 39, 42, 43)
(54, 55, 58, 59)
(70, 71, 74, 75)
(86, 87, 90, 91)
</pre></div>


<p>In Part 2 and Part 3 of this series, we will 
encounter these concepts again, and it will
become more clear what these caveats and 
notes mean through example.</p>
<p>Following is a preview of Part 2 of this 3-part blog post.</p>
<p><a name="rubiks1-preview"></a></p>
<h1>Preview of Part 2</h1>
<p>In Part 2 of this series, we will utilize the n-tuple representation
of the 4x4 Rubik's Cube in order to write permutations of the cube
corresponding to specific states, and turn a sequence of moves on the 
cube into permutations.</p>
<p>We will also create a map for each type of move, telling us 
where each face index will end up.</p>
<p>In Part 3 we will use these to predict properties of 
rotations applied to the 4x4 Rubik's Cube.</p>
<p><a name="rubiks1-references"></a></p>
<h1>References</h1>
<ol>
<li>
<p>"Rubik's Cube". Charlesreid1.com wiki, Charles Reid. Edited 11 January 2017. Accessed 11 January 2017.
&lt;<a href="https://charlesreid1.com/wiki/Rubiks_Cube">https://charlesreid1.com/wiki/Rubiks_Cube</a>&gt;</p>
</li>
<li>
<p>"Rubik's Revenge". Charlesreid1.com wiki, Charles Reid. Edited 11 January 2017. Accessed 11 January 2017.
&lt;<a href="https://charlesreid1.com/wiki/Rubiks_Revenge">https://charlesreid1.com/wiki/Rubiks_Revenge</a>&gt;</p>
</li>
<li>
<p>"Rubik's Cube/Tuple". Charlesreid1.com wiki, Charles Reid. Edited 11 January 2017. Accessed 11 January 2017.
&lt;<a href="https://charlesreid1.com/wiki/Rubiks_Cube/Tuple">https://charlesreid1.com/wiki/Rubiks_Cube/Tuple</a>&gt;</p>
</li>
<li>
<p>"Rubik's Cube/Permutations". Charlesreid1.com wiki, Charles Reid. Edited 11 January 2017. Accessed 11 January 2017.
&lt;<a href="https://charlesreid1.com/wiki/Rubiks_Cube/Permutations">https://charlesreid1.com/wiki/Rubiks_Cube/Permutations</a>&gt;</p>
</li>
<li>
<p>"Github - dwalton76/rubiks-cube-NxNxN-solver". dwalton76, Github Repository, Github Inc. Accessed 11 January 2017.
&lt;<a href="https://github.com/dwalton76/rubiks-cube-NxNxN-solver">https://github.com/dwalton76/rubiks-cube-NxNxN-solver</a>&gt;</p>
</li>
<li>
<p>"Rubik's Cube NxNxN Solver". Git repository, git.charlesreid1.com. Charles Reid. Updated 11 January 2017.
&lt;<a href="https://charlesreid1.com:3000/charlesreid1/rubiks-cube-nnn-solver">https://git.charlesreid1.com/charlesreid1/rubiks-cube-nnn-solver</a>&gt;</p>
</li>
<li>
<p>"Rubiks Cube Cycles". Git repository, git.charlesreid1.com. Charles Reid. Updated 11 January 2017.
&lt;<a href="https://charlesreid1.com:3000/charlesreid1/rubiks-cube-cycles">https://git.charlesreid1.com/charlesreid1/rubiks-cube-cycles</a>&gt;</p>
</li>
</ol></div>

    </div>
</div>

<div class="v20"></div>

<div class="row">
    <div class="col-md-12" style="text-align: left;">

        <div class="tags">
            <p>Tags:&nbsp;&nbsp;&nbsp;
                    <a href="https://charlesreid1.github.io/tag/rubiks-cube.html">rubiks cube</a>
                    &nbsp;&nbsp;
                    <a href="https://charlesreid1.github.io/tag/mathematics.html">mathematics</a>
                    &nbsp;&nbsp;
                    <a href="https://charlesreid1.github.io/tag/combinatorics.html">combinatorics</a>
                    &nbsp;&nbsp;
                    <a href="https://charlesreid1.github.io/tag/permutations.html">permutations</a>
                    &nbsp;&nbsp;
                    <a href="https://charlesreid1.github.io/tag/python.html">python</a>
                    &nbsp;&nbsp;
                    <a href="https://charlesreid1.github.io/tag/puzzles.html">puzzles</a>
                    &nbsp;&nbsp;
        </div>

    </div>
</div>


<div class="v200"></div>
  	            	</article>
  	            	<article>
<header>
<div class="row">


    <div class="col-md-12">
        <div class="headtext" style="text-align: center;">
            <h1><b>
                Let's Generate Permutations!
            </b></h1>
        
            <p class="lead">
                Posted 
                <time datetime="2018-01-02T18:00:00-08:00" pubdate>Tuesday 01/02/2018</time>
                in 
                <a href="https://charlesreid1.github.io/category/computer-science.html">Computer Science</a>
                </p>
            <p>
            <span style="font-size: 14px">
                <a href="https://charlesreid1.github.io/lets-generate-permutations.html">permalink</a>
            </span>
            </p>
        </div>

    </div>

</div>
</header>


<div class="v50"></div>


<div class="row">
    <div class="col-md-12" style="text-align: left;">

        <div class="entry-content"><h1>Generating Permutations</h1>
<p>In today's post we're going to discuss the generation of permutations.</p>
<p>Often, in combinatorics problems, we are interested in <em>how many</em> different
instances or configurations of a particular thing we can have (what we'll call
"enumeration" or "counting"). However, that is different from wanting to 
actually see all of those configurations. Indeed, if we are counting 
something with an astronomical number of configurations, we don't want 
to try to list all of them.</p>
<p>However, as usual, Donald Knuth, who covers the topic of permutation 
generation in Volume 4A of his classic work, 
<u>The Art of Computer Programming</u>,
uncovers a problem that is much more complicated and subtle
than it initially appears.</p>
<h2>Background: Radix Method for Generating Permutations</h2>
<p>In Volume 4A of his classic work, <u>The Art of Computer Programming</u>, 
Donald Knuth turns to the question of generating permutations for a given
combinatoric system. The book opens with Knuth jumping immediately into 
the problem of generating permutations.</p>
<p>Algorith M is the first algorithm Knuth presents to generate all unique tuples.
To pose the problem a little more clearly, consider a combinatoric system that
has <span class="math">\(n\)</span> independent parts, each part having a number of possible states.
We can completely specify the state of the combinatoric system by specifying
an <span class="math">\(n\)</span>-tuple:</p>
<div class="math">$$
(a_1, a_2, \dots, a_n)
$$</div>
<p>where each independent variable takes on one of its possible values <span class="math">\(0 \leq a_i \leq m_i\)</span>.</p>
<p>Knuth's Algorithm M starts by setting all a's to 0, and incrementing 
the right-most entry of the tuple (carrying if necessary). </p>
<p>This is equivalent to counting in binary from 0 to <span class="math">\(N-1\)</span>,
or to labeling every possible outcome with a number between 0 and <span class="math">\(N-1\)</span>.</p>
<p>This becomes more clear if we consider the <span class="math">\(n\)</span>-tuple to be 
a number in a variable-radix system:</p>
<p>The number is <span class="math">\(\left[ a_1, a_2, \dots, a_n \right]\)</span></p>
<p>The radix is <span class="math">\(\left[ m_1, m_2, \dots, m_n \right]\)</span></p>
<p>By repeatedly adding 1 to the number <span class="math">\(\left[ a_1, a_2, \dots, a_n \right]\)</span>, 
we iterate through every possible tuple <span class="math">\((a_1, a_2, \dots, a_n)\)</span> and 
therefore through every possible combination of the independent variables.</p>
<h2>Knuth's Algorithm M</h2>
<p><strong>Algorithm M</strong> <em>(Mixed-radix generation)</em>. This algorithm visits all <span class="math">\(n\)</span>-tuples that satisfy the number/radix expressions above, by repeatedly adding 1 to the mixed-radix number until overflow occurs. (Aux. variables <span class="math">\(a_0\)</span> and <span class="math">\(m_0\)</span> introduced for convenience only.)</p>
<p><strong>M1.</strong> [Initialize.] Set <span class="math">\(a_j \rightarrow 0\)</span> for <span class="math">\(0 \leq j \leq n\)</span>, set <span class="math">\(m_0 \rightarrow 2\)</span>.</p>
<p><strong>M2.</strong> [Visit.] Visit the <span class="math">\(n\)</span>-tuple <span class="math">\((a_1, \dots, a_n)\)</span>. (The program that wants to examine all <span class="math">\(n\)</span>-tulpes now does its thing.)</p>
<p><strong>M3.</strong> [Prepare to add one.] Set <span class="math">\(j \rightarrow n\)</span>.</p>
<p><strong>M4.</strong> [Carry if necessary.] If <span class="math">\(a_j = m_j - 1\)</span>, set <span class="math">\(a_j \rightarrow 0, j \rightarrow j-1\)</span> and repeat this step.</p>
<p><strong>M5.</strong> [Increase, unless done.] If <span class="math">\(j=0\)</span>, terminate algorithm. Otherwise set <span class="math">\(a_j = a_j + 1\)</span> and go back to step <span class="math">\(M2\)</span>.</p>
<h2>Implementing Algorithm M</h2>
<p>Unfortunately, this pseudocode takes some work to translate. Fortunately, that's already done in the method below.</p>
<p>The method below implements Algorithm M in Python to generate random sequences on a 4x4 Rubik's Cube (called the Rubik's Revenge, or RR for short). The RR cube has six faces that can each be rotated clockwise or counterclockwise by a single layer, denoted by the uppercase letters U, D, B, F, L, R (up, down, back, front, left, right, respectively) for clockwise rotations and U', D', B', F', L', R' for counterclockwise rotations, for 12 total moves.</p>
<p>However, on a 4x4 cube, we can also rotate <em>two</em> layers at a time. (That's the limit; moving three layers at a time is equivalent to a reversed rotation of the remaining single layer.) This type of rotation is denoted with a "w".</p>
<p>Thus, rotating the top two layers of each of the six faces clockwise is denoted Uw, Dw, Bw, Fw, Lw, Rw, and counterclockwise rotations are denoted Uw', Dw', Bw', Fw', Lw', Rw', for 12 additional moves.</p>
<p>We have one more type of move, which is where the second layer only is removed. This type of move is denoted with 2, and the face whose second layer is being rotated, for six moves: 2U, 2D, 2B, 2F, 2L, 2R. The prime notation denotes again a counterclockwise rotation, for an additional six moves: 2U', 2D', 2B', 2F', 2L', 2R'. This yields another 12 moves.</p>
<p>There are 36 total moves that can be executed on the 4x4 Rubik's Revenge cube.</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">algorithm_m</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Knuth&#39;s Algorithm M for permutation generation,</span>
<span class="sd">    via AOCP Volume 4 Fascile 2.</span>
<span class="sd">    This is a generator that returns permtuations </span>
<span class="sd">    generated using the variable-radix method. </span>

<span class="sd">    This generates ALL permutations.</span>
<span class="sd">    Many of these are rotations of one another,</span>
<span class="sd">    so use the get_rotations() function</span>
<span class="sd">    (defined later) to eliminate redundant sequences.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">moves</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">,</span><span class="s1">&#39;B&#39;</span><span class="p">,</span><span class="s1">&#39;C&#39;</span><span class="p">,</span><span class="s1">&#39;D&#39;</span><span class="p">]</span>

    <span class="c1"># M1 - Initialize</span>
    <span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,]</span><span class="o">*</span><span class="n">n</span>
    <span class="n">m</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">moves</span><span class="p">),]</span><span class="o">*</span><span class="n">n</span>

    <span class="n">j</span> <span class="o">=</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span>

    <span class="n">nvisits</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>

        <span class="c1"># M2 - visit</span>
        <span class="n">move_sequence</span> <span class="o">=</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span> <span class="n">moves</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">aj</span><span class="p">)]</span> <span class="k">for</span> <span class="n">aj</span> <span class="ow">in</span> <span class="n">a</span><span class="p">])</span>
        <span class="k">yield</span> <span class="n">move_sequence</span> 

        <span class="n">nvisits</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># M3 - prepare to +1</span>
        <span class="n">j</span> <span class="o">=</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span>

        <span class="c1"># M4 - carry</span>
        <span class="k">while</span><span class="p">(</span> <span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="n">m</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">j</span><span class="o">-</span><span class="mi">1</span>

        <span class="c1"># M5 - increase unless done</span>
        <span class="k">if</span><span class="p">(</span><span class="n">j</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">):</span>
            <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
</pre></div>


<h2>Test Drive</h2>
<p>Let's take a look at how Algorithm M looks when it is applied. 
No surprises here: Algorithm M generates each of the possible 
permutations in sequence.</p>
<div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pprint</span> <span class="kn">import</span> <span class="n">pprint</span>

<span class="c1"># (Algorithm M goes here) </span>

<span class="k">if</span> <span class="vm">__name__</span><span class="o">==</span><span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">pprint</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">algorithm_m</span><span class="p">(</span><span class="mi">3</span><span class="p">)))</span>
</pre></div>


<p>and the result:</p>
<div class="highlight"><pre><span></span>    [&#39;A A A&#39;,
     &#39;A A B&#39;,
     &#39;A A C&#39;,
     &#39;A A D&#39;,
     &#39;A B A&#39;,
     &#39;A B B&#39;,
     &#39;A B C&#39;,
     &#39;A B D&#39;,
     &#39;A C A&#39;,
     &#39;A C B&#39;,
     &#39;A C C&#39;,
     &#39;A C D&#39;,
     &#39;A D A&#39;,
     &#39;A D B&#39;,
     &#39;A D C&#39;,
     &#39;A D D&#39;,
     &#39;B A A&#39;,
     &#39;B A B&#39;,
     &#39;B A C&#39;,
     &#39;B A D&#39;,
     &#39;B B A&#39;,
     &#39;B B B&#39;,
     &#39;B B C&#39;,
     &#39;B B D&#39;,
     &#39;B C A&#39;,
     &#39;B C B&#39;,
     &#39;B C C&#39;,
     &#39;B C D&#39;,
     &#39;B D A&#39;,
     &#39;B D B&#39;,
     &#39;B D C&#39;,
     &#39;B D D&#39;,
     &#39;C A A&#39;,
     &#39;C A B&#39;,
     &#39;C A C&#39;,
     &#39;C A D&#39;,
     &#39;C B A&#39;,
     &#39;C B B&#39;,
     &#39;C B C&#39;,
     &#39;C B D&#39;,
     &#39;C C A&#39;,
     &#39;C C B&#39;,
     &#39;C C C&#39;,
     &#39;C C D&#39;,
     &#39;C D A&#39;,
     &#39;C D B&#39;,
     &#39;C D C&#39;,
     &#39;C D D&#39;,
     &#39;D A A&#39;,
     &#39;D A B&#39;,
     &#39;D A C&#39;,
     &#39;D A D&#39;,
     &#39;D B A&#39;,
     &#39;D B B&#39;,
     &#39;D B C&#39;,
     &#39;D B D&#39;,
     &#39;D C A&#39;,
     &#39;D C B&#39;,
     &#39;D C C&#39;,
     &#39;D C D&#39;,
     &#39;D D A&#39;,
     &#39;D D B&#39;,
     &#39;D D C&#39;,
     &#39;D D D&#39;]
</pre></div>


<h2>What Other Ways Are There?</h2>
<p>All of this may seem obvious or uninteresting,
if you don't realize there are other ways of 
generating all possible <span class="math">\(n\)</span>-tuples.</p>
<p>It's a bit easier to think about for binary 
numbers. Imagine you're trying to generate 
every possible 10-digit binary number.
This means generating all binary numbers
between <span class="math">\(0\)</span> and <span class="math">\(2^{10}-1\)</span>. </p>
<p>Algorithm M, as we saw above, just counts 
from 0 to <span class="math">\(2^{10}-1\)</span>. But this can involve
changing a large number of bits (for example,
adding 1 to 001111111 results in 010000000,
changing 8 digits. Knuth presents an
alternative algorithm that only requires
changing <em>one</em> bit to generate the next
permutation, making the algorithm much 
faster.</p>
<p>More on that algorithm in a future blog post...</p>
<script type="text/javascript">if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width < 768) ? "left" : align;
        indent = (screen.width < 768) ? "0em" : indent;
        linebreak = (screen.width < 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
</script></div>

    </div>
</div>

<div class="v20"></div>

<div class="row">
    <div class="col-md-12" style="text-align: left;">

        <div class="tags">
            <p>Tags:&nbsp;&nbsp;&nbsp;
                    <a href="https://charlesreid1.github.io/tag/combinatorics.html">combinatorics</a>
                    &nbsp;&nbsp;
                    <a href="https://charlesreid1.github.io/tag/permutations.html">permutations</a>
                    &nbsp;&nbsp;
                    <a href="https://charlesreid1.github.io/tag/python.html">python</a>
                    &nbsp;&nbsp;
                    <a href="https://charlesreid1.github.io/tag/computer-science.html">computer science</a>
                    &nbsp;&nbsp;
                    <a href="https://charlesreid1.github.io/tag/algorithms.html">algorithms</a>
                    &nbsp;&nbsp;
                    <a href="https://charlesreid1.github.io/tag/art-of-computer-programming.html">art of computer programming</a>
                    &nbsp;&nbsp;
                    <a href="https://charlesreid1.github.io/tag/knuth.html">knuth</a>
                    &nbsp;&nbsp;
        </div>

    </div>
</div>


<div class="v200"></div>
  	            	</article>
  	            	<article>
<header>
<div class="row">


    <div class="col-md-12">
        <div class="headtext" style="text-align: center;">
            <h1><b>
                Five Letter Words: Part 3: Letter Coverage and Dynamic Programming
            </b></h1>
        
            <p class="lead">
                Posted 
                <time datetime="2017-09-19T12:00:00-07:00" pubdate>Tuesday 09/19/2017</time>
                in 
                <a href="https://charlesreid1.github.io/category/computer-science.html">Computer Science</a>
                </p>
            <p>
            <span style="font-size: 14px">
                <a href="https://charlesreid1.github.io/five-letter-words-part-3-letter-coverage-and-dynamic-programming.html">permalink</a>
            </span>
            </p>
        </div>

    </div>

</div>
</header>


<div class="v50"></div>


<div class="row">
    <div class="col-md-12" style="text-align: left;">

        <div class="entry-content"><p><em>NOTE: The code covered in this post uses Python 3. The scripts can be converted to Python 2 with minimal effort,
but the author would encourage any user of Python 2 to "put on your big kid pants" and 
make the switch to Python 3. Let's all make this painful, drawn-out switch from Python 2 
to Python 3 a thing of the past, shall we?</em></p>
<h2>Table of Contents</h2>
<ul>
<li><a href="#five3-intro">Introduction</a></li>
<li><a href="#five3-example">A Simple Manual Exmaple</a></li>
<li><a href="#five3-pseudocode">Pseudocode</a></li>
<li><a href="#five3-python">Python Code</a></li>
<li><a href="#five3-output">Output and Timing</a></li>
</ul>
<p><a name="five3-intro"></a></p>
<h2>Introduction</h2>
<p>The letter/word coverage problem, as presented by Donald Knuth in Volume 4, Facicle 0 
of his masterpiece <u>Art of Computer Programming</u>, is the problem of finding
the <em>minimum</em> number of words from the collection of five letter words that 
"cover" (are drawn from) the first N letters of the alphabet.</p>
<p>The problem has a couple of variations:</p>
<ul>
<li>Provided a set of letters, search for the smallest number of words that cover those particular letters.</li>
<li>Given an integer <span class="math">\(N \leq 26\)</span>, search for the smallest number of words that cover the first N letters of the alphabet.</li>
<li>The same problem as above, but drawing from the first <span class="math">\(M\)</span> words of the 5757 total five-letter words.</li>
</ul>
<p>For the sake of simplicity, we will focus on the simplest problem: considering the first <span class="math">\(N\)</span> 
letters of the alphabet, find the shortest sequence of words that will provide coverage of the first 
<span class="math">\(N\)</span> letters of the alphabet.</p>
<p>This is an example of a dynamic programming problem: a combinatorics problem that can 
be solved by breaking the overall down into smaller sub-problems, solving the sub-problems, and 
assembling solutions to the sub-problems into an overall problem solution.</p>
<p>The procedure is as follows:</p>
<ul>
<li>For each word <span class="math">\(w_i\)</span>, we begin by assuming this word is the best solution <em>on its own</em>. This forms the base case/starting solution.</li>
<li>Next, examine all prior words <span class="math">\(w_j, j&lt;i\)</span>, and compare each to using the word <span class="math">\(w_i\)</span> by itself.</li>
<li>For each pair of words, take the union (OR) of the character coverage for word <span class="math">\(w_i\)</span> 
and the solution bit vector for word <span class="math">\(w_j\)</span> (that is, using the best-covered solution so far 
for word <span class="math">\(w_j\)</span>)</li>
<li>Note: for word <span class="math">\(w_i\)</span>, we need to store one of these unions as the best-covered solution so far for 
word <span class="math">\(w_i\)</span>, but we aren't sure which one yet.)</li>
<li>For the given pair of words <span class="math">\(w_j\)</span> and <span class="math">\(w_i\)</span>, we are looking at word <span class="math">\(w_j\)</span> and considering the possibility 
of extending that with word <span class="math">\(w_i\)</span>. Adding <span class="math">\(w_i\)</span> to the best solution so far may or may not improve the best solution,
so we need to decide whether to add <span class="math">\(w_i\)</span> to the best solution so far.</li>
<li>Compute the number of letters covered in the union of <span class="math">\(w_i\)</span> and the best solution so far (by, e.g., 
summing up the 1s in the bit vector of <span class="math">\(w_i\)</span> added to the bit vector representing the best solution so far for word <span class="math">\(w_j\)</span>)</li>
<li>Compute the number of words in the best solution so far for word <span class="math">\(w_j\)</span>, and add one to it (representing the new word <span class="math">\(w_i\)</span> being added)</li>
<li>We are searching for the prior solution for word <span class="math">\(w_j\)</span> that will lead to the maximum number of 1s in the bit vector</li>
<li>We break ties by picking the word <span class="math">\(w_j\)</span> that will minimize the number of total words</li>
<li>Once we find the best word <span class="math">\(w_j\)</span>, we save the union bit vector for word <span class="math">\(w_i\)</span> and word <span class="math">\(w_j\)</span> under the 
word <span class="math">\(w_i\)</span> combined solution bit vector; we save the length of 1s in the combined solution bit vector; and we save 
the number of words so far in that solution.</li>
</ul>
<p>Once we have gone through every word, we are ready to find the minimum. Do this by:</p>
<ul>
<li>Searching through the solutions for every word, and pick out the one that maximizes the number of 1s in the solution bit vector
(or, rather, that has the correct number of 1s in the bit vector) while also minimizing the total number of words.</li>
<li>To get the actual sequence of words, rather than just the minimum number of jwords, we need to save the prior word
that leads to the maximum number of 1s in the solution bit vector and minimum number of words, for each word.
Then, at the end, we can backtrack through the words that compose the solution.</li>
</ul>
<p>This is a bit complicated to explain in words, so we'll give a small example,
then some pseudocode. Then we'll present the actual Python program that accomplishes
this task.</p>
<p><a name="five3-example"></a></p>
<h2>A Simple Manual Example</h2>
<p>Let's walk through an example manually to illustrate the approach:</p>
<p>Suppose we are considering 2-letter words taken from a 5-letter alphabet <em>abcde</em>.
We can represent a given word as a binary string or bit vector: for example,
the two-letter word <code>aa</code> would be represented by the bit vector <code>10000</code>,
<code>ab</code> would be represented by the bit vector <code>11000</code>, etc.</p>
<p>Now let's consider a set of words, and step through the algorithm with them.</p>
<div class="highlight"><pre><span></span>W0 = aa = 10000
W1 = ab = 11000
W2 = bc = 01100
W3 = aa = 10000
W4 = dd = 00010
W5 = de = 00011
W6 = bb = 01000
</pre></div>


<p>Now, we wish to write a dynamic program that will find the smallest set of 
words such that taking the union of each bit vector for each of the words in 
the set will yield the bit vector <code>11111</code>. At each step, we seek the words that will 
maximize the number of 1s in the union of the bit vectors, while minimizing the number
of words. We take the union of the "longest sequence of 1s" bit vector from the 
prior step, plus the bit vector from the current step.</p>
<p><em>W0: aa</em></p>
<p>Start with word W0: this is the only bit vector, so it sets the starting "largest sequence of 1s" bit vector. 
We wish to maximize "largest sequence of 1s" and minimize number of words.</p>
<ul>
<li>only W0 as solution is therefore <span class="math">\(10000\)</span>. The number of 1s is 1. The number of words is 1. (W0 SOLUTION)</li>
</ul>
<p><em>W1: ab</em></p>
<p>Start with word W1: this is the only bit vector, so it sets the starting "largest sequence of 1s" bit vector. 
We wish to maximize "largest sequence of 1s" and minimize number of words.</p>
<ul>
<li>only W1 as solution is therefore <span class="math">\(11000\)</span>. The number of 1s is 2. The number of words is 1. (W1 SOLUTION)</li>
<li>union of W0 solution and W1 <span class="math">\(10000 \bigcup 11000 = 11000\)</span>. The number of 1s is 2. The number of words is 2.</li>
</ul>
<p><em>W2: bc</em></p>
<p>Next is word W2: the "largest sequence of 1s" bit vector is the union of the prior step's "largest sequence of 1s" bit vector and the current word's bit vector. One option:</p>
<ul>
<li>only W2 as solution is <span class="math">\(01100\)</span>. The number of 1s is 2. The number of words is 1.</li>
<li>union of W0 solution and W2 <span class="math">\(10000 \bigcup 01100 = 11100\)</span>. The number of 1s is 3. The number of words is 2. (W2 SOLUTION)</li>
<li>union of W1 solution and W2 <span class="math">\(11000 \bigcup 01100 = 11100\)</span>. The number of 1s is 3. The number of words is 2.</li>
</ul>
<p><em>W3: aa</em></p>
<p>Next is word W3: the "largest sequence of 1s" bit vector is the union that maximizes the number of 1s and minimizes the number of words. Two options:</p>
<ul>
<li>only W3 as solution is <span class="math">\(10000\)</span>. The number of 1s is 1. The number of words is 1.</li>
<li>union of W0 solution and W3 <span class="math">\(10000 \bigcup 10000 = 10000\)</span>. The number of 1s is 1. The number of words is 2.</li>
<li>union of W1 solution and W3 <span class="math">\(11000 \bigcup 10000 = 11000\)</span>. The number of 1s is 2. The number of words is 2.</li>
<li>union of W2 solution and W3 <span class="math">\(11100 \bigcup 10000 = 11100\)</span>. The number of 1s is 3. The number of words is 3. (W3 SOLUTION)</li>
</ul>
<p><em>W4: dd</em></p>
<p>Next is word W4: the "largest sequence of 1s" bit vector is the union that maximizes the number of 1s and minimizes the number of words. Three options:</p>
<ul>
<li>only W4 as solution is <span class="math">\(00010\)</span>. The number of 1s is 1. The number of words is 1.</li>
<li>union of W0 solution and W4 <span class="math">\(10000 \bigcup 00010 = 10010\)</span>. The number of 1s is 2. The number of words is 2.</li>
<li>union of W1 solution and W4 <span class="math">\(11000 \bigcup 00010 = 11010\)</span>. The number of 1s is 3. The number of words is 2.</li>
<li>union of W2 solution and W4 <span class="math">\(11100 \bigcup 00010 = 11110\)</span>. The number of 1s is 4. The number of words is 3. (W4 SOLUTION)</li>
<li>union of W3 solution and W4 <span class="math">\(11100 \bigcup 00010 = 11110\)</span>. The number of 1s is 4. The number of words is 4.</li>
</ul>
<p><em>W5: de</em></p>
<p>Next is word W5: the "largest sequence of 1s" bit vector is the union maximizing number of 1s and minimizing number of words. Four options:</p>
<ul>
<li>only W5 as solution is <span class="math">\(00011\)</span>. The number of 1s is 2. The number of words is 1.</li>
<li>union of W0 solution and W5 <span class="math">\(10000 \bigcup 00010 = 10010\)</span>. The number of 1s is 2. The number of words is 2.</li>
<li>union of W1 solution and W5 <span class="math">\(11000 \bigcup 00011 = 11011\)</span>. The number of 1s is 4. The number of words is 2.</li>
<li>union of W2 solution and W5 <span class="math">\(11100 \bigcup 00011 = 11111\)</span>. The number of 1s is 5. The number of words is 3. (W5 SOLUTION)</li>
<li>union of W3 solution and W5 <span class="math">\(11100 \bigcup 00011 = 11111\)</span>. The number of 1s is 5. The number of words is 4.</li>
<li>union of W4 solution and W5 <span class="math">\(11110 \bigcup 00111 = 11111\)</span>. The number of 1s is 5. The number of words is 4.</li>
</ul>
<p><em>W6:</em></p>
<p>Next is word W6: the "largest sequence of 1s" bit vector is the union maximizing number of 1s and minimizing number of words. Five options:</p>
<ul>
<li>only W6 as solution is <span class="math">\(01000\)</span>. The number of 1s is 1. The number of words is 1.</li>
<li>union of W0 solution and W6 <span class="math">\(10000 \bigcup 01000 = 11000\)</span>. The number of 1s is 2. The number of words is 2.</li>
<li>union of W1 solution and W6 <span class="math">\(11000 \bigcup 01000 = 11000\)</span>. The number of 1s is 2. The number of words is 2.</li>
<li>union of W2 solution and W6 <span class="math">\(11100 \bigcup 01000 = 11100\)</span>. The number of 1s is 3. The number of words is 3.</li>
<li>union of W3 solution and W6 <span class="math">\(11100 \bigcup 01000 = 11100\)</span>. The number of 1s is 3. The number of words is 4.</li>
<li>union of W4 solution and W6 <span class="math">\(11110 \bigcup 01000 = 11110\)</span>. The number of 1s is 4. The number of words is 4.</li>
<li>union of W5 solution and W6 <span class="math">\(11111 \bigcup 01000 = 11111\)</span>. The number of 1s is 5. The number of words is 4. (W6 SOLUTION)</li>
</ul>
<p>(NOTE: We don't need to consider every possible combination of W1, W2, W3, W4, W5, and W6; we only need to consider each word once, because each word's current solution can be written in terms of the prior word's solution, so we only need to consider solutions for each word. We've already considered the non-solutions and can therefore ignore them because they don't maximize number of 1s and minimize number of words.)</p>
<p>Thus far, we have found a ''local'' solution for each word. We can now compare all of these ''local'' solutions to find a ''global'' solution. The global solution will maximize the number of 1s found (meaning we can toss out any solutions that have less than 5 1s), and minimizes the total number of words (meaning, our W5 solution gives us the global optimum).</p>
<p>Therefore our global solution is the W5 solution: 5 1s, and 3 words. Thus, backtracking, we see that the words W1, W2, W5 cover all of the first five letters, with the minimum number of total words.</p>
<div class="highlight"><pre><span></span>W0 = aa = 10000
W2 = bc = 01100
W5 = de = 00011
</pre></div>


<p><a name="five3-pseudocode"></a></p>
<h2>Pseudocode</h2>
<p>Here is the pseudocode for the program. We utilize one function to compute
the letter coverage bit vector for a single word, and the rest of the 
functionality will go in the main method:</p>
<div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">word2bitvector</span><span class="p">(</span><span class="nx">word</span><span class="p">)</span><span class="o">:</span>
    <span class="nx">initialize</span> <span class="mi">26</span><span class="o">-</span><span class="nx">element</span> <span class="nx">bit</span> <span class="nx">vector</span> <span class="kd">with</span> <span class="mi">0</span><span class="nx">s</span> <span class="p">(</span><span class="nx">one</span> <span class="mi">0</span> <span class="nx">per</span> <span class="nx">letter</span><span class="p">)</span>
    <span class="k">for</span> <span class="nx">each</span> <span class="nx">letter</span> <span class="k">in</span> <span class="nx">word</span>:
        <span class="kt">turn</span> <span class="nx">the</span> <span class="nx">bit</span> <span class="k">for</span> <span class="k">this</span> <span class="nx">letter</span> <span class="nx">to</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="nx">bit</span> <span class="nx">vector</span>

<span class="nx">fuction</span> <span class="nx">main</span><span class="p">()</span><span class="o">:</span>

    <span class="c1">// initialization step:</span>
    <span class="nx">initialize</span> <span class="nx">best</span> <span class="nx">coverage</span> <span class="nx">bit</span> <span class="nx">vector</span>
    <span class="nx">initialize</span> <span class="nx">maximum</span> <span class="kt">number</span> <span class="nx">of</span> <span class="mi">1</span><span class="nx">s</span> <span class="p">(</span><span class="nx">the</span> <span class="kt">number</span> <span class="nx">of</span> <span class="nx">letters</span> <span class="nx">N</span> <span class="nx">we</span> <span class="nx">wish</span> <span class="nx">to</span> <span class="nx">cover</span><span class="p">)</span>
    <span class="nx">initialize</span> <span class="kt">number</span> <span class="nx">of</span> <span class="nx">words</span> <span class="k">in</span> <span class="nx">current</span> <span class="nx">solution</span>
    <span class="nx">initialize</span> <span class="nx">backtracking</span> <span class="nx">array</span> <span class="p">(</span><span class="k">for</span> <span class="nx">constructing</span> <span class="kr">final</span> <span class="nx">solution</span><span class="p">)</span>

    <span class="c1">// outer loop fencepost step:</span>
    <span class="nx">set</span> <span class="nx">things</span> <span class="nx">up</span> <span class="k">for</span> <span class="nx">word</span> <span class="mi">0</span> <span class="p">(</span><span class="nx">base</span> <span class="k">case</span><span class="p">)</span>

    <span class="c1">// loop through each word</span>
    <span class="k">for</span> <span class="nx">each</span> <span class="nx">word</span> <span class="k">in</span> <span class="nx">words</span><span class="o">:</span>
        <span class="c1">// skip word 0 (base case)</span>

        <span class="c1">// inner loop fencepost step:</span>
        <span class="nx">initialize</span> <span class="nx">things</span> <span class="k">for</span> <span class="nx">word</span> <span class="p">(</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">for</span> <span class="nx">each</span> <span class="nx">prior</span> <span class="nx">word</span> <span class="nx">j</span> <span class="o">&lt;</span> <span class="nx">i</span>:
            <span class="kt">compute</span> <span class="nx">the</span> <span class="k">new</span> <span class="nx">potential</span> <span class="nx">best</span> <span class="nx">coverage</span> <span class="nx">bitvector</span>
            <span class="nx">compute</span> <span class="nx">the</span> <span class="kt">number</span> <span class="nx">of</span> <span class="mi">1</span><span class="nx">s</span> <span class="k">in</span> <span class="nx">the</span> <span class="nx">bnew</span> <span class="nx">potential</span> <span class="nx">best</span> <span class="nx">coverage</span> <span class="nx">bit</span> <span class="nx">vector</span>
            <span class="nx">compute</span> <span class="nx">numbr</span> <span class="nx">of</span> <span class="nx">words</span> <span class="k">in</span> <span class="k">new</span> <span class="nx">potential</span> <span class="nx">best</span> <span class="nx">solution</span>
            <span class="k">if</span> <span class="k">this</span> <span class="nx">solution</span> <span class="nx">is</span> <span class="nx">better</span> <span class="nx">than</span> <span class="nx">current</span> <span class="nx">best</span> <span class="nx">solution</span>:
                <span class="kt">overwrite</span> <span class="nx">best</span> <span class="nx">solution</span> <span class="kd">with</span> <span class="nx">current</span> <span class="nx">solution</span>

    <span class="c1">// get solution:</span>
    <span class="nx">find</span> <span class="nx">maximum</span> <span class="nx">indices</span> <span class="nx">of</span> <span class="nx">vector</span> <span class="nx">of</span> <span class="kt">number</span> <span class="nx">of</span> <span class="mi">1</span><span class="nx">s</span> 
    <span class="c1">// (this is potentially multiple indices, representing multiple </span>
    <span class="c1">//  solutions that satisfy the coverage we want)</span>
    <span class="nx">find</span> <span class="nx">minimum</span> <span class="kt">number</span> <span class="nx">of</span> <span class="nx">words</span> <span class="nx">corresponding</span> <span class="nx">to</span> <span class="nx">each</span> <span class="nx">of</span> <span class="nx">the</span> <span class="nx">coverage</span> <span class="nx">indices</span>
    <span class="nx">backtrack</span> <span class="nx">through</span> <span class="nx">solution</span> <span class="nx">indices</span>
</pre></div>


<p><a name="five3-python"></a></p>
<h2>Python Code</h2>
<p>The code for this solution can be found here: <a href="https://git.charlesreid1.com/cs/five-letter-words/src/master/letter_coverage.py">letter_coverage.py</a></p>
<p>This code is as follows:</p>
<p>Start with the word-to-bit vector function:</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">word2bitvector</span><span class="p">(</span><span class="n">word</span><span class="p">,</span><span class="n">N</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Turns a five-letter word into a bit vector representing character coverage.</span>
<span class="sd">    Uses 26 letters by default.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">bit_vector</span> <span class="o">=</span> <span class="p">[</span><span class="bp">False</span><span class="p">,]</span><span class="o">*</span><span class="n">N</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">word</span><span class="p">:</span>
        <span class="n">i</span> <span class="o">=</span> <span class="nb">ord</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="o">-</span><span class="nb">ord</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">bit_vector</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
            <span class="k">pass</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">bit_vector</span><span class="p">)</span>
</pre></div>


<p>We also implement a few helper methods: the first turns a boolean bit vector into 
a pretty string of 0s and 1s:</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">printbv</span><span class="p">(</span><span class="n">bv</span><span class="p">):</span>
    <span class="n">result</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
    <span class="k">for</span> <span class="n">bit</span> <span class="ow">in</span> <span class="n">bv</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">bit</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">+=</span> <span class="s2">&quot;1&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">+=</span> <span class="s2">&quot;0&quot;</span>
    <span class="k">return</span> <span class="n">result</span>
</pre></div>


<p>The second method is our all-important backtracking to obtain the actual sequence of words
that leads to the minimum coverage, instead of just getting a count of the minimum number 
of words that it takes to cover the first <span class="math">\(N\)</span> letters:</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">btsolution</span><span class="p">(</span><span class="n">min_key</span><span class="p">,</span> <span class="n">min_val</span><span class="p">,</span> <span class="n">words</span><span class="p">,</span> <span class="n">bt</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Reconstruct the sequence of words that gives maximum coverage and minimum word count.</span>

<span class="sd">    Input: minimum word key (last word), minimum value (number of words), backtrack (prior word)</span>

<span class="sd">    Output: list of words</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">solution</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">solution</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">words</span><span class="p">[</span><span class="n">min_key</span><span class="p">])</span>
    <span class="n">prior_key</span> <span class="o">=</span> <span class="n">bt</span><span class="p">[</span><span class="n">min_key</span><span class="p">]</span>
    <span class="k">while</span> <span class="n">prior_key</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
        <span class="n">solution</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">words</span><span class="p">[</span><span class="n">prior_key</span><span class="p">])</span>
        <span class="n">prior_key</span> <span class="o">=</span> <span class="n">bt</span><span class="p">[</span><span class="n">prior_key</span><span class="p">]</span>
    <span class="k">return</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">solution</span><span class="p">)</span>
</pre></div>


<p>Finally, we get to the meat of the method: the dynamic program.
Start with some initialization. This is where we set the number of letters
we want to cover, and limit the "vocabulary" if desired: </p>
<div class="highlight"><pre><span></span><span class="k">if</span> <span class="vm">__name__</span><span class="o">==</span><span class="s2">&quot;__main__&quot;</span><span class="p">:</span>

    <span class="c1"># Searching for words covering first N letters</span>
    <span class="n">N</span> <span class="o">=</span> <span class="mi">13</span>

    <span class="n">words</span> <span class="o">=</span> <span class="n">get_words</span><span class="p">()</span>

    <span class="c1"># If we want to restrict our search to the first M letters,</span>
    <span class="c1">#words = words[:1000]</span>
</pre></div>


<p>We begin with the initialization step:</p>
<div class="highlight"><pre><span></span>    <span class="c1"># Initialization:</span>
    <span class="c1"># ----------------</span>

    <span class="c1"># Store best coverage bitvectors for each word</span>
    <span class="n">bestcoverage_bv</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">False</span><span class="p">]</span><span class="o">*</span><span class="n">N</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">words</span><span class="p">))]</span>

    <span class="c1"># Store number of 1s for best coverage vector for each word</span>
    <span class="n">ones_bv</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">words</span><span class="p">)</span>

    <span class="c1"># Store number of words in best solution for each word</span>
    <span class="n">ws</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">words</span><span class="p">)</span>

    <span class="c1"># Store prior word for backtracking</span>
    <span class="n">bt</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">words</span><span class="p">)</span>
</pre></div>


<p>Next comes the fencepost initialization step, where we intiialize the solution
for word 0:</p>
<div class="highlight"><pre><span></span>    <span class="c1"># Fencepost: Initial Step</span>
    <span class="c1"># Word 0</span>
    <span class="c1"># ----------------</span>

    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># Start with word 0</span>
    <span class="n">wi</span> <span class="o">=</span> <span class="n">words</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

    <span class="c1"># Best letter coverage bit vector</span>
    <span class="n">bestcoverage_bv</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">word2bitvector</span><span class="p">(</span><span class="n">words</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">N</span><span class="p">)</span>

    <span class="c1"># Length of 1s</span>
    <span class="n">ones_bv</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">bestcoverage_bv</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

    <span class="c1"># Number of words in best solution:</span>
    <span class="n">ws</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="c1"># Backtracking: first word has no prior word</span>
    <span class="n">bt</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
</pre></div>


<p>Next, we loop over each word <span class="math">\(w_i, i&gt;0\)</span>: </p>
<div class="highlight"><pre><span></span>    <span class="c1"># Start by assuming the word by itself, </span>
    <span class="c1"># and then examine each possible pairing</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">words</span><span class="p">)):</span>
        <span class="n">wi</span> <span class="o">=</span> <span class="n">words</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="c1"># Start with bitvector of word i&#39;s coverage</span>
        <span class="n">wi_bv</span> <span class="o">=</span> <span class="n">word2bitvector</span><span class="p">(</span><span class="n">wi</span><span class="p">,</span><span class="n">N</span><span class="p">)</span>

        <span class="c1"># Fencepost: initial step</span>
        <span class="c1"># Word i by itself</span>
        <span class="c1"># Assume word i is the first word in the solution,</span>
        <span class="c1"># and if we find a better combination with prior word,</span>
        <span class="c1"># overwrite this solution.</span>
        <span class="c1"># ------------------------</span>

        <span class="c1"># Best coverage so far (first guess) is word i by itself</span>
        <span class="n">bestcoverage_bv</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">wi_bv</span>

        <span class="c1"># Count ones in (first guess) best bitvector</span>
        <span class="n">ones_bv</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">bestcoverage_bv</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

        <span class="c1"># Number of words in new best solution:</span>
        <span class="n">ws</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="c1"># Backtracking</span>
        <span class="n">bt</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

        <span class="c1"># Boolean: is this the first word in the sequence of solutions?</span>
        <span class="n">first</span> <span class="o">=</span> <span class="bp">True</span>
</pre></div>


<p>We started by assuming that each word <span class="math">\(w_i\)</span> provides a best solution by itself;
the next step is to consider each pairing of <span class="math">\(w_i\)</span> with prior words <span class="math">\(w_j\)</span>,
and update our current solution if we find a better one: </p>
<div class="highlight"><pre><span></span>        <span class="c1"># Now loop over the rest of the words,</span>
        <span class="c1"># and look for a better solution.</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">i</span><span class="p">)):</span>

            <span class="c1"># Get the prior word</span>
            <span class="n">wj</span> <span class="o">=</span> <span class="n">words</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>

            <span class="c1"># Get best coverage bitvector </span>
            <span class="n">wj_bv</span> <span class="o">=</span> <span class="n">bestcoverage_bv</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>

            <span class="c1"># (potential) new combined coverage vector</span>
            <span class="n">bestcoverage_bv_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">wi_bv</span><span class="p">,</span> <span class="n">wj_bv</span><span class="p">)</span>

            <span class="c1"># Number of ones in (potential) new combined coverage vector</span>
            <span class="n">ones_bv_i</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">bestcoverage_bv_i</span><span class="p">)</span>

            <span class="c1"># Number of words in (potential) new best solution</span>
            <span class="n">ws_i</span> <span class="o">=</span> <span class="n">ws</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span>

            <span class="c1"># If this solution is better than our current one,</span>
            <span class="c1"># overwrite the current solution.</span>
            <span class="c1"># (Better means, &quot;more ones&quot;, or &quot;same ones and fewer words&quot;.)</span>

            <span class="c1">#import pdb; pdb.set_trace();</span>

            <span class="k">if</span><span class="p">(</span> <span class="p">(</span><span class="n">ones_bv_i</span> <span class="o">&gt;</span> <span class="n">ones_bv</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="ow">or</span> <span class="p">(</span><span class="n">ones_bv_i</span><span class="o">==</span><span class="n">ones_bv</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">and</span> <span class="n">ws_i</span> <span class="o">&lt;</span> <span class="n">ws</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">):</span>
                <span class="n">bestcoverage_bv</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">bestcoverage_bv_i</span>
                <span class="n">ones_bv</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">ones_bv_i</span>
                <span class="n">ws</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">ws_i</span>
                <span class="n">bt</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">j</span>

                <span class="c1"># This word now follows another word in the sequence of solutions</span>
                <span class="n">first</span> <span class="o">=</span> <span class="bp">False</span>

            <span class="c1"># It&#39;s tempting to stop early,</span>
            <span class="c1"># but what if we find the perfect </span>
            <span class="c1"># solution right at the end?!?</span>
</pre></div>


<p>Now that we have found the coverage for each word, and the corresponding number of words 
in that coverage solution, we find the solution that achieves the desired coverage 
while minimizing the number of words, so that we can construct the actual solution:</p>
<div class="highlight"><pre><span></span>    <span class="c1"># Okay, now actually get the solution.</span>
    <span class="c1"># The solution is the maximum of ones_bv and the minimum of ws</span>
    <span class="c1"># </span>
    <span class="c1"># Start by finding the maximum(s) of ones_bv</span>
    <span class="c1"># Then check each corresponding index of ws</span>
    <span class="n">ones_bv_indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ones_bv</span><span class="p">)</span> <span class="k">if</span> <span class="n">v</span><span class="o">==</span><span class="nb">max</span><span class="p">(</span><span class="n">ones_bv</span><span class="p">)]</span>

    <span class="n">min_key</span> <span class="o">=</span> <span class="n">ones_bv_indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">min_val</span> <span class="o">=</span> <span class="n">ones_bv</span><span class="p">[</span><span class="n">ones_bv_indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
    <span class="k">for</span> <span class="n">ix</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">ones_bv_indices</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
        <span class="k">if</span><span class="p">(</span><span class="n">ones_bv</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">min_key</span><span class="p">):</span>
            <span class="n">min_key</span> <span class="o">=</span> <span class="n">ix</span>
            <span class="n">min_val</span> <span class="o">=</span> <span class="n">ones_bv</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span>



    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;Min key: word &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">min_key</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot; = &quot;</span><span class="o">+</span><span class="n">words</span><span class="p">[</span><span class="n">min_key</span><span class="p">])</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;Min val: &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">min_val</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot; words to cover &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">N</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot; letters&quot;</span><span class="p">)</span>

    <span class="n">pprint</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">btsolution</span><span class="p">(</span><span class="n">min_key</span><span class="p">,</span> <span class="n">min_val</span><span class="p">,</span> <span class="n">words</span><span class="p">,</span> <span class="n">bt</span><span class="p">)))</span>
</pre></div>


<p><a name="output"></a></p>
<h2>Output and Timing</h2>
<p>Let's take a look at some example output from the program. 
This program only considers the first 1,000 words in the five-letter word list:</p>
<div class="highlight"><pre><span></span>$ <span class="nb">time</span> py letter_coverage.py
Takes <span class="m">9</span> words to cover <span class="m">15</span> letters
<span class="o">[</span><span class="s1">&#39;which&#39;</span>,
 <span class="s1">&#39;their&#39;</span>,
 <span class="s1">&#39;about&#39;</span>,
 <span class="s1">&#39;could&#39;</span>,
 <span class="s1">&#39;after&#39;</span>,
 <span class="s1">&#39;right&#39;</span>,
 <span class="s1">&#39;think&#39;</span>,
 <span class="s1">&#39;major&#39;</span>,
 <span class="s1">&#39;level&#39;</span><span class="o">]</span>

real    0m17.226s
user    0m17.090s
sys     0m0.087s
</pre></div>


<p>Here's the same program, considering all 5,757 words:</p>
<div class="highlight"><pre><span></span>$ <span class="nb">time</span> py letter_coverage.py
akes <span class="m">9</span> words to cover <span class="m">15</span> letters
<span class="o">[</span><span class="s1">&#39;which&#39;</span>,
 <span class="s1">&#39;their&#39;</span>,
 <span class="s1">&#39;about&#39;</span>,
 <span class="s1">&#39;could&#39;</span>,
 <span class="s1">&#39;after&#39;</span>,
 <span class="s1">&#39;right&#39;</span>,
 <span class="s1">&#39;think&#39;</span>,
 <span class="s1">&#39;major&#39;</span>,
 <span class="s1">&#39;level&#39;</span><span class="o">]</span>

real    9m29.619s
user    9m24.360s
sys 0m1.958s
</pre></div>


<p>Note that the algorithm is <span class="math">\(O(N^2)\)</span>, since it iterates over each word, and for each word,
it examines each possible pairing with a preceding word. Thus, if we increase the number of words
by a factor of 6, we expect the runtime to increase by a factor of 36, for an estimated runtime of 
<span class="math">\(36 \times 17 \mbox{ seconds} \approx 10 \mbox{ minutes}\)</span>, which is pretty close to what we see above.</p>
<script type="text/javascript">if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width < 768) ? "left" : align;
        indent = (screen.width < 768) ? "0em" : indent;
        linebreak = (screen.width < 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
</script></div>

    </div>
</div>

<div class="v20"></div>

<div class="row">
    <div class="col-md-12" style="text-align: left;">

        <div class="tags">
            <p>Tags:&nbsp;&nbsp;&nbsp;
                    <a href="https://charlesreid1.github.io/tag/dynamic-programming.html">dynamic programming</a>
                    &nbsp;&nbsp;
                    <a href="https://charlesreid1.github.io/tag/python.html">python</a>
                    &nbsp;&nbsp;
                    <a href="https://charlesreid1.github.io/tag/computer-science.html">computer science</a>
                    &nbsp;&nbsp;
                    <a href="https://charlesreid1.github.io/tag/graphs.html">graphs</a>
                    &nbsp;&nbsp;
                    <a href="https://charlesreid1.github.io/tag/algorithms.html">algorithms</a>
                    &nbsp;&nbsp;
                    <a href="https://charlesreid1.github.io/tag/art-of-computer-programming.html">art of computer programming</a>
                    &nbsp;&nbsp;
                    <a href="https://charlesreid1.github.io/tag/knuth.html">knuth</a>
                    &nbsp;&nbsp;
                    <a href="https://charlesreid1.github.io/tag/five-letter-words.html">five letter words</a>
                    &nbsp;&nbsp;
        </div>

    </div>
</div>


<div class="v200"></div>
  	            	</article>

<div class="row">
    <div class="col-md-4 col-centered" style="text-align: center;">

        <div class="pagination">

            <a class="next" href="https://charlesreid1.github.io/index10.html">&larr; Newer</a>

            &nbsp;
            &nbsp;
            &nbsp;
            &nbsp;
            &nbsp;

            <a class="prev" href="https://charlesreid1.github.io/index12.html">Older &rarr;</a>
        
          <br />
        </div>

    </div>
</div>

<div class="v50"></div>


        </div>

        <div class="col-md-4" style="text-align: center;">
<a name="a_archive"></a>


        <div class="well">

            <h2>September 2019</h2>

            <p class="archive">
            <a href="https://charlesreid1.github.io/mocking-aws-in-unit-tests.html">Mocking AWS in Unit Tests</a>
            </p>

        </div>

        <div class="v20"></div>


        <div class="well">

            <h2>May 2019</h2>

            <p class="archive">
            <a href="https://charlesreid1.github.io/deconvoluting-convolutional-neural-networks.html">Deconvoluting Convolutional Neural Networks</a>
            </p>
            <p class="archive">
            <a href="https://charlesreid1.github.io/graphs-for-bioinformatics-part-1-de-bruijn-graphs-hamiltonian-paths-and-eulerian-paths.html">Graphs for Bioinformatics, Part 1: de Bruijn Graphs, Hamiltonian Paths, and Eulerian Paths</a>
            </p>

        </div>

        <div class="v20"></div>


        <div class="well">

            <h2>April 2019</h2>

            <p class="archive">
            <a href="https://charlesreid1.github.io/the-git-commit-ectomy.html">The Git-Commit-Ectomy</a>
            </p>

        </div>

        <div class="v20"></div>


        <div class="well">

            <h2>March 2019</h2>

            <p class="archive">
            <a href="https://charlesreid1.github.io/the-josephus-problem-part-3-solving-the-double-step-case.html">The Josephus Problem: Part 3: Solving the Double Step Case</a>
            </p>
            <p class="archive">
            <a href="https://charlesreid1.github.io/the-josephus-problem-part-2-two-examples.html">The Josephus Problem: Part 2: Two Examples</a>
            </p>
            <p class="archive">
            <a href="https://charlesreid1.github.io/the-josephus-problem-part-1-the-problem.html">The Josephus Problem: Part 1: The Problem</a>
            </p>
            <p class="archive">
            <a href="https://charlesreid1.github.io/approximating-pi-happy-pi-day.html">Approximating Pi (Happy Pi Day)</a>
            </p>
            <p class="archive">
            <a href="https://charlesreid1.github.io/five-letter-words-part-5-the-try-trie-tree.html">Five Letter Words: Part 5: The Try Trie Tree</a>
            </p>
            <p class="archive">
            <a href="https://charlesreid1.github.io/five-letter-words-part-4-revisiting-diff-by-one.html">Five Letter Words: Part 4: Revisiting Diff by One</a>
            </p>
            <p class="archive">
            <a href="https://charlesreid1.github.io/centillion-a-document-search-engine.html">centillion: a document search engine</a>
            </p>

        </div>

        <div class="v20"></div>


        <div class="well">

            <h2>February 2019</h2>

            <p class="archive">
            <a href="https://charlesreid1.github.io/any-color-you-like-as-long-as-its-00add8.html">Any Color You Like, As Long As It's 00ADD8</a>
            </p>
            <p class="archive">
            <a href="https://charlesreid1.github.io/a-few-of-my-favorite-peps.html">A Few of My Favorite PEPs</a>
            </p>
            <p class="archive">
            <a href="https://charlesreid1.github.io/context-managers-in-python.html">Context Managers in Python</a>
            </p>

        </div>

        <div class="v20"></div>


        <div class="well">

            <h2>January 2019</h2>

            <p class="archive">
            <a href="https://charlesreid1.github.io/building-snakemake-command-line-wrappers-for-kubernetes-workflows.html">Building Snakemake Command Line Wrappers for Kubernetes Workflows</a>
            </p>
            <p class="archive">
            <a href="https://charlesreid1.github.io/building-snakemake-command-line-wrappers-for-workflows.html">Building Snakemake Command Line Wrappers for Workflows</a>
            </p>
            <p class="archive">
            <a href="https://charlesreid1.github.io/recursive-backtracking-in-go-for-bioinformatics-applications-3-go-implementation-of-backtracking.html">Recursive Backtracking in Go for Bioinformatics Applications: 3. Go Implementation of Backtracking</a>
            </p>

        </div>

        <div class="v20"></div>


        <div class="well">

            <h2>December 2018</h2>

            <p class="archive">
            <a href="https://charlesreid1.github.io/recursive-backtracking-in-go-for-bioinformatics-applications-2-generating-variations.html">Recursive Backtracking in Go for Bioinformatics Applications: 2. Generating Variations</a>
            </p>
            <p class="archive">
            <a href="https://charlesreid1.github.io/recursive-backtracking-in-go-for-bioinformatics-applications-1-counting-variations.html">Recursive Backtracking in Go for Bioinformatics Applications: 1. Counting Variations</a>
            </p>
            <p class="archive">
            <a href="https://charlesreid1.github.io/basic-data-structures-in-go-maps.html">Basic Data Structures in Go: Maps</a>
            </p>
            <p class="archive">
            <a href="https://charlesreid1.github.io/learning-bioinformatics-with-go-and-rosalind.html">Learning Bioinformatics with Go and Rosalind</a>
            </p>

        </div>

        <div class="v20"></div>


        <div class="well">

            <h2>October 2018</h2>

            <p class="archive">
            <a href="https://charlesreid1.github.io/first-post-of-the-fall-part-2-flaskadillo.html">First Post of the Fall, Part 2: Flaskadillo</a>
            </p>
            <p class="archive">
            <a href="https://charlesreid1.github.io/first-post-of-the-fall-part-1-data-commons.html">First Post of the Fall, Part 1: Data Commons</a>
            </p>

        </div>

        <div class="v20"></div>


        <div class="well">

            <h2>May 2018</h2>

            <p class="archive">
            <a href="https://charlesreid1.github.io/current-projects.html">Current Projects</a>
            </p>

        </div>

        <div class="v20"></div>


        <div class="well">

            <h2>March 2018</h2>

            <p class="archive">
            <a href="https://charlesreid1.github.io/charlesreid1com-stack.html">Charlesreid1.com Stack</a>
            </p>

        </div>

        <div class="v20"></div>


        <div class="well">

            <h2>February 2018</h2>

            <p class="archive">
            <a href="https://charlesreid1.github.io/d3-calendar-visualizations.html">D3 Calendar Visualizations</a>
            </p>
            <p class="archive">
            <a href="https://charlesreid1.github.io/project-euler-problem-172.html">Project Euler Problem 172</a>
            </p>

        </div>

        <div class="v20"></div>


        <div class="well">

            <h2>January 2018</h2>

            <p class="archive">
            <a href="https://charlesreid1.github.io/4x4-rubiks-cube-part-4-sequence-order.html">4x4 Rubik's Cube: Part 4: Sequence Order</a>
            </p>
            <p class="archive">
            <a href="https://charlesreid1.github.io/4x4-rubiks-cube-part-3-factoring-permutations.html">4x4 Rubik's Cube: Part 3: Factoring Permutations</a>
            </p>
            <p class="archive">
            <a href="https://charlesreid1.github.io/4x4-rubiks-cube-part-2-permutations.html">4x4 Rubik's Cube: Part 2: Permutations</a>
            </p>
            <p class="archive">
            <a href="https://charlesreid1.github.io/4x4-rubiks-cube-part-1-representations.html">4x4 Rubik's Cube: Part 1: Representations</a>
            </p>
            <p class="archive">
            <a href="https://charlesreid1.github.io/lets-generate-permutations.html">Let's Generate Permutations!</a>
            </p>

        </div>

        <div class="v20"></div>


        <div class="well">

            <h2>September 2017</h2>

            <p class="archive">
            <a href="https://charlesreid1.github.io/five-letter-words-part-3-letter-coverage-and-dynamic-programming.html">Five Letter Words: Part 3: Letter Coverage and Dynamic Programming</a>
            </p>
            <p class="archive">
            <a href="https://charlesreid1.github.io/five-letter-words-part-2-more-five-word-algorithms.html">Five Letter Words: Part 2: More Five-Word Algorithms</a>
            </p>
            <p class="archive">
            <a href="https://charlesreid1.github.io/five-letter-words-part-1-getting-familiar-with-the-list.html">Five Letter Words: Part 1: Getting Familiar With The List</a>
            </p>

        </div>

        <div class="v20"></div>


        <div class="well">

            <h2>August 2017</h2>

            <p class="archive">
            <a href="https://charlesreid1.github.io/eulers-theorem-the-totient-function-and-calculating-totients-by-hand.html">Euler's Theorem, the Totient Function, and Calculating Totients By Hand</a>
            </p>

        </div>

        <div class="v20"></div>


        <div class="well">

            <h2>July 2017</h2>

            <p class="archive">
            <a href="https://charlesreid1.github.io/mad-combinatoric-castles.html">Mad Combinatoric Castles</a>
            </p>
            <p class="archive">
            <a href="https://charlesreid1.github.io/project-euler-problem-1.html">Project Euler Problem 1</a>
            </p>
            <p class="archive">
            <a href="https://charlesreid1.github.io/shortest-lattice-paths-and-multiset-permutations.html">Shortest Lattice Paths and Multiset Permutations</a>
            </p>
            <p class="archive">
            <a href="https://charlesreid1.github.io/computing-square-roots-part-2-using-continued-fractions.html">Computing Square Roots: Part 2: Using Continued Fractions</a>
            </p>
            <p class="archive">
            <a href="https://charlesreid1.github.io/computing-square-roots-part-1-using-newtons-method.html">Computing Square Roots: Part 1: Using Newton's Method</a>
            </p>

        </div>

        <div class="v20"></div>


        <div class="well">

            <h2>June 2017</h2>

            <p class="archive">
            <a href="https://charlesreid1.github.io/cse-143-final-project-hilbert-sort-3-the-code.html">CSE 143 Final Project: Hilbert Sort: 3. The Code</a>
            </p>
            <p class="archive">
            <a href="https://charlesreid1.github.io/cse-143-final-project-hilbert-sort-2-the-solution-algorithm.html">CSE 143 Final Project: Hilbert Sort: 2. The Solution Algorithm</a>
            </p>
            <p class="archive">
            <a href="https://charlesreid1.github.io/cse-143-final-project-hilbert-sort-1-the-problem.html">CSE 143 Final Project: Hilbert Sort: 1. The Problem</a>
            </p>
            <p class="archive">
            <a href="https://charlesreid1.github.io/cse-143-final-project-classy.html">CSE 143 Final Project: Classy</a>
            </p>
            <p class="archive">
            <a href="https://charlesreid1.github.io/cse-143-final-project-checkers.html">CSE 143 Final Project: Checkers</a>
            </p>

        </div>

        <div class="v20"></div>


        <div class="well">

            <h2>May 2017</h2>

            <p class="archive">
            <a href="https://charlesreid1.github.io/teaching-recursion-with-the-n-queens-problem.html">Teaching Recursion with the N Queens Problem</a>
            </p>
            <p class="archive">
            <a href="https://charlesreid1.github.io/undergraduate-research-project-wireless-sensor-networks-for-internet-of-things-applications-part-2-the-technologies.html">Undergraduate Research Project: Wireless Sensor Networks for Internet of Things Applications (Part 2: The Technologies)</a>
            </p>
            <p class="archive">
            <a href="https://charlesreid1.github.io/undergraduate-research-project-wireless-sensor-networks-for-internet-of-things-applications-part-1-the-project.html">Undergraduate Research Project: Wireless Sensor Networks for Internet of Things Applications (Part 1: The Project)</a>
            </p>

        </div>

        <div class="v20"></div>


        <div class="well">

            <h2>April 2017</h2>

            <p class="archive">
            <a href="https://charlesreid1.github.io/stunnel.html">Stunnel</a>
            </p>
            <p class="archive">
            <a href="https://charlesreid1.github.io/traveling-schoolteacher-problem.html">Traveling Schoolteacher Problem</a>
            </p>
            <p class="archive">
            <a href="https://charlesreid1.github.io/the-z-machine-a-simple-turing-machine.html">The Z-Machine: A Simple Turing Machine</a>
            </p>
            <p class="archive">
            <a href="https://charlesreid1.github.io/awsome-day-seattle-notes-part-2-networking-security-and-miscellany.html">AWSome Day Seattle Notes: Part 2: Networking, Security, and Miscellany</a>
            </p>
            <p class="archive">
            <a href="https://charlesreid1.github.io/awsome-day-seattle-notes-part-1-the-basics.html">AWSome Day Seattle Notes: Part 1: The Basics</a>
            </p>
            <p class="archive">
            <a href="https://charlesreid1.github.io/setting-up-a-self-hosted-github-clone-with-gitea.html">Setting Up a Self-Hosted Github Clone with Gitea</a>
            </p>
            <p class="archive">
            <a href="https://charlesreid1.github.io/better-timing-of-guava-traveling-salesperson-problem-code-timing-scripts.html">Better Timing of Guava Traveling Salesperson Problem Code: Timing Scripts</a>
            </p>

        </div>

        <div class="v20"></div>


        <div class="well">

            <h2>March 2017</h2>

            <p class="archive">
            <a href="https://charlesreid1.github.io/fixing-bottlenecks-in-the-guava-traveling-salesperson-problem-code.html">Fixing Bottlenecks in the Guava Traveling Salesperson Problem Code</a>
            </p>
            <p class="archive">
            <a href="https://charlesreid1.github.io/python-vs-perl-n-queens-problem.html">Python vs. Perl: N Queens Problem</a>
            </p>
            <p class="archive">
            <a href="https://charlesreid1.github.io/solving-the-traveling-salesperson-problem-with-java-and-guava.html">Solving the Traveling Salesperson Problem with Java and Guava</a>
            </p>
            <p class="archive">
            <a href="https://charlesreid1.github.io/perl-vs-java-n-queens-problem.html">Perl vs. Java: N Queens Problem</a>
            </p>
            <p class="archive">
            <a href="https://charlesreid1.github.io/enigma-cipher-implementation-part-4-combinatorics.html">Enigma Cipher Implementation: Part 4: Combinatorics</a>
            </p>
            <p class="archive">
            <a href="https://charlesreid1.github.io/enigma-cipher-implementation-part-3-enigma-in-java-without-objects.html">Enigma Cipher Implementation: Part 3: Enigma in Java Without Objects</a>
            </p>
            <p class="archive">
            <a href="https://charlesreid1.github.io/enigma-cipher-implementation-part-2-pseudocode.html">Enigma Cipher Implementation: Part 2: Pseudocode</a>
            </p>
            <p class="archive">
            <a href="https://charlesreid1.github.io/enigma-cipher-implementation-part-1-how-it-works.html">Enigma Cipher Implementation: Part 1: How It Works</a>
            </p>

        </div>

        <div class="v20"></div>



<div class="v100"></div>
        </div>

    </div>



</div>



<script type="text/javascript" src="https://charlesreid1.github.io/theme/js/jquery-1.11.2.js"></script>
<script type="text/javascript" src="https://charlesreid1.github.io/theme/js/bootstrap-3.3.4.js"></script>
<script type="text/javascript" src="https://charlesreid1.github.io/theme/js/d3-3.5.5.js"></script><script type="text/javascript" src="https://charlesreid1.github.io/theme/js/jquery-1.11.2.js"></script>
<script type="text/javascript" src="https://charlesreid1.github.io/theme/js/bootstrap-3.3.4.js"></script>

<footer id="contentinfo" class="body">
<p>&nbsp;</p>
<p>&nbsp;</p>
<center>
	<hr />
</center>
<p>&nbsp;</p>
<p style="text-align: center">
    <span class="fa-stack fa-lg">
        <i class="fa fa-square fa-stack-2x" style="color:#000;"></i>
        <i class="fa fa-terminal fa-stack-1x fa-inverse"></i>
    </span>
    Made from the command line with vim by 
    <a href="http://charlesreid1.com">charlesreid1</a><br />
    with help from <a href="https://getbootstrap.com/">Bootstrap</a> and <a href="http://getpelican.com">Pelican</a>.
</p>

<br />

<p style="text-align: center">
    <a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/">
    <span class="fa-stack fa-lg">
        <i class="fa fa-square fa-stack-2x" style="color:#000;"></i>
        <i class="fa fa-creative-commons fa-stack-1x fa-inverse"></i>
    </span>
    </a>
    <br />
    Licensed under the <a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/">Creative Commons Attribution-NonCommercial 4.0 License</a>.
</p>

<!-- Start of StatCounter Code for Default Guide -->
<script type="text/javascript">
var sc_project=11611748;
var sc_invisible=1;
var sc_security="9fcba820";
</script>
<script type="text/javascript"
src="https://www.statcounter.com/counter/counter.js"
async></script>

<noscript><div class="statcounter"><a title="Web Analytics"
href="http://statcounter.com/" target="_blank"><img
class="statcounter"
src="//c.statcounter.com/11611748/0/9fcba820/1/" alt="Web
Analytics"></a></div></noscript>
<!-- End of StatCounter Code for Default Guide -->
</footer><!-- /#contentinfo -->
</body>
</html>