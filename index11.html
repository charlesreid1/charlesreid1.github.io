<!DOCTYPE html>
<html lang="en">
<head>
        <title>charlesreid1</title>
        <meta charset="utf-8" />

        <!--
        CSS styles
        -->
        <link href="https://charlesreid1.github.io/theme/css/bootstrap.css"       rel="stylesheet" type="text/css">
        <link href="https://charlesreid1.github.io/theme/css/slate.css"              rel="stylesheet" type="text/css">
        <link href="https://charlesreid1.github.io/theme/css/font-awesome.css"       rel="stylesheet" type="text/css"/>
        <link href="https://charlesreid1.github.io/theme/css/pygment-solarized.css"  rel="stylesheet" type="text/css"/>

        <!--
        my CSS styles
        -->
        <link href="https://charlesreid1.github.io/theme/css/main.css"            rel="stylesheet" type="text/css">
        <link href="https://charlesreid1.github.io/theme/css/dox.css"             rel="stylesheet" type="text/css">


        <!--
        include Angular first
        -->
        <script type="text/javascript" src="https://charlesreid1.github.io/theme/js/angular-1.3.15.js"></script>
        <script type="text/javascript" src="https://charlesreid1.github.io/theme/js/skrollr-0.6.29.js"></script>
        <script type="text/javascript" src="https://charlesreid1.github.io/theme/js/d3-3.5.5.js"></script>

        <!--
        this seems like a bad idea.
        but if I don't put jquery first, I get errors about unrecognized $s.
        -->
        <script type="text/javascript" src="https://charlesreid1.github.io/theme/js/jquery-1.11.2.js"></script>

</head>
<body id="index">
<nav class="navbar navbar-default">
    <div class="container-fluid">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#myNavbar">
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span> 
            </button>
            <a href="https://charlesreid1.github.io" class="navbar-brand">charlesreid1.github.io</a>
        </div>
        <div>
            <div class="collapse navbar-collapse" id="myNavbar">
                <ul class="nav navbar-nav">

                    <li>
                        <a href="https://charlesreid1.com/wiki">Wiki</a>
                    </li>
                    <li>
                        <a href="https://git.charlesreid1.com/explore">Git</a>
                    </li>
                    <li>
                        <a href="http://spotify.charlesreid1.com">Music</a>
                    </li>
                    <li>
                        <a href="https://charlesreid1.com/life">Life</a>
                    </li>
                    <li>
                        <a href="https://charlesreid1.github.io">Blog</a>
                    </li>
                    <li>
                        <a href="https://charlesreid1.com/about">About Me</a>
                    </li>

                </ul>
            </div>
        </div>
    </div>
</nav>



<div class="container">

    <div class="row">
        <div class="col-md-12 col-centered" style="text-align: center;">
            <div class="v50"></div>
            <div class="cosmojumbo">
                <h1 class="jumbojumbo">charlesreid1.com blog<h1>
            </div>
        </div>
    </div>


    <div class="v50"></div>


    <div class="row">

        <div class="col-md-8" style="text-align: center;">

  	            	<article>
<header>
<div class="row">


    <div class="col-md-12">
        <div class="headtext" style="text-align: center;">
            <h1><b>
                4x4 Rubik's Cube: Part 3: Factoring Permutations
            </b></h1>
        
            <p class="lead">
                Posted 
                <time datetime="2018-01-20T12:00:00-08:00" pubdate>Saturday 01/20/2018</time>
                in 
                <a href="https://charlesreid1.github.io/category/rubiks-cube.html">Rubiks Cube</a>
                </p>
            <p>
            <span style="font-size: 14px">
                <a href="https://charlesreid1.github.io/4x4-rubiks-cube-part-3-factoring-permutations.html">permalink</a>
            </span>
            </p>
        </div>

    </div>

</div>
</header>


<div class="v50"></div>


<div class="row">
    <div class="col-md-12" style="text-align: left;">

        <div class="entry-content"><p><em>This is Part 3 of a 4-part blog post 
on the mathematics of the 4x4 Rubik's Cube, 
its relation to algorithms, and some 
curious properties of Rubik's Cubes.</em></p>
<p>See Part 1 of this blog post here: <a href="https://charlesreid1.github.io/4x4-rubiks-cube-part-1-representations.html">Part 1: Representations</a></p>
<p>See Part 2 of this blog post here: <a href="https://charlesreid1.github.io/4x4-rubiks-cube-part-2-permutations.html">Part 2: Permutations</a></p>
<p>You are currently reading Part 3 of this blog post: <strong>Part 3: Factoring Permutations</strong></p>
<p>See Part 4 of this blog post here: <a href="#">Part 4: Sequence Order</a></p>
<h1>Table of Contents</h1>
<ul>
<li>
<p><a href="#rubiks3-rubiks3-intro">Introduction: Cycles, Sequences, and Order</a></p>
<ul>
<li><a href="#rubiks3-rubiks3-intro-cycles">Cycles</a></li>
<li><a href="#rubiks3-rubiks3-intro-sequences">Sequences</a></li>
<li><a href="#rubiks3-rubiks3-intro-order">Order</a></li>
</ul>
</li>
<li>
<p><a href="#rubiks3-rubiks3-intercalation">Intercalation Product</a></p>
<ul>
<li><a href="#rubiks3-intercalation-definition">Definition</a></li>
<li><a href="#rubiks3-intercalation-properties">Properties</a></li>
</ul>
</li>
<li>
<p><a href="#rubiks3-factoring">Factoring Permutations Using Knuth's Theorem A</a></p>
<ul>
<li><a href="#rubiks3-factoring-significance">Significance of Factors</a></li>
<li><a href="#rubuiks3-factoring-how">How to Factor Permutations</a></li>
<li><a href="#rubuiks3-factoring-how-contd">How to Factor Permutations (Cont'd)</a></li>
<li><a href="#rubiks3-factoring-algorithmA">Algorithm A</a></li>
<li><a href="#rubiks3-factoring-pseudocode">Pseudocode</a></li>
<li><a href="#rubiks3-factoring-python">Python Code</a></li>
</ul>
</li>
<li>
<p><a href="#rubiks3-preview">Preview of Part 4</a></p>
</li>
<li>
<p><a href="#rubiks3-references">References</a></p>
</li>
</ul>
<p><br />
<br />
<br /></p>
<p><a name="rubiks3-intro"></a></p>
<h1>Introduction</h1>
<p>So far we have been discussing representations of the Rubik's Cube,
with the ultimate intention of investigating some of its properties.</p>
<p>In this post, we define and explore the properties we are interested
in studying.</p>
<p><a name="rubiks3-intro-cycles"></a></p>
<h2>Cycles</h2>
<p>(Definition of cycle)</p>
<p>We use the two-line notation introduced in the last blog post,
so a permutation of a 5-tuple might look like this:</p>
<div class="math">$$
a = \bigl(\begin{smallmatrix}
  a &amp; b &amp; c &amp; d &amp; e \\
  b &amp; a &amp; e &amp; c &amp; d 
\end{smallmatrix}\bigr)
$$</div>
<p>In this permutation, we see that <span class="math">\(a\)</span> and <span class="math">\(b\)</span> swap places,
and <span class="math">\(c\)</span>, <span class="math">\(d\)</span>, and <span class="math">\(e\)</span> exchange places as well. These two
groups form two cycles. </p>
<p>Think of the cycles as the particular way that pieces 
of the permutation are exchanged with one another.</p>
<p><a name="rubiks3-intro-sequences"></a></p>
<h2>Sequences</h2>
<p>We are interested in studying the properties of the cube,
but in particular we are interested in the properties of 
move sequences applied to the cube.</p>
<p>There are 36 possible moves on a cube, and a series of 
moves applied in a particular order defines a sequence.
The 36 possible rotations were given in the prior blog post
and cover clockwise and counterclockwise rotations of 
each of the six faces - either the first layer, the second layer,
or both of the first two layers.</p>
<p>These moves are denoted with six letters (UDLRFB) for the upper,
downward, left, right, front, and back face of the cube, respectively.</p>
<p>Moves indicated should be clockwise unless they contain an apostrophe
character <code>'</code>, which indicates counterclockwise rotation.</p>
<p>A capital letter indicates a rotation of the first layer only 
(e.g., <code>U</code> indicates a clockwise rotation of the first layer of 
the upper face).</p>
<p>A lowercase letter indicates a roration of the first and second layers
(e.g., <code>r</code> indicates a clockwise rotation of the top two layers of
the right face).</p>
<p>A 2 before the letter indicates that the second layer should be rotated
(e.g., <code>2F</code> indicates a clockwise rotation of the second layer of the 
front face).</p>
<p>Each move sequence can be translated into a tuple representation
(see Part 1 blog post). Once we have the tuple representation of a 
permutation, we can do several things, beginning with finding
the cycles that compose the moves of the sequence.</p>
<p><a name="rubiks3-intro-order"></a></p>
<h2>Order</h2>
<p>The quantity we are truly interested in is the order of a given cycle.</p>
<p>The order of a sequence of moves is the number of times that sequence
must be applied to the cube to get the cube to return back to its 
original state. A more convenient way to think about it is, if you 
applied a move sequence to a solved cube, how many times would you 
have to apply it until you reached a solved cube again?</p>
<p>We begin with the move sequence, which applies a particular permutation
to the cube, exchanging particular pieces in a particular order.
We want to obtain a tuple representation of the permutation
that results from a particular sequence of moves.</p>
<p>Once we have the tuple representation of a sequence's permutation, we can 
factor it into independent cycles using the techniques covered in 
this blog post. </p>
<p>The factoring a permutation into cycles will yield the order; 
the order is the least common multiple of the lengths of eacch
cycle that is a factor.</p>
<p>Using this, we can investigate the properties of the order 
of different move sequences.</p>
<p><a name="rubiks3-intercalation"></a></p>
<h1>Intercalation Product</h1>
<p>In Part 2 of this blog post, we discussed the tuple representation
of a permutation; for example, one permutation <span class="math">\(\pi\)</span> of an
<span class="math">\(n\)</span>-tuple might be written:</p>
<div class="math">$$
\pi = \bigl(\begin{smallmatrix}
  1 &amp; 2 &amp; 3 &amp; \cdots &amp; n-1 &amp; n \\
  2 &amp; 3 &amp; 4 &amp; \cdots &amp;  n  &amp; 1
\end{smallmatrix}\bigr)
$$</div>
<p>The top row consists of the elements in the tuple in 
sorted order; the second row consists of elements of the 
tuple corresponding to that permutation.</p>
<p>In the discussion that follows we'll keep it general,
and talk about multisets - the case in which the top row
has multiple occurrences of different items.</p>
<p>For the following discussion, we will suppose two permutations
<span class="math">\(\alpha\)</span> and <span class="math">\(\beta\)</span> composed of four objects <span class="math">\(\{a, b, c, d,\}\)</span>, 
each occurring multiple times:</p>
<div class="math">$$
\alpha = \bigl(\begin{smallmatrix}
  a &amp; a &amp; b &amp; c &amp; d \\
  c &amp; a &amp; d &amp; a &amp; b
\end{smallmatrix}\bigr)
$$</div>
<div class="math">$$
\beta = \bigl(\begin{smallmatrix}
  a &amp; b &amp; d &amp; d &amp; d \\
  b &amp; d &amp; d &amp; a &amp; d
\end{smallmatrix}\bigr)
$$</div>
<p><a name="rubiks3-intercalation-definition"></a></p>
<h2>Definition</h2>
<p>Now we define the intercalation product <span class="math">\(\alpha \top \beta\)</span> 
of these permutations as the elements of each permutation
organized in an interleaved way - 
each element of <span class="math">\(\alpha\)</span> and <span class="math">\(\beta\)</span> are grouped
by the letter that appears on the top row,
and within those groups they are ordered 
as they appear in <span class="math">\(\alpha\)</span>, then as they appear
in <span class="math">\(\beta\)</span>.</p>
<p>For our example, the intercalation product is the following
combination of <span class="math">\(\alpha\)</span> and <span class="math">\(\beta\)</span>:</p>
<div class="math">$$
\alpha \top \beta = \bigl(\begin{smallmatrix}
  a &amp; a &amp; b &amp; c &amp; d \\
  c &amp; a &amp; d &amp; a &amp; b 
\end{smallmatrix}\bigr) \top \bigl(\begin{smallmatrix}
  a &amp; b &amp; d &amp; d &amp; d \\
  b &amp; d &amp; d &amp; a &amp; d 
\end{smallmatrix}\bigr) = 
\bigl(\begin{smallmatrix}
  a &amp; a &amp; a &amp; b &amp; b &amp; c &amp; d &amp; d &amp; d &amp; d \\
  c &amp; a &amp; b &amp; d &amp; d &amp; a &amp; b &amp; d &amp; a &amp; d
\end{smallmatrix}\bigr)
$$</div>
<p>This is basically an interleaving operation. 
All top-bottom pairs with <span class="math">\(a\)</span> at the top are 
grouped together - and within the group,
everyone from <span class="math">\(\alpha\)</span> comes first, everyone
from <span class="math">\(\beta\)</span> comes second.</p>
<p>The first two <span class="math">\(a\)</span> items in <span class="math">\(\alpha \top \beta\)</span> 
come from <span class="math">\(\alpha\)</span>, the third <span class="math">\(a\)</span> item comes from <span class="math">\(\beta\)</span>.</p>
<h3>Side Note: Why Define an Intercalation Product?</h3>
<p>You may be wondering what the intercalation product has to do 
with Rubik's Cubes or finding the order of a sequence. It turns
out that the intercalation product will allow us to establish
a system of permutation algebra, define certain operations
and properties of permutations, and use these to factor
permutations into independent groups of faces being 
exchanged.</p>
<p><a name="rubiks3-intercalation-properties"></a></p>
<h2>Properties</h2>
<p>We can state some properties of the intercalation algebra already:</p>
<p>If <span class="math">\(\alpha \top \pi = \beta \top \pi\)</span> 
or <span class="math">\(\pi \top \alpha = \pi \top \beta\)</span>, 
this implies <span class="math">\(\alpha = \beta\)</span>.</p>
<p>An identity element exists such that 
<span class="math">\(\epsilon \top \alpha = \alpha \top \epsilon = \alpha\)</span>.</p>
<p>The commutative property for the intercalation product 
(whether <span class="math">\(\alpha\)</span> and <span class="math">\(\beta\)</span> can be exchanged in expressions)
only holds if <span class="math">\(\alpha\)</span> and <span class="math">\(\beta\)</span> are independent of each 
other (if they permute different elements).
If this condition holds, then 
<span class="math">\(\alpha \top \beta = \beta \top \alpha\)</span>.</p>
<p>This property does <em>not</em> hold in general.</p>
<p>(An example of permutations that would be independent 
on the Rubik's Cube would be the moves U and D.
These each rotate a different group of faces.)</p>
<p><a name="rubiks3-factoring"></a></p>
<h1>Factoring Permutations Using Knuth's Theorem A</h1>
<p>Volume 3 of Donald Knuth's <u>The Art of Computer Programming</u>
gives the following theorem on page 26, which gives a very useful
property of intercalation products:</p>
<p><strong>Theorem A.</strong> Let the elements of the multiset <span class="math">\(M\)</span> be linearly
ordered by the relation "&lt;". Every permutation <span class="math">\(\pi\)</span> of <span class="math">\(M\)</span> 
has a unique representation as the intercalation </p>
<div class="math">$$
\pi = 
( x_{1,1} \dots x_{1,n_1} y_1 ) \top 
( x_{2,1} \dots x_{2,n_2} y_2 ) \top 
\dots \top
( x_{t,1} \dots x_{t,n_t} y_t ) 
$$</div>
<p>where </p>
<div class="math">$$
y_1 \leq y_2 \leq \dots \leq y_t
$$</div>
<p>and </p>
<div class="math">$$
y_i &lt; x_{ij} \qquad \mbox{ for } 1 \leq j \leq n_i, 1 \leq i \leq t
$$</div>
<p><a name="rubiks3-factoring-significance"></a></p>
<h2>Significance of Factors</h2>
<p>Theorem A is central to our goal of studying move sequences 
(and computing their order). To understand why, consider the 
factors that result from Theorem A, and what they mean in the 
specific example of a Rubik's Cube.</p>
<p>In a regular n-tuple, the factors represent groups of items 
in the tuple that are being exchanged. A tuple that factors
into the intercalation of many very small tuples means the 
permutation mostly consists of swapping pairs or triplets 
of things. A tuple that factors into the intercalation
of two large tuples means, all of the things are divided 
into two groups, and within that group, everybody is mixed
in with everybody else. </p>
<p>On a Rubik's Cube, the tuple consists of faces being moved,
so a permutation's factors indicate how many faces are being 
swapped. The size of each group of faces gives some indication
as to how long it takes for the cube to "sync up" with its 
original state if the permutation is repeatedly applied; 
a permutation with fewer large factors will take longer than a 
permutation with many small factors.</p>
<p>For example, suppose a move sequence permutes three corner pieces
on a cube each time it is applied. Then if we write the two-line 
tuple corresponding to that permutation, and we factor it into the 
intercalation product of several tuples, several factors of the
permutation will have a length of three, and will contain the 
set of three faces being exchanged.</p>
<p>On the other hand, if a move sequence permutes six corner pieces
on a cube each time it is applied, some of the factors will be
groups of six faces being exchanged when the sequence is applied.</p>
<p>Thus, <em>the (sizes of the) factors of a permutation determine 
the order of the permutation.</em></p>
<p><a name="rubiks3-factoring-how"></a></p>
<h2>How to Factor Permutations</h2>
<p>To factor a permutation, we perform the opposite of the intercalation
product. Now supppose we wish to factor the permutation:</p>
<div class="math">$$
\pi = \bigl(\begin{smallmatrix}
    a &amp; a &amp; b &amp; b &amp; b &amp; b &amp; b &amp; c &amp; c &amp; c &amp; d &amp; d &amp; d &amp; d &amp; d \\
    d &amp; b &amp; c &amp; b &amp; c &amp; a &amp; c &amp; d &amp; a &amp; d &amp; d &amp; b &amp; b &amp; b &amp; d
\end{smallmatrix}\bigr)
$$</div>
<p>into the intercalation of multiple independent, disjoint cycles,</p>
<div class="math">$$
\pi = \alpha \top \beta \top \dots \top \gamma
$$</div>
<p>We can extract each factor one at a time using the following algorithm.</p>
<p>Start by assuming the first factor <span class="math">\(\alpha\)</span> contains the first symbol <span class="math">\(a\)</span>
in its top row.</p>
<p>(It turns out this assumption <em>can't</em> be false - if there is an <span class="math">\(a\)</span> 
in the top row of <span class="math">\(\pi\)</span> then there is an <span class="math">\(a\)</span> in the top row of at least 
one factor. We're simply going to pull out those factors with this assumption.)</p>
<p>Given this assumption, we know <span class="math">\(\alpha\)</span> must map <span class="math">\(a\)</span> to the same letter
as the final permutation maps <span class="math">\(a\)</span> to, in the very first column of <span class="math">\(\pi\)</span>.
The first column of <span class="math">\(\pi\)</span> is <span class="math">\(( a d )\)</span> (a on top, d on bottom). 
That means that if our assumption holds, if <span class="math">\(\alpha\)</span> contains <span class="math">\(a\)</span>, then 
it must permute all <span class="math">\(a\)</span>'s into <span class="math">\(d\)</span>'s and thus <span class="math">\(\alpha\)</span> should contain the 
same column <span class="math">\((a d )\)</span>.</p>
<p>Now suppose that <span class="math">\(\alpha\)</span> contains <span class="math">\(d\)</span>, which it must if our prior step
is true. (<span class="math">\(\alpha\)</span> cannot turn <span class="math">\(a\)</span> into <span class="math">\(d\)</span> if it does not have a <span class="math">\(d\)</span>!).
We find the leftmost <span class="math">\(d\)</span> on the top line, and see that it maps to the 
symbol <span class="math">\(d\)</span>, due to the column <span class="math">\(( d d )\)</span> (d on top, d on bottom). 
Thus, <span class="math">\(\alpha\)</span> should also contain the column  <span class="math">\(( d d )\)</span>.</p>
<p>We keep going. Suppose that <span class="math">\(\alpha\)</span> contains another <span class="math">\(d\)</span>, as a consequence
of the prior step. Since we already used the first d column in <span class="math">\(\pi\)</span>, we use
the next column, <span class="math">\(( d b )\)</span> Thus, <span class="math">\(\alpha\)</span> should also contain the column <span class="math">\(( d b )\)</span>,
and we use the outcome <span class="math">\(b\)</span> as the starting point for the next step.</p>
<p>The process stops as soon as the starting point for the next step
is the letter we began with, <span class="math">\(a\)</span>. That's because, at that point,
we've formed a "closed loop" of pieces that permute with one 
another. That closed loop forms the first intercalation factor 
of the permutation <span class="math">\(\pi\)</span>.</p>
<p>If we keep repeating the process described, we eventually wind up 
with <span class="math">\(\alpha\)</span>:</p>
<div class="math">$$
\alpha = \bigl(\begin{smallmatrix}
    a &amp; d &amp; d &amp; b &amp; c &amp; d &amp; b &amp; b &amp; c \\
    d &amp; d &amp; b &amp; c &amp; d &amp; b &amp; b &amp; c &amp; a
\end{smallmatrix}\bigr)
$$</div>
<h3>Side Note: Why Does This Work?</h3>
<p>Let's pause for a moment and see what's happening. 
What we're doing is following a thread between the 
top and bottom rows of the permutation; this thread 
tells us how elements are being moved around to
create permutations.</p>
<p>(A simpler but easier way to see this is by comparing 
two permutations of <span class="math">\((1 2 3 4 5 6)\)</span>: consider the permutation 
<span class="math">\((2 1 3 4 6 5)\)</span>, versus the permutation <span class="math">\((2 4 5 6 1 3)\)</span>. 
The first permutation swaps positions 0 and 1, and 
positions 4 and 5, independently; the second permutation 
mixes <em>all</em> positions together.)</p>
<p>We are assembling <span class="math">\(\alpha\)</span> piece by piece, by pulling out 
pairs from the top and bottom row of <span class="math">\(\pi\)</span> and putting them 
into <span class="math">\(\alpha\)</span>. At some point we will come back to the starting
point, the symbol <span class="math">\(a\)</span>, and we will be finished finding the 
first factor <span class="math">\(\alpha\)</span>, which is a disjoint cycle. </p>
<p>By starting from the top row and following where it leads 
in the bottom row, and continuing until we return to the 
original starting element in the top row, we can carve up 
the permutation into groups of pieces exchanged with one 
another and not with any other pieces, or groups of pieces 
that don't move.</p>
<p><a name="rubiks3-factoring-how-contd"></a></p>
<h2>How to Factor Permutations (Cont'd)</h2>
<p>Recall that our goal was to factor the permutation <span class="math">\(\pi\)</span> into the 
intercalation of multiple independent and disjoint cycles,
<span class="math">\(\pi = \alpha \top \beta \top \dots \top \gamma\)</span>.
We gave a procedure to extract factors and used it to
extract the first factor, <span class="math">\(\alpha\)</span>. </p>
<p>However, this is not the end of the factoring process: there are 
still several elements of <span class="math">\(\pi\)</span> that have not been used to form 
<span class="math">\(\alpha\)</span>, and those remaining elements themselves form a permutation 
that can be factored.</p>
<p>We begin with the original permutation <span class="math">\(\pi\)</span>:</p>
<div class="math">$$
\pi = \bigl( \begin{smallmatrix}
    a &amp; a &amp; b &amp; b &amp; b &amp; b &amp; b &amp; c &amp; c &amp; c &amp; d &amp; d &amp; d &amp; d &amp; d \\
    d &amp; b &amp; c &amp; b &amp; c &amp; a &amp; c &amp; d &amp; a &amp; d &amp; d &amp; b &amp; b &amp; b &amp; d
\end{smallmatrix}\bigr)
$$</div>
<p>When we pull out the first factor <span class="math">\(\alpha\)</span>, we get:</p>
<div class="math">$$
\pi = \bigl( \begin{smallmatrix}
    a &amp; d &amp; d &amp; b &amp; c &amp; d &amp; b &amp; b &amp; c \\
    d &amp; d &amp; b &amp; c &amp; d &amp; b &amp; b &amp; c &amp; a
\end{smallmatrix} \bigr)
\top
\bigl( \begin{smallmatrix}
    a &amp; b &amp; b &amp; c &amp; d &amp; d \\
    b &amp; a &amp; c &amp; d &amp; b &amp; d
\end{smallmatrix} \bigr)
$$</div>
<p>When we pull out the second factor <span class="math">\(\beta\)</span>, we get: </p>
<div class="math">$$
\pi = \bigl( \begin{smallmatrix}
    a &amp; d &amp; d &amp; b &amp; c &amp; d &amp; b &amp; b &amp; c \\
    d &amp; d &amp; b &amp; c &amp; d &amp; b &amp; b &amp; c &amp; a
\end{smallmatrix} \bigr)
\top
\bigl( \begin{smallmatrix}
    a &amp; b \\
    b &amp; a 
\end{smallmatrix} \bigr)
\top 
\bigl( \begin{smallmatrix}
    b &amp; c &amp; d &amp; d \\
    c &amp; d &amp; b &amp; d
\end{smallmatrix} \bigr)
$$</div>
<p>The third factor can be pulled out as well, which leaves the last factor, 
a single column <span class="math">\(( d d )\)</span> by itself, indicating an element that is 
not moved by the permutation.</p>
<div class="math">$$
\pi = \bigl( \begin{smallmatrix}
    a &amp; d &amp; d &amp; b &amp; c &amp; d &amp; b &amp; b &amp; c \\
    d &amp; d &amp; b &amp; c &amp; d &amp; b &amp; b &amp; c &amp; a
\end{smallmatrix} \bigr)
\top
\bigl( \begin{smallmatrix}
    a &amp; b \\
    b &amp; a 
\end{smallmatrix} \bigr)
\top 
\bigl( \begin{smallmatrix}
    b &amp; c &amp; d  \\
    c &amp; d &amp; b
\end{smallmatrix} \bigr)
\top 
\bigl( \begin{smallmatrix}
    d \\
    d
\end{smallmatrix} \bigr)
$$</div>
<p>Thus the permutation <span class="math">\(\pi\)</span> can be expressed as the intercalation 
of four independent cycles.</p>
<p>This procedure illustrates Knuth's Theorem A.</p>
<p>(Note: had we initially assumed <span class="math">\(\alpha\)</span> contained <span class="math">\(b\)</span> instead of <span class="math">\(a\)</span>, 
we would end up starting by pulling out a different factor, but we 
would ultimately end up with the same set of four factors.)</p>
<p>To relate this back to the Rubik's Cube, we can start with a sequence 
of interest, like <code>U R D D B</code>, and write the tuple representing the 
outcome of this sequence when it is applied to the cube. In this way 
we represent a move sequence as a tuple or as a permutation.</p>
<p>Next, we factor this permutation the way we factored <span class="math">\(\pi\)</span>, 
into the intercalation product of independent cycles. 
These are groups of pieces being swapped each time the 
cycle is applied.</p>
<p>Now if one factor is of length 4 (group of 4 faces being permuted),
one factor is of length 3, and one factor is of length 20,
then the number of times the sequence must be applied 
before the cube will come back to its original, solved state
is <span class="math">\(LCM(3,4,20) = 60\)</span>.</p>
<p><a name="rubiks3-factoring-algorithmA"></a></p>
<h2>Algorithm A</h2>
<p>Algorithm A is an algorithm written to perform the factoring process
described above.</p>
<p>We started with the two-row representation above,
so our function will start with the top and bottom rows
of the two-row representation.</p>
<p>The procedure started with the first entry of the 
top row, and got the corresponding entry of the bottom
row. It then moved to the index of that item on the top row,
and got the coresponding entry of the bottom row, 
and so on, assembling the components of the permutation
by stepping through each.</p>
<p>In code, this will require us to switch between
items in a list, and the indices of occurrencs of 
items in the list. Fortunately, this is an easy 
and common operation.</p>
<p>Following is the pseudocode, then the Python code,
to implement Algorithm A on the two-row representation
of a tuple.</p>
<p><a name="rubiks3-factoring-pseudocode"></a></p>
<h2>Pseudocode</h2>
<p>Our function takes two arguments: the top and bottom rows
of the two-row representation of this permutation.</p>
<div class="highlight"><pre><span></span>define function factor_permutations( top row, bottom row )

    create bit vector to mark columns as factored or not

    initialize list of factors

    initialize pointer to active location

    initialize starting index

    while there are still zeros in the bit vector:

        initialize this factor

        run until break reached:

            set bit vector at active location to 1

            get active location entries on top row (leader) and bottom row (follower)

            get next active location (index of follower in top row)

            break if next active location out of bounds

            break if next active location is starting element

            append follower to this factor

        add starting element to end of factor

        add factor to list of factors

        set next start index to index of first 0 in bit vector

    return factors
</pre></div>


<p><a name="rubiks3-factoring-python"></a></p>
<h2>Python Code</h2>
<p>(Code for Algorithm A)</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">factor_permutation</span><span class="p">(</span><span class="n">perm_top</span><span class="p">,</span><span class="n">perm_bot</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Factor a permutation into its lowest terms</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">MAX</span> <span class="o">=</span> <span class="mi">96</span>
    <span class="c1"># Need a way to also mark them as used... bit vector</span>
    <span class="n">used_vector</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">perm_top</span><span class="p">)</span>

    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">perm_top</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">used_vector</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="n">factors</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># If we still have values to pick out:</span>
    <span class="k">while</span><span class="p">(</span><span class="mi">0</span> <span class="ow">in</span> <span class="n">used_vector</span><span class="p">):</span>

        <span class="n">factor</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">while</span><span class="p">(</span><span class="bp">True</span><span class="p">):</span>
            <span class="n">used_vector</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">leader</span> <span class="o">=</span> <span class="n">perm_top</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">follower</span> <span class="o">=</span> <span class="n">perm_bot</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

            <span class="n">i</span> <span class="o">=</span> <span class="n">perm_top</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">follower</span><span class="p">)</span>
            <span class="k">while</span><span class="p">(</span><span class="n">used_vector</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">==</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="o">&gt;=</span><span class="n">MAX</span><span class="p">):</span>
                    <span class="k">break</span>

            <span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="o">&gt;=</span><span class="n">MAX</span><span class="p">):</span>
                <span class="k">break</span>
            <span class="k">elif</span><span class="p">(</span><span class="n">follower</span><span class="o">==</span><span class="n">start</span><span class="p">):</span>
                <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">factor</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">follower</span><span class="p">)</span>

        <span class="c1"># add start to end</span>
        <span class="n">factor</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>

        <span class="n">factors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">factor</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">used_vector</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">perm_top</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">break</span>

    <span class="n">factorsize</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="n">check</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">factor</span> <span class="ow">in</span> <span class="n">factors</span><span class="p">:</span>
        <span class="n">factorsize</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">factor</span><span class="p">))</span>
        <span class="n">check</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">factor</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">factors</span>
</pre></div>


<p><a name="rubiks3-preview"></a></p>
<h1>Preview of Part 4</h1>
<p>We concluded with an algorithm that will be central to our task
of computing the order of a Rubik's Cube move sequence.</p>
<p>In the next post, we'll apply our method of representing Rubik's Cubes
using the two-line tuple notation, and use the factoring algorithm above,
which will allow us to factor Rubik's Cube permutations into their 
corresponding intercalation products. </p>
<p>From there, we can count the size of each intercalation product,
and the least common multiple of the sizes gives the order of the 
permutation.</p>
<p><a name="rubiks3-references"></a></p>
<h1>References</h1>
<ol>
<li>
<p>"Rubik's Cube". Charlesreid1.com wiki, Charles Reid. Edited 20 January 2017. Accessed 20 January 2017.
&lt;<a href="https://charlesreid1.com/wiki/Rubiks_Cube">https://charlesreid1.com/wiki/Rubiks_Cube</a>&gt;</p>
</li>
<li>
<p>"Rubik's Revenge". Charlesreid1.com wiki, Charles Reid. Edited 20 January 2017. Accessed 20 January 2017.
&lt;<a href="https://charlesreid1.com/wiki/Rubiks_Revenge">https://charlesreid1.com/wiki/Rubiks_Revenge</a>&gt;</p>
</li>
<li>
<p>"Rubik's Cube/Tuple". Charlesreid1.com wiki, Charles Reid. Edited 20 January 2017. Accessed 20 January 2017.
&lt;<a href="https://charlesreid1.com/wiki/Rubiks_Cube/Tuple">https://charlesreid1.com/wiki/Rubiks_Cube/Tuple</a>&gt;</p>
</li>
<li>
<p>"Rubik's Cube/Permutations". Charlesreid1.com wiki, Charles Reid. Edited 20 January 2017. Accessed 20 January 2017.
&lt;<a href="https://charlesreid1.com/wiki/Rubiks_Cube/Permutations">https://charlesreid1.com/wiki/Rubiks_Cube/Permutations</a>&gt;</p>
</li>
<li>
<p>"Github - dwalton76/rubiks-cube-NxNxN-solver". dwalton76, Github Repository, Github Inc. Accessed 11 January 2017.
&lt;<a href="https://github.com/dwalton76/rubiks-cube-NxNxN-solver">https://github.com/dwalton76/rubiks-cube-NxNxN-solver</a>&gt;</p>
</li>
<li>
<p>"Rubik's Cube NxNxN Solver". Git repository, git.charlesreid1.com. Charles Reid. Updated 20 January 2017.
&lt;<a href="https://git.charlesreid1.com/charlesreid1/rubiks-cube-nnn-solver">https://git.charlesreid1.com/charlesreid1/rubiks-cube-nnn-solver</a>&gt;</p>
</li>
<li>
<p>"Rubiks Cube Cycles". Git repository, git.charlesreid1.com. Charles Reid. Updated 20 January 2017.
&lt;<a href="https://git.charlesreid1.com/charlesreid1/rubiks-cube-cycles">https://git.charlesreid1.com/charlesreid1/rubiks-cube-cycles</a>&gt;</p>
</li>
</ol>
<script type="text/javascript">if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width < 768) ? "left" : align;
        indent = (screen.width < 768) ? "0em" : indent;
        linebreak = (screen.width < 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
</script></div>

    </div>
</div>

<div class="v20"></div>

<div class="row">
    <div class="col-md-12" style="text-align: left;">

        <div class="tags">
            <p>Tags:&nbsp;&nbsp;&nbsp;
                    <a href="https://charlesreid1.github.io/tag/rubiks-cube.html">rubiks cube</a>
                    &nbsp;&nbsp;
                    <a href="https://charlesreid1.github.io/tag/combinatorics.html">combinatorics</a>
                    &nbsp;&nbsp;
                    <a href="https://charlesreid1.github.io/tag/permutations.html">permutations</a>
                    &nbsp;&nbsp;
                    <a href="https://charlesreid1.github.io/tag/python.html">python</a>
                    &nbsp;&nbsp;
                    <a href="https://charlesreid1.github.io/tag/puzzles.html">puzzles</a>
                    &nbsp;&nbsp;
                    <a href="https://charlesreid1.github.io/tag/art-of-computer-programming.html">art of computer programming</a>
                    &nbsp;&nbsp;
                    <a href="https://charlesreid1.github.io/tag/knuth.html">knuth</a>
                    &nbsp;&nbsp;
        </div>

    </div>
</div>


<div class="v200"></div>
  	            	</article>
  	            	<article>
<header>
<div class="row">


    <div class="col-md-12">
        <div class="headtext" style="text-align: center;">
            <h1><b>
                4x4 Rubik's Cube: Part 2: Permutations
            </b></h1>
        
            <p class="lead">
                Posted 
                <time datetime="2018-01-14T20:00:00-08:00" pubdate>Sunday 01/14/2018</time>
                in 
                <a href="https://charlesreid1.github.io/category/rubiks-cube.html">Rubiks Cube</a>
                </p>
            <p>
            <span style="font-size: 14px">
                <a href="https://charlesreid1.github.io/4x4-rubiks-cube-part-2-permutations.html">permalink</a>
            </span>
            </p>
        </div>

    </div>

</div>
</header>


<div class="v50"></div>


<div class="row">
    <div class="col-md-12" style="text-align: left;">

        <div class="entry-content"><p><em>This is Part 2 of a 4-part blog post 
on the mathematics of the 4x4 Rubik's Cube, 
its relation to algorithms, and some 
curious properties of Rubik's Cubes.</em></p>
<p>See Part 1 of this blog post here: <a href="https://charlesreid1.github.io/4x4-rubiks-cube-part-1-representations.html">Part 1: Representations</a></p>
<p>You are currently reading Part 2 of this blog post: <strong>Part 2: Permutations</strong></p>
<p>See Part 3 of this blog post here: <a href="https://charlesreid1.github.io/4x4-rubiks-cube-part-3-factoring-permutations.html">Part 3: Factoring Permutations</a></p>
<p>See Part 4 of this blog post here: <a href="#">Part 4: Sequence Order</a></p>
<h1>Table of Contents</h1>
<ul>
<li>
<p><a href="#rubiks2-intro">Introduction: Sequences and Permutations</a></p>
</li>
<li>
<p><a href="#rubiks2-representing">Representing Permutations: Two-Row Notation</a></p>
<ul>
<li><a href="#rubiks2-representing-tworow">Two-Row Notation</a></li>
<li><a href="#rubiks2-representing-tworow-rubiks">Two-Row Notation for Rubik's Cube</a></li>
</ul>
</li>
<li>
<p><a href="#rubiks2-sequences">Sequences</a></p>
<ul>
<li><a href="#rubiks2-sequences-review">Review of Move/Sequence Notation</a></li>
<li><a href="#rubiks2-sequences-permute-cube">How Moves Permute the Cube</a></li>
</ul>
</li>
<li>
<p><a href="#rubiks2-maps">Rotation Maps</a></p>
<ul>
<li><a href="#rubiks2-maps-u">U Rotation Map</a></li>
<li><a href="#rubiks2-maps-d">D Rotation Map</a></li>
<li><a href="#rubiks2-maps-l">L Rotation Map</a></li>
<li><a href="#rubiks2-maps-r">R Rotation Map</a></li>
<li><a href="#rubiks2-maps-f">F Rotation Map</a></li>
<li><a href="#rubiks2-maps-b">B Rotation Map</a></li>
<li><a href="#rubiks2-maps-rotation">How to Use Rotation Map</a></li>
<li><a href="#rubiks2-maps-code">Face Map Code</a></li>
</ul>
</li>
<li>
<p><a href="#rubiks2-tuples">Tuples for Move Sequences</a></p>
<ul>
<li><a href="#rubiks2-tuples-sequences">Applying Rotation Maps for Sequences</a></li>
</ul>
</li>
<li>
<p><a href="#rubiks2-preview">Preview of Part 3</a></p>
</li>
<li>
<p><a href="#rubiks2-references">References</a></p>
</li>
<li>
<p><a href="#rubiks2-appendix">Appendix: Cube with Numbered Faces</a></p>
</li>
</ul>
<p><br />
<br />
<br /></p>
<p><a name="rubiks2-intro"></a></p>
<h1>Introduction</h1>
<p>In this post, we'll be connecting material from Part 1, about 
how to represent the state of the cube in a mathematical way,
to the ultimate goal of exploring properties of particular
move sequences.</p>
<p>In paticular, we'll expand on the tuple notation from Part 1,
and demonstrate the two-row permutation notation of Knuth.
This notation is useful for representing permutations 
in a way that makes it possible to create a system for 
describing permutations using algebra.</p>
<p>We will not discuss the aim of representing permutations
in this way in the present post, but this will be 
described in Part 3.</p>
<p>Next, we discuss move sequences on the Rubik's Cube - 
these are sequences of rotations of particular faces
on the Rubik's Cube. We discuss the application of the 
two-row permutation notation to describe moves
and to describe move sequences.</p>
<p>Finally, we discuss rotation maps, a useful concept
in the implementation of permutations via move sequences.</p>
<p><a name="rubiks2-representing"></a></p>
<h1>Representing Permutations: Two-Row Notation</h1>
<p>We begin by expanding on and streamlining the tuple notation
introduced in Part 1 of this post so that we have a common
basis for comparing two permutations. We do this using a two-row
notation, where the first row denotes the "solved" or default 
state of the system.</p>
<p>In the case of the Rubik's Cube, this is equivalent to 
starting a cube in the solved state, then describing where
each face ends up, in order to completely specify 
the outcome of a move or a sequence of moves.</p>
<p><a name="rubiks2-representing-tworow"></a></p>
<h2>Two-Row Notation</h2>
<p>We begin by considering a permutation of an <span class="math">\(n\)</span>-tuple,
which, in the last post, we resolved to denote </p>
<div class="math">$$
(2 3 4 \dots n 1)
$$</div>
<p>Now, let us write this as two rows: the first row
consists of each element of the tuple <em>in ascending 
order</em>, while the second line will the tuple corresponding
to the order of the elements in this particular permutation:</p>
<div class="math">$$
a = \bigl(\begin{smallmatrix}
  1 &amp; 2 &amp; 3 &amp; \cdots &amp; n-1 &amp; n \\
  2 &amp; 3 &amp; 4 &amp; \cdots &amp;  n  &amp; 1
\end{smallmatrix}\bigr)
$$</div>
<p>We can think of the first row as denoting the "solved", 
default configuration, and the second row denoting how 
each item is permuted.</p>
<p>If we had a different permutation, we would simply change
the second row:</p>
<div class="math">$$
b = \bigl(\begin{smallmatrix}
  1 &amp; 2 &amp; 3 &amp; \cdots &amp; n-1 &amp; n \\
  n &amp; 4 &amp; 1 &amp; \cdots &amp; 2   &amp; 3
\end{smallmatrix}\bigr)
$$</div>
<p><a name="rubiks2-representing-tworow-rubiks"></a></p>
<h2>Two-Row Notation for Rubik's Cube</h2>
<p>If we adopt the above two-row notation for the Rubik's Cube,
and we utilize the face numbering and tuple indexing from Part 1,
the top row consists of the integers from 1 to 96:</p>
<div class="highlight"><pre><span></span>(1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96)
</pre></div>


<p>Now suppose we perform a rotation of the upper row U on the cube.
Then we end up with the following tuple:</p>
<div class="highlight"><pre><span></span>(13 9 5 1 14 10 6 2 15 11 7 3 16 12 8 4 33 34 35 36 21 22 23 24 25 26 27 28 29 30 31 32 49 50 51 52 37 38 39 40 41 42 43 44 45 46 47 48 65 66 67 68 53 54 55 56 57 58 59 60 61 62 63 64 17 18 19 20 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96)
</pre></div>


<p>This tuple denotes the permutation corresponding to the move U 
performed on a solved cube.</p>
<p><a name="rubiks2-sequences"></a></p>
<h1>Sequences</h1>
<p><a name="rubiks2-sequences-review"></a></p>
<h2>Review of Move/Sequence Notation</h2>
<p>Let's quickly recap what we already know from prior posts about the 
properties of move sequences on the Rubik's Cube.</p>
<p>There are 36 possible moves on a cube, and a series of 
moves applied in a particular order defines a sequence.
The 36 possible rotations were given in the prior blog post
and cover clockwise and counterclockwise rotations of 
each of the six faces - either the first layer, the second layer,
or both of the first two layers.</p>
<p>These moves are denoted with six letters (<code>UDLRFB</code>) for the upper,
downward, left, right, front, and back face of the cube, respectively.</p>
<p>Moves indicated should be clockwise unless they contain an apostrophe
character <code>'</code>, which indicates counterclockwise rotation.</p>
<p>A capital letter indicates a rotation of the first layer only 
(e.g., <code>U</code> indicates a clockwise rotation of the first layer of 
the upper face).</p>
<p>A lowercase letter indicates a roration of the first and second layers
(e.g., <code>r</code> indicates a clockwise rotation of the top two layers of
the right face).</p>
<p>A 2 before the letter indicates that the second layer should be rotated
(e.g., <code>2F</code> indicates a clockwise rotation of the second layer of the 
front face).</p>
<p><a name="rubiks2-sequences-permute-cube"></a></p>
<h2>How Moves Permute the Cube</h2>
<p>This will be a little easier to understand if we consider 
a particular move sequence. We'll start simple and consider 
the move sequence <code>U</code>. This results, as we saw before, in:</p>
<div class="highlight"><pre><span></span>U:
(1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96)
(13 9 5 1 14 10 6 2 15 11 7 3 16 12 8 4 33 34 35 36 21 22 23 24 25 26 27 28 29 30 31 32 49 50 51 52 37 38 39 40 41 42 43 44 45 46 47 48 65 66 67 68 53 54 55 56 57 58 59 60 61 62 63 64 17 18 19 20 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96)
</pre></div>


<p>Now let's consider the move sequence <code>U U</code>, a double rotation of the 
cube's top layer:</p>
<div class="highlight"><pre><span></span>U U:
(1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96)
(16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 49 50 51 52 21 22 23 24 25 26 27 28 29 30 31 32 65 66 67 68 37 38 39 40 41 42 43 44 45 46 47 48 17 18 19 20 53 54 55 56 57 58 59 60 61 62 63 64 33 34 35 36 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96)
</pre></div>


<p>Third, we consider the move sequence <code>U U U</code>, equivalent to <code>U'</code>,
a counterclockwise rotation of the top layer:</p>
<div class="highlight"><pre><span></span>U U U:
(1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96)
(4 8 12 16 3 7 11 15 2 6 10 14 1 5 9 13 65 66 67 68 21 22 23 24 25 26 27 28 29 30 31 32 17 18 19 20 37 38 39 40 41 42 43 44 45 46 47 48 33 34 35 36 53 54 55 56 57 58 59 60 61 62 63 64 49 50 51 52 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96)
</pre></div>


<p>The fourth application of <code>U</code>, of course, will return the cube back to its 
solved state:</p>
<div class="highlight"><pre><span></span>U U U:
(1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96)
(1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96)
</pre></div>


<p>Now if we examine the relationship between each of these tuples, 
we see that the faces are exchanged according to specific patterns.</p>
<p>These groups of four numbered faces are exchanged with one another:</p>
<div class="highlight"><pre><span></span>( 4, 16, 13,  1)
( 8, 15,  9,  2)
(12, 14,  5,  3)
( 7, 11, 10,  6)
(65, 49, 33, 17) 
(66, 50, 34, 18)
(67, 51, 35, 19)
(68, 52, 36, 20)
</pre></div>


<p>There are 8 total faces, composing one upper quadrant of the face
being rotated.</p>
<p>The remaining 64 faces do not move:</p>
<div class="highlight"><pre><span></span>(21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96)
</pre></div>


<p><a name="rubiks2-maps"></a></p>
<h1>Rotation Maps</h1>
<p>While the 96-tuple representation is useful, a better computational
representation of the tuple is a rotation map, which consists of 
2-tuples of face index numbers that are permuted. For example,
the tuple <span class="math">\((4,16)\)</span> would indicate that the position at face 4
would become face 16 after the rotation.</p>
<p>As a reminder, here is the solved cube's face index layout:</p>
<div class="highlight"><pre><span></span>             01 02 03 04
             05 06 07 08
             09 10 11 12
             13 14 15 16

17 18 19 20  33 34 35 36  49 50 51 52  65 66 67 68
21 22 23 24  37 38 39 40  53 54 55 56  69 70 71 72
25 26 27 28  41 42 43 44  57 58 59 60  73 74 75 76
29 30 31 32  45 46 47 48  61 62 63 64  77 78 79 80

             81 82 83 84
             85 86 87 88
             89 90 91 92
             93 94 95 96
</pre></div>


<p>Thus, the rotation map representation of each move would be:</p>
<p><a name="rubiks2-maps-u"></a></p>
<h2>U Rotation Map</h2>
<p>Upon a U rotation, the face 1 will become face 13, indicated by (1,13).</p>
<div class="highlight"><pre><span></span>U:
---------------------
[(1, 13),
 (2, 9),
 (3, 5),
 (4, 1),
 (5, 14),
 (6, 10),
 (7, 6),
 (8, 2),
 (9, 15),
 (10, 11),
 (11, 7),
 (12, 3),
 (13, 16),
 (14, 12),
 (15, 8),
 (16, 4),
 (17, 33),
 (18, 34),
 (19, 35),
 (20, 36),
 (33, 49),
 (34, 50),
 (35, 51),
 (36, 52),
 (49, 65),
 (50, 66),
 (51, 67),
 (52, 68),
 (65, 17),
 (66, 18),
 (67, 19),
 (68, 20)]
</pre></div>


<p><a name="rubiks2-maps-d"></a></p>
<h2>D Rotation Map</h2>
<div class="highlight"><pre><span></span>D:
----------------------------------------
[(81, 93),
 (82, 89),
 (83, 85),
 (84, 81),
 (85, 94),
 (86, 90),
 (87, 86),
 (88, 82),
 (89, 95),
 (90, 91),
 (91, 87),
 (92, 83),
 (93, 96),
 (94, 92),
 (95, 88),
 (96, 84),
 (29, 77),
 (30, 78),
 (31, 79),
 (32, 80),
 (45, 29),
 (46, 30),
 (47, 31),
 (48, 32),
 (61, 45),
 (62, 46),
 (63, 47),
 (64, 48),
 (77, 61),
 (78, 62),
 (79, 63),
 (80, 64)]
</pre></div>


<p><a name="rubiks2-maps-l"></a></p>
<h2>L Rotation Map</h2>
<div class="highlight"><pre><span></span>L:
----------------------------------------
[(17, 29),
 (18, 25),
 (19, 21),
 (20, 17),
 (21, 30),
 (22, 26),
 (23, 22),
 (24, 18),
 (25, 31),
 (26, 27),
 (27, 23),
 (28, 19),
 (29, 32),
 (30, 28),
 (31, 24),
 (32, 20),
 (1, 80),
 (5, 76),
 (9, 72),
 (13, 68),
 (33, 1),
 (37, 5),
 (41, 9),
 (45, 13),
 (81, 33),
 (85, 37),
 (89, 41),
 (93, 45),
 (68, 93),
 (72, 89),
 (76, 85),
 (80, 81)]
</pre></div>


<p><a name="rubiks2-maps-r"></a></p>
<h2>R Rotation Map</h2>
<div class="highlight"><pre><span></span> R:
----------------------------------------
[(49, 61),
 (50, 57),
 (51, 53),
 (52, 49),
 (53, 62),
 (54, 58),
 (55, 54),
 (56, 50),
 (57, 63),
 (58, 59),
 (59, 55),
 (60, 51),
 (61, 64),
 (62, 60),
 (63, 56),
 (64, 52),
 (4, 36),
 (8, 40),
 (12, 44),
 (16, 48),
 (36, 84),
 (40, 88),
 (44, 92),
 (48, 96),
 (84, 77),
 (88, 73),
 (92, 69),
 (96, 65),
 (65, 16),
 (69, 12),
 (73, 8),
 (77, 4)]
</pre></div>


<p><a name="rubiks2-maps-f"></a></p>
<h2>F Rotation Map</h2>
<div class="highlight"><pre><span></span> F:
----------------------------------------
[(33, 45),
 (34, 41),
 (35, 37),
 (36, 33),
 (37, 46),
 (38, 42),
 (39, 38),
 (40, 34),
 (41, 47),
 (42, 43),
 (43, 39),
 (44, 35),
 (45, 48),
 (46, 44),
 (47, 40),
 (48, 36),
 (13, 32),
 (14, 28),
 (15, 24),
 (16, 20),
 (20, 81),
 (24, 82),
 (28, 83),
 (32, 84),
 (81, 61),
 (82, 57),
 (83, 53),
 (84, 49),
 (49, 13),
 (53, 14),
 (57, 15),
 (61, 16)]
</pre></div>


<p><a name="rubiks2-maps-b"></a></p>
<h2>B Rotation Map</h2>
<div class="highlight"><pre><span></span> B:
----------------------------------------
[(65, 77),
 (66, 73),
 (67, 69),
 (68, 65),
 (69, 78),
 (70, 74),
 (71, 70),
 (72, 66),
 (73, 79),
 (74, 75),
 (75, 71),
 (76, 67),
 (77, 80),
 (78, 76),
 (79, 72),
 (80, 68),
 (1, 52),
 (2, 56),
 (3, 60),
 (4, 64),
 (17, 4),
 (21, 3),
 (25, 2),
 (29, 1),
 (93, 17),
 (94, 21),
 (95, 25),
 (96, 29),
 (52, 96),
 (56, 95),
 (60, 94),
 (64, 93)]
</pre></div>


<p><a name="rubiks2-maps-rotation"></a></p>
<h2>How To Use Rotation Map</h2>
<p>The rotation map enables us to represent a 4x4 Rubik's Cube
as a simple tuple, and just use a Rubik's Cube object from the 
<a href="https://git.charlesreid1.com/charlesreid1/rubiks-cube-nnn-solver">forked rubikscubesolver library</a>
at git.charlesreid1.com to get the rotation maps.</p>
<div class="highlight"><pre><span></span><span class="c1"># Python code:</span>
<span class="n">cube0</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">96</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
<span class="n">cube1</span> <span class="o">=</span> <span class="n">cube0</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="n">cube_prior</span> <span class="o">=</span> <span class="n">cube0</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="n">r</span> <span class="o">=</span> <span class="n">get_cube</span><span class="p">()</span>

<span class="k">for</span> <span class="n">c</span><span class="p">,</span><span class="n">move</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">rot</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">)):</span>

    <span class="c1"># Get the rotation map</span>
    <span class="n">rotmap</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">rotation_map</span><span class="p">(</span><span class="n">move</span><span class="p">)</span>

    <span class="c1"># (Print the rotation map here)</span>

    <span class="c1"># Apply each transformation in the rotation map to the new cube</span>
    <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">rotmap</span><span class="p">:</span>
        <span class="c1"># shift item at index m[0] to item at index m[1]</span>
        <span class="n">cube1</span><span class="p">[</span><span class="n">cube_prior</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span> <span class="o">=</span> <span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="n">cube_prior</span> <span class="o">=</span> <span class="n">cube1</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
</pre></div>


<p><a name="rubiks2-maps-code"></a></p>
<h2>Face Map Code</h2>
<p>In this section we present a portion of the code 
that actually generates these face maps. This functionality
was not in the <a href="https://github.com/dwalton76/rubiks-cube-NxNxN-solver">original Rubik's Cube solver library</a>
from <a href="https://github.com/dwalton76/">Github user @dwalton76</a>,
so the library was forked and the functionality added
to the <a href="https://git.charlesreid1.com/charlesreid1/rubiks-cube-nnn-solver">forked Rubik's Cube solver library</a>.</p>
<p>The actual implementation is in the <code>rotation_map(action)</code> method,
defined for the Rubik's Cube object at the same place as the 
<code>rotate(action)</code> method. This definition is in 
<code>rubikscubennnsolver/__init__.py</code> on line 581:</p>
<p><a href="https://git.charlesreid1.com/charlesreid1/rubiks-cube-nnn-solver/src/master/rubikscubennnsolver/__init__.py#L581">link to <code>rubikscubennnsolver/__init__.py</code></a></p>
<p>This method returns a list containing the tuples of index permutations 
(old,new) that correspond to this particular move. Call it like this:</p>
<div class="highlight"><pre><span></span><span class="n">order</span> <span class="o">=</span> <span class="s1">&#39;URFDLB&#39;</span>
<span class="n">cube</span> <span class="o">=</span> <span class="n">RubiksCube444</span><span class="p">(</span><span class="n">solved_4x4x4</span><span class="p">,</span> <span class="n">order</span><span class="p">)</span>
<span class="n">cube</span><span class="o">.</span><span class="n">rotation_map</span><span class="p">(</span><span class="s1">&#39;U&#39;</span><span class="p">)</span>
</pre></div>


<p><a name="rubiks2-tuples"></a></p>
<h1>Tuples for Move Sequences</h1>
<p>So far we have shown the tuple representation for the Rubik's Cube
and how it works, and created a more convenient representation for
implementing the cube on a computer and applying rotations.</p>
<p>Now, we can achieve the goal of this post, which is to be able to
represent the state of a cube, after a certain number of rotations,
in a quantitative and mathematical way.</p>
<p>In Part 3, we'll develop an algebra of permutations to use 
and understand the tuple representations we are presenting in 
this post.</p>
<p><a name="rubiks2-tuples-sequences"></a></p>
<h2>Applying Rotation Maps for Sequences</h2>
<p>The concept here is simple: we use the rotation maps that we defined
above to permute elements according to the formula prescribed for 
that particular rotation.</p>
<p>By applying these permutations sequentially, we can permute the 
96-tuple in a way that represents the permutations created by 
a given sequence of moves.</p>
<p>For example, after applying four sequence maps corresponding to 
the move sequence <code>U R U' R'</code> we get:</p>
<div class="highlight"><pre><span></span>(1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96)
(1 2 3 77 5 6 7 73 9 10 11 69 16 12 8 20 17 18 19 36 21 22 23 24 25 26 27 28 29 30 31 32 49 50 51 33 37 38 39 40 41 42 43 44 45 46 47 48 13 56 60 64 53 54 55 34 57 58 59 35 61 62 63 4 96 66 67 68 14 70 71 72 15 74 75 76 65 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 52)
</pre></div>


<p><a name="rubiks2-preview"></a></p>
<h1>Preview of Part 3</h1>
<p>As a preview of where we are going with Part 3, let's 
return to the permutation corresponding to <code>U R U' R'</code>:</p>
<div class="highlight"><pre><span></span>(1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96)
(1 2 3 77 5 6 7 73 9 10 11 69 16 12 8 20 17 18 19 36 21 22 23 24 25 26 27 28 29 30 31 32 49 50 51 33 37 38 39 40 41 42 43 44 45 46 47 48 13 56 60 64 53 54 55 34 57 58 59 35 61 62 63 4 96 66 67 68 14 70 71 72 15 74 75 76 65 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 52)
</pre></div>


<p>It turns out that, unlike the <code>U</code> move by itself, this move sequence 
results in groups of either three or six faces exchanging places.
(In Part 3 we will cover the algorithm for finding these groups,
which, crucially, relies on the work we did in this post.)</p>
<p>The groups of six faces that are permuted are:</p>
<div class="highlight"><pre><span></span><span class="k">[77, 65, 96, 52, 64, 4]</span>
<span class="k">[16, 20, 36, 33, 49, 13]</span>
</pre></div>


<p>These two sets of six faces all live on corners of the cube, 
so this move sequence swaps six corners.</p>
<p>Likewise, the groups of three faces that are permuted are:</p>
<div class="highlight"><pre><span></span><span class="k">[73, 15, 8]</span>
<span class="k">[69, 14, 12]</span>
<span class="k">[50, 56, 34]</span>
<span class="k">[51, 60, 35]</span>
</pre></div>


<p>These are all faces on double edge pieces: </p>
<ul>
<li><code>[73, 15, 8]</code> and <code>[51, 60, 35]</code> are faces on right-handed double edge pieces</li>
<li><code>[69, 14, 12]</code> and <code>[50, 56, 34]</code> are faces on left-handed double edge pieces</li>
</ul>
<p>The remaining faces do not permute:</p>
<div class="highlight"><pre><span></span>[1, 2, 3, 5, 6, 7, 9, 10, 11, 17, 18, 19, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 53, 54, 55, 57, 58, 59, 61, 62, 63, 66, 67, 68, 70, 71, 72, 74, 75, 76, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95]
</pre></div>


<p>What we will discover is that the least common multiple 
of these two numbers, 6 and 3, yields the number of times
this move sequence needs to be applied to a solved cube (6) 
in order to return the cube back to its solved state.</p>
<p><a name="rubiks2-references"></a></p>
<h1>References</h1>
<ol>
<li>
<p>"Rubik's Cube". Charlesreid1.com wiki, Charles Reid. Edited 14 January 2017. Accessed 14 January 2017.
&lt;<a href="https://charlesreid1.com/wiki/Rubiks_Cube">https://charlesreid1.com/wiki/Rubiks_Cube</a>&gt;</p>
</li>
<li>
<p>"Rubik's Revenge". Charlesreid1.com wiki, Charles Reid. Edited 14 January 2017. Accessed 14 January 2017.
&lt;<a href="https://charlesreid1.com/wiki/Rubiks_Revenge">https://charlesreid1.com/wiki/Rubiks_Revenge</a>&gt;</p>
</li>
<li>
<p>"Rubik's Cube/Tuple". Charlesreid1.com wiki, Charles Reid. Edited 14 January 2017. Accessed 14 January 2017.
&lt;<a href="https://charlesreid1.com/wiki/Rubiks_Cube/Tuple">https://charlesreid1.com/wiki/Rubiks_Cube/Tuple</a>&gt;</p>
</li>
<li>
<p>"Rubik's Cube/Permutations". Charlesreid1.com wiki, Charles Reid. Edited 14 January 2017. Accessed 14 January 2017.
&lt;<a href="https://charlesreid1.com/wiki/Rubiks_Cube/Permutations">https://charlesreid1.com/wiki/Rubiks_Cube/Permutations</a>&gt;</p>
</li>
<li>
<p>"Github - dwalton76/rubiks-cube-NxNxN-solver". dwalton76, Github Repository, Github Inc. Accessed 11 January 2017.
&lt;<a href="https://github.com/dwalton76/rubiks-cube-NxNxN-solver">https://github.com/dwalton76/rubiks-cube-NxNxN-solver</a>&gt;</p>
</li>
<li>
<p>"Rubik's Cube NxNxN Solver". Git repository, git.charlesreid1.com. Charles Reid. Updated 14 January 2017.
&lt;<a href="https://git.charlesreid1.com/charlesreid1/rubiks-cube-nnn-solver">https://git.charlesreid1.com/charlesreid1/rubiks-cube-nnn-solver</a>&gt;</p>
</li>
<li>
<p>"Rubiks Cube Cycles". Git repository, git.charlesreid1.com. Charles Reid. Updated 14 January 2017.
&lt;<a href="https://git.charlesreid1.com/charlesreid1/rubiks-cube-cycles">https://git.charlesreid1.com/charlesreid1/rubiks-cube-cycles</a>&gt;</p>
</li>
</ol>
<p><a name="rubiks2-appendix"></a></p>
<h1>Appendix: Cube with Numbered Faces</h1>
<div class="highlight"><pre><span></span>             01 02 03 04
             05 06 07 08
             09 10 11 12
             13 14 15 16

17 18 19 20  33 34 35 36  49 50 51 52  65 66 67 68
21 22 23 24  37 38 39 40  53 54 55 56  69 70 71 72
25 26 27 28  41 42 43 44  57 58 59 60  73 74 75 76
29 30 31 32  45 46 47 48  61 62 63 64  77 78 79 80

             81 82 83 84
             85 86 87 88
             89 90 91 92
             93 94 95 96
</pre></div>


<script type="text/javascript">if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width < 768) ? "left" : align;
        indent = (screen.width < 768) ? "0em" : indent;
        linebreak = (screen.width < 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
</script></div>

    </div>
</div>

<div class="v20"></div>

<div class="row">
    <div class="col-md-12" style="text-align: left;">

        <div class="tags">
            <p>Tags:&nbsp;&nbsp;&nbsp;
                    <a href="https://charlesreid1.github.io/tag/rubiks-cube.html">rubiks cube</a>
                    &nbsp;&nbsp;
                    <a href="https://charlesreid1.github.io/tag/combinatorics.html">combinatorics</a>
                    &nbsp;&nbsp;
                    <a href="https://charlesreid1.github.io/tag/permutations.html">permutations</a>
                    &nbsp;&nbsp;
                    <a href="https://charlesreid1.github.io/tag/python.html">python</a>
                    &nbsp;&nbsp;
                    <a href="https://charlesreid1.github.io/tag/puzzles.html">puzzles</a>
                    &nbsp;&nbsp;
                    <a href="https://charlesreid1.github.io/tag/art-of-computer-programming.html">art of computer programming</a>
                    &nbsp;&nbsp;
                    <a href="https://charlesreid1.github.io/tag/knuth.html">knuth</a>
                    &nbsp;&nbsp;
        </div>

    </div>
</div>


<div class="v200"></div>
  	            	</article>
  	            	<article>
<header>
<div class="row">


    <div class="col-md-12">
        <div class="headtext" style="text-align: center;">
            <h1><b>
                4x4 Rubik's Cube: Part 1: Representations
            </b></h1>
        
            <p class="lead">
                Posted 
                <time datetime="2018-01-11T15:00:00-08:00" pubdate>Thursday 01/11/2018</time>
                in 
                <a href="https://charlesreid1.github.io/category/rubiks-cube.html">Rubiks Cube</a>
                </p>
            <p>
            <span style="font-size: 14px">
                <a href="https://charlesreid1.github.io/4x4-rubiks-cube-part-1-representations.html">permalink</a>
            </span>
            </p>
        </div>

    </div>

</div>
</header>


<div class="v50"></div>


<div class="row">
    <div class="col-md-12" style="text-align: left;">

        <div class="entry-content"><p><em>This is Part 1 of a 4-part blog post 
on the mathematics of the 4x4 Rubik's Cube, 
its relation to algorithms, and some 
curious properties of Rubik's Cubes.</em></p>
<p>You are currently reading Part 1 of this blog post: <strong>Part 1: Representations</strong></p>
<p>See Part 2 of this blog post here: <a href="https://charlesreid1.github.io/4x4-rubiks-cube-part-2-permutations.html">Part 2: Permutations</a></p>
<p>See Part 3 of this blog post here: <a href="https://charlesreid1.github.io/4x4-rubiks-cube-part-3-factoring-permutations.html">Part 3: Factoring Permutations</a></p>
<p>See Part 4 of this blog post here: <a href="#">Part 4: Sequence Order</a></p>
<h1>Table of Contents</h1>
<ul>
<li>
<p><a href="#rubiks1-intro">Introduction: Why the Rubik's Cube</a></p>
<ul>
<li><a href="#rubiks1-intro-why">Why the 4x4 Rubik's Cube</a></li>
</ul>
</li>
<li>
<p><a href="#rubiks1-how">How the Rubik's Cube Works</a></p>
<ul>
<li><a href="#rubiks1-how-pieces">The Pieces</a></li>
<li><a href="#rubiks1-how-face">Face Notation</a></li>
<li><a href="#rubiks1-how-color">Color Notation</a></li>
<li><a href="#rubiks1-how-move">Move Notation</a><ul>
<li><a href="#rubiks1-how-move-regular">Regular Face Rotations</a></li>
<li><a href="#rubiks1-how-move-reverse">Reverse Face Rotations</a></li>
<li><a href="#rubiks1-how-move-double">Double Face Rotations</a></li>
<li><a href="#rubiks1-how-move-second">Second Layer Face Rotations</a></li>
</ul>
</li>
</ul>
</li>
<li>
<p><a href="#rubiks1-computer">Computer Representation of a Rubik's Cube</a></p>
<ul>
<li><a href="#rubiks1-computer-operations">Operations and Functionality</a></li>
<li><a href="#rubiks1-computer-face">Face Numbering</a></li>
</ul>
</li>
<li>
<p><a href="#rubiks1-tuple">Tuple</a></p>
<ul>
<li><a href="#rubiks1-tuple-requirements">Tuple Representation Requirements</a></li>
<li><a href="#rubiks1-tuple-representation">Tuple Representation</a></li>
</ul>
</li>
<li>
<p><a href="#rubiks1-preview">Preview of Part 2</a></p>
</li>
<li>
<p><a href="#rubiks1-references">References</a></p>
</li>
</ul>
<p><br />
<br />
<br /></p>
<p><a name="rubiks1-intro"></a></p>
<h1>Introduction: Why The Rubik's Cube</h1>
<p>In this series of four posts, we'll take a look at the 
4x4 Rubik's Cube. The Rubik's Cube is an interesting
puzzle that has some profound mathematical connections
to group theory and combinatorics.</p>
<p>Group theory is a branch of mathematics that applies to 
any system that exhibits symmetry; combinatorics is the 
mathematics of counting things.</p>
<p>The Rubik's Cube gives us the opportunity to apply
concepts in group theory and combinatorics to 
better understand how the cube works, and to learn
how to apply these principles to real world systems.</p>
<p>Finally, we will wrap up by discussing some of the 
algorithms that are required to deal with a 
Rubik's Cube computationally.</p>
<p>In the next two posts, we'll talk more about the
mathematical representation of permutations of 
the Rubik's Cube, and how to use this representation 
to understand some of the properties of move 
sequences when applied to the cube.</p>
<p><a name="rubiks1-intro-why"></a></p>
<h2>Why The 4x4 Rubik's Cube</h2>
<p>The 4x4 Rubik's cube, also known as the Rubik's Revenge cube, 
is larger than the standard 3x3 Rubik's Cube - 96 faces, instead of 
the ususal 36. The 4x4 cube exhibits some particularly interesting 
properties as a result of having an even number of squares on each edge. </p>
<p><a name="rubiks1-how"></a></p>
<h1>How the Rubik's Cube Works</h1>
<p>Let's start with a discussion of cube mechanics, since this 
is important to coming up with an accurate mathematical model
of the cube.</p>
<p><a name="rubiks1-how-pieces"></a></p>
<h2>The Pieces</h2>
<p>The 4x4 Rubik's Cube consists of six faces of sixteen squares 
each, for a total of 96 face squares. These face squares are 
not completely interchangeable, however - the 4x4 cube is actually
composed of three types of pieces, called "cubies".</p>
<p><img src="images/cube1.jpg" width="300"/>
<strong>Figure 1: Corner pieces are green.</strong></p>
<p>The first type of piece is a <strong>corner piece</strong>, which contains 
3 faces. Note that it is impossible for the corner pieces
to change their chirality (direction of rotation).
There are 8 corner pieces, each of which can be oriented
in 3 different ways. </p>
<p><img src="images/cube2.jpg" width="300"/>
<strong>Figure 2: Double edge pieces are blue.</strong></p>
<p>The second type of piece is a <strong>double edge (dedge) piece</strong>.
Each edge is composed of two double edges. There are 
24 total double edge pieces, which can be further classified
into 12 left-handed and 12 right-handed dedge pieces.</p>
<p><img src="images/cube3.jpg" width="300"/>
<strong>Figure 3: Center pieces are blue.</strong></p>
<p>Lastly, there are 4 <strong>center pieces</strong> in the center of each
face, for a total of 24 center pieces. Note that each of the 
center pieces of a given color are interchangeable, unlike 
the double edge pieces or corners.</p>
<p><a name="rubiks1-how-face"></a></p>
<h2>Face Notation</h2>
<p>To refer to particular faces on the cube, we use six
letters to indicate different faces:</p>
<p><code>U</code> - upper face (the top of the cube)</p>
<p><code>D</code> - downward face (the bottom of the cube0</p>
<p><code>F</code> - front face (the front of the cube)</p>
<p><code>B</code> - back face (the back side of the cube)</p>
<p><code>L</code> - left face of the cube (on the left side when facing the front F face)</p>
<p><code>R</code> - right face of the cube</p>
<p>This will help refer to how we will rotate the cube.</p>
<p><a name="rubiks1-how-color"></a></p>
<h2>Color Notation</h2>
<p>In the solved state, each cube face has one of six colors.
The orientation of these colors relative to one another
is always fixed; the red and orange colored faces, for example,
are never adjacent. This is due to the nature of the mechanical
pieces that compose the Rubik's Cube.</p>
<p>The standard faces for each color on a solved cube are:</p>
<ul>
<li><code>U</code> = White</li>
<li><code>D</code> = Yellow</li>
<li><code>F</code> = Green</li>
<li><code>B</code> = Blue (Back-Blue)</li>
<li><code>L</code> = Orange</li>
<li><code>R</code> = Red (Red-Right)</li>
</ul>
<p>Note that on a 3x3 cube, we can always determine the
final color a face will have, because the six center pieces
on each side of a 3x3 cube always remain fixed.</p>
<p>On a 4x4 cube, however, all four center squares can rotate 
and move, meaning all 24 center squares are totally 
interchangeable, and there is no link between the 
center colors on a 4x4 cube and the final color
that will be on that face when the cube is solved.</p>
<p><a name="rubiks1-how-move"></a></p>
<h2>Move Notation</h2>
<p>Using the face notation explained above, we can denote 
multiple types of moves on the 4x4 Rubik's Cube.</p>
<p>We have 36 total moves that we can make on the 4x4 Rubik's Cube,
which can be grouped by the dozen:</p>
<div class="highlight"><pre><span></span>L l r R
U u d D
B b f F

L&#39; l&#39; r&#39; R&#39;
U&#39; u&#39; d&#39; D&#39;
B&#39; b&#39; f&#39; F&#39;

2L 2L&#39; 2R 2R&#39;
2U 2U&#39; 2D 2D&#39;
2B 2B&#39; 2F 2F&#39;
</pre></div>


<p>Let's go through the details of the notation.</p>
<p><a name="rubiks1-how-move-regular"></a></p>
<h3>Regular Face Rotations</h3>
<p>The regular face turns are denoted with capital letters:
<code>L R U D B F</code> refer to a single clockwise rotation of the 
respective face. Here, "clockwise" means <em>the direction
that is clockwise when facing the given face head-on.</em></p>
<p><a name="rubiks1-how-move-reverse"></a></p>
<h3>Reverse Face Rotations</h3>
<p>The <code>'</code> apostrophe following moves, as in <code>L' R' U' D' B' F'</code>,
indicates that the move shoud be a <em>counter-clockwise</em> 
rotation of the given face, instead of clockwise.</p>
<p><a name="rubiks1-how-move-double"></a></p>
<h3>Double Face Rotations</h3>
<p>Rotations that are indicated using a lowercase letter
refer to two-layer rotations: <code>l r u d b f</code>.</p>
<p><img src="images/cube4.jpg" width="300"/>
<strong>Figure 4: Cube state after move <code>u</code>.</strong></p>
<p>That is, the lowercase <code>u</code> refers to the <em>clockwise</em> 
rotation of the top two layers of the cube; 
the lowercase <code>r</code> refers to the <em>clockwise</em> 
rotation of the rightmost two
layers of the cube; and so on.</p>
<p>The apostrophe also serves to indicate a 
<em>counter-clockwise</em> rotation: <code>'l r' u' d' b' f'</code>
indicate counter clockwise rotations of the two
left, two right, two upper, two bottom, two back,
and two front layers, respectively.</p>
<p>We have covered the first 24 moves - 
clockwise and counter-clockwise rotations
of single and double layers.</p>
<p><a name="rubiks1-how-move-second"></a></p>
<h3>Second Layer Face Rotations</h3>
<p><img src="images/cube5.jpg" width="300"/>
<strong>Figure 5: Cube state after move <code>2U</code>.</strong></p>
<p>The <code>2</code> notation indicates a rotation of the second layer only. 
For example, <code>2U</code> refers to the clockwise rotation of the second 
layer from the top. This is equivalent to the move sequence 
<code>u U'</code>.</p>
<p>Likewise, the apostrophe indicates a counterclockwise rotation.</p>
<p><a name="rubiks1-computer"></a></p>
<h1>Computer Representation of a Rubik's Cube</h1>
<p>The computer representation we are using is the 
<a href="https://github.com/dwalton76/rubiks-cube-NxNxN-solver">rubiks-cube-NxNxN-solver</a>
library by Github user <a href="https://github.com/dwalton76/">@dwalton</a>.</p>
<p>We have modified this library to provide additional
functionality needed in the project; the fork used 
in this project is available at git.charlesreid1.com:
<a href="https://git.charlesreid1.com/charlesreid1/rubiks-cube-nnn-solver">rubiks-cube-nnn-solver</a></p>
<p>Using this library, here's how we create a 4x4
Rubik's Revenge cube:</p>
<div class="highlight"><pre><span></span><span class="n">In</span> <span class="p">[</span><span class="mi">1</span><span class="p">]:</span> <span class="kn">from</span> <span class="nn">rubikscubennnsolver.RubiksCube444</span> <span class="kn">import</span> <span class="n">RubiksCube444</span><span class="p">,</span> <span class="n">solved_4x4x4</span>

<span class="n">In</span> <span class="p">[</span><span class="mi">2</span><span class="p">]:</span> <span class="n">order</span> <span class="o">=</span> <span class="s1">&#39;URFDLB&#39;</span>

<span class="n">In</span> <span class="p">[</span><span class="mi">3</span><span class="p">]:</span> <span class="n">cube</span> <span class="o">=</span> <span class="n">RubiksCube444</span><span class="p">(</span><span class="n">solved_4x4x4</span><span class="p">,</span> <span class="n">order</span><span class="p">)</span>

<span class="n">In</span> <span class="p">[</span><span class="mi">4</span><span class="p">]:</span> <span class="n">cube</span><span class="o">.</span><span class="n">print_cube</span><span class="p">()</span>
         <span class="n">U</span> <span class="n">U</span> <span class="n">U</span> <span class="n">U</span>
         <span class="n">U</span> <span class="n">U</span> <span class="n">U</span> <span class="n">U</span>
         <span class="n">U</span> <span class="n">U</span> <span class="n">U</span> <span class="n">U</span>
         <span class="n">U</span> <span class="n">U</span> <span class="n">U</span> <span class="n">U</span>

<span class="n">L</span> <span class="n">L</span> <span class="n">L</span> <span class="n">L</span>  <span class="n">F</span> <span class="n">F</span> <span class="n">F</span> <span class="n">F</span>  <span class="n">R</span> <span class="n">R</span> <span class="n">R</span> <span class="n">R</span>  <span class="n">B</span> <span class="n">B</span> <span class="n">B</span> <span class="n">B</span>
<span class="n">L</span> <span class="n">L</span> <span class="n">L</span> <span class="n">L</span>  <span class="n">F</span> <span class="n">F</span> <span class="n">F</span> <span class="n">F</span>  <span class="n">R</span> <span class="n">R</span> <span class="n">R</span> <span class="n">R</span>  <span class="n">B</span> <span class="n">B</span> <span class="n">B</span> <span class="n">B</span>
<span class="n">L</span> <span class="n">L</span> <span class="n">L</span> <span class="n">L</span>  <span class="n">F</span> <span class="n">F</span> <span class="n">F</span> <span class="n">F</span>  <span class="n">R</span> <span class="n">R</span> <span class="n">R</span> <span class="n">R</span>  <span class="n">B</span> <span class="n">B</span> <span class="n">B</span> <span class="n">B</span>
<span class="n">L</span> <span class="n">L</span> <span class="n">L</span> <span class="n">L</span>  <span class="n">F</span> <span class="n">F</span> <span class="n">F</span> <span class="n">F</span>  <span class="n">R</span> <span class="n">R</span> <span class="n">R</span> <span class="n">R</span>  <span class="n">B</span> <span class="n">B</span> <span class="n">B</span> <span class="n">B</span>

         <span class="n">D</span> <span class="n">D</span> <span class="n">D</span> <span class="n">D</span>
         <span class="n">D</span> <span class="n">D</span> <span class="n">D</span> <span class="n">D</span>
         <span class="n">D</span> <span class="n">D</span> <span class="n">D</span> <span class="n">D</span>
         <span class="n">D</span> <span class="n">D</span> <span class="n">D</span> <span class="n">D</span>
</pre></div>


<p><a name="rubiks1-computer-operations"></a></p>
<h2>Operations and Functionality</h2>
<p>Some important functionality:</p>
<ul>
<li>Obtaining each side</li>
<li>Applying rotation</li>
<li>Applying sequence of rotations</li>
<li>Each side</li>
<li>Side face numberings, centers, edges</li>
</ul>
<p>To obtain each side, use the <code>sides</code> attribute:</p>
<div class="highlight"><pre><span></span>In [8]: print(cube.sides)
OrderedDict([(&#39;U&#39;, &lt;rubikscubennnsolver.RubiksSide.Side object at 0x11172d358&gt;), 
             (&#39;L&#39;, &lt;rubikscubennnsolver.RubiksSide.Side object at 0x11172d240&gt;), 
             (&#39;F&#39;, &lt;rubikscubennnsolver.RubiksSide.Side object at 0x11172d5c0&gt;), 
             (&#39;R&#39;, &lt;rubikscubennnsolver.RubiksSide.Side object at 0x11172d5f8&gt;), 
             (&#39;B&#39;, &lt;rubikscubennnsolver.RubiksSide.Side object at 0x11172d518&gt;), 
             (&#39;D&#39;, &lt;rubikscubennnsolver.RubiksSide.Side object at 0x11172d390&gt;)])
</pre></div>


<p>Each Side object has a long list of methods, including methods
to obtain the index numbers of corner, edge, or center faces 
on a particular side.</p>
<p>To apply a rotation of a single face, 
use the <code>rotate()</code> method and pass the 
name of the face:</p>
<div class="highlight"><pre><span></span>In [10]: cube.rotate(&quot;U&quot;)

In [11]: cube.print_cube()
         U U U U
         U U U U
         U U U U
         U U U U

F F F F  R R R R  B B B B  L L L L
L L L L  F F F F  R R R R  B B B B
L L L L  F F F F  R R R R  B B B B
L L L L  F F F F  R R R R  B B B B

         D D D D
         D D D D
         D D D D
         D D D D
</pre></div>


<p>Unfortunately, the rotate method does not 
take sequences of moves, but this is easily
resolved:</p>
<div class="highlight"><pre><span></span>In [12]: cube = RubiksCube444(solved_4x4x4, order)

In [13]: sequence = &quot;U L U&#39; L&#39;&quot;

In [14]: for move in sequence.split():
    ...:     cube.rotate(move)
    ...:

In [15]: cube.print_cube()
         L U U U
         U U U U
         U U U U
         U B B L

D F F F  R L L F  U R R R  B B B B
L L L L  F F F F  R R R R  B B B U
L L L L  F F F F  R R R R  B B B U
L L L L  F F F F  R R R R  B B B U

         D D D D
         D D D D
         D D D D
         B D D D
</pre></div>


<p><a name="rubiks1-computer-face"></a></p>
<h2>Face Numbering</h2>
<p>Here is the numerical representation of the faces,
which we will make extensive use of:</p>
<div class="highlight"><pre><span></span>In [6]: cube.print_cube_layout()
             01 02 03 04
             05 06 07 08
             09 10 11 12
             13 14 15 16

17 18 19 20  33 34 35 36  49 50 51 52  65 66 67 68
21 22 23 24  37 38 39 40  53 54 55 56  69 70 71 72
25 26 27 28  41 42 43 44  57 58 59 60  73 74 75 76
29 30 31 32  45 46 47 48  61 62 63 64  77 78 79 80

             81 82 83 84
             85 86 87 88
             89 90 91 92
             93 94 95 96
</pre></div>


<p><a name="rubiks1-tuple"></a></p>
<h1>Tuple Representation</h1>
<p>We have a goal of finding a way of representing the 
state of the 4x4 Rubik's Revenge using a tuple, 
which is a mathematical object that will enable us
to investigate properties of sequences, moves, and 
rotations.</p>
<p>It is important to note that the mechanics of the
cube restrict some of the 96 total faces to only 
occur in particular configurations. By using a 
tuple of 96 integers, we are overspecifying the 
state of the cube, and we would be able to do much 
better if our goal were a minimal representation 
of the Rubik's Cube state.</p>
<p>However, our goal is <em>not</em> a minimal representation
of the cube, but a <em>unique</em> representation of the cube.
As we will see in a later post, the schema we use
does not actually matter, so long as we can 
represent each unique state of the cube using a sequence
of integers of arbitrary length.</p>
<p><a name="rubiks1-tuple-requirements"></a></p>
<h2>Tuple Representation Requirements</h2>
<p>The 4x4 cube, in the solved state, has a few characteristics that can be used
to indicate a particular permutation or configuration:</p>
<ul>
<li>Face indciators <code>UDFBLR</code></li>
<li>Colors <code>WYGBRO</code></li>
<li>Integers 1-96 to number each face</li>
</ul>
<p>Here is how the faces representation looks:</p>
<div class="highlight"><pre><span></span>In [17]: cube.print_cube()
         U U U U
         U U U U
         U U U U
         U U U U

L L L L  F F F F  R R R R  B B B B
L L L L  F F F F  R R R R  B B B B
L L L L  F F F F  R R R R  B B B B
L L L L  F F F F  R R R R  B B B B

         D D D D
         D D D D
         D D D D
         D D D D
</pre></div>


<p>The equivalent color representation is:</p>
<div class="highlight"><pre><span></span>         W W W W
         W W W W
         W W W W
         W W W W

O O O O  G G G G  R R R R  B B B B
O O O O  G G G G  R R R R  B B B B
O O O O  G G G G  R R R R  B B B B
O O O O  G G G G  R R R R  B B B B

         Y Y Y Y
         Y Y Y Y
         Y Y Y Y
         Y Y Y Y
</pre></div>


<p>However, the tuple representation <em>cannot</em> use 
colors to represent the state of the cube.
This is because a tuple representation using 
"R" to represent each red face would give us no
way of distinguishing between the (non-interchangeable)
red faces on the cube. For example, if the 
red-green double edge piece were replaced 
with a red-blue double edge piece, oriented
with the red face at the same location,
the n-tuple needs to reflect that this face
has a different value than it did the prior move.</p>
<p>For this reason, we must use an integer to index 
each distinct face:</p>
<div class="highlight"><pre><span></span>             01 02 03 04
             05 06 07 08
             09 10 11 12
             13 14 15 16

17 18 19 20  33 34 35 36  49 50 51 52  65 66 67 68
21 22 23 24  37 38 39 40  53 54 55 56  69 70 71 72
25 26 27 28  41 42 43 44  57 58 59 60  73 74 75 76
29 30 31 32  45 46 47 48  61 62 63 64  77 78 79 80

             81 82 83 84
             85 86 87 88
             89 90 91 92
             93 94 95 96
</pre></div>


<p>We can rearrange this into a 96-tuple:</p>
<div class="highlight"><pre><span></span>(1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96)
</pre></div>


<p>If we apply a rotation, for example <code>U R</code>, 
we will end up with a different cube:</p>
<div class="highlight"><pre><span></span>             13 09 05 01
             14 10 06 02
             15 11 07 03
             48 44 40 36

33 34 35 84  61 57 53 49  16 66 67 68  17 18 19 20
21 22 23 24  37 38 39 88  62 58 54 50  12 70 71 72
25 26 27 28  41 42 43 92  63 59 55 51  08 74 75 76
29 30 31 32  45 46 47 96  64 60 56 52  04 78 79 80

             81 82 83 77
             85 86 87 73
             89 90 91 69
             93 94 95 65
</pre></div>


<p>This particular sequence of moves results in 
a cube state uniquely represented by the following 
96-tuple:</p>
<div class="highlight"><pre><span></span>(13 9 5 1 14 10 6 2 15 11 7 3 48 44 40 36 33 34 35 84 21 22 23 24 25 26 27 28 29 30 31 32 61 57 53 49 37 38 39 88 41 42 43 92 45 46 47 96 16 66 67 68 62 58 54 50 63 59 55 51 64 60 56 52 17 18 19 20 12 70 71 72 8 74 75 76 4 78 79 80 81 82 83 77 85 86 87 73 89 90 91 69 93 94 95 65)
</pre></div>


<p><a name="rubiks1-tuple-representation"></a></p>
<h2>Tuple Representation</h2>
<p>Now, we have managed to find a unique representation for any given cube state 
by labeling each individual face 1-96.</p>
<p>But we aren't quite done yet. It turns out that our 
statement, that our representation should treat each
face as unique, is not strictly true for all 96 faces.</p>
<p>The square pieces are completely interchangeable, due to 
the fact that they are not connected to any other faces
(and therefore have no orientation or way of differentiating
them from one another).</p>
<p>If we are doing anything that involves counting 
configurations, it is important to account for this fact,
by treating the following groups of face indices as
interchangeable:</p>
<div class="highlight"><pre><span></span>(6, 7, 10, 11)
(22, 23, 26, 27)
(38, 39, 42, 43)
(54, 55, 58, 59)
(70, 71, 74, 75)
(86, 87, 90, 91)
</pre></div>


<p>In Part 2 and Part 3 of this series, we will 
encounter these concepts again, and it will
become more clear what these caveats and 
notes mean through example.</p>
<p>Following is a preview of Part 2 of this 3-part blog post.</p>
<p><a name="rubiks1-preview"></a></p>
<h1>Preview of Part 2</h1>
<p>In Part 2 of this series, we will utilize the n-tuple representation
of the 4x4 Rubik's Cube in order to write permutations of the cube
corresponding to specific states, and turn a sequence of moves on the 
cube into permutations.</p>
<p>We will also create a map for each type of move, telling us 
where each face index will end up.</p>
<p>In Part 3 we will use these to predict properties of 
rotations applied to the 4x4 Rubik's Cube.</p>
<p><a name="rubiks1-references"></a></p>
<h1>References</h1>
<ol>
<li>
<p>"Rubik's Cube". Charlesreid1.com wiki, Charles Reid. Edited 11 January 2017. Accessed 11 January 2017.
&lt;<a href="https://charlesreid1.com/wiki/Rubiks_Cube">https://charlesreid1.com/wiki/Rubiks_Cube</a>&gt;</p>
</li>
<li>
<p>"Rubik's Revenge". Charlesreid1.com wiki, Charles Reid. Edited 11 January 2017. Accessed 11 January 2017.
&lt;<a href="https://charlesreid1.com/wiki/Rubiks_Revenge">https://charlesreid1.com/wiki/Rubiks_Revenge</a>&gt;</p>
</li>
<li>
<p>"Rubik's Cube/Tuple". Charlesreid1.com wiki, Charles Reid. Edited 11 January 2017. Accessed 11 January 2017.
&lt;<a href="https://charlesreid1.com/wiki/Rubiks_Cube/Tuple">https://charlesreid1.com/wiki/Rubiks_Cube/Tuple</a>&gt;</p>
</li>
<li>
<p>"Rubik's Cube/Permutations". Charlesreid1.com wiki, Charles Reid. Edited 11 January 2017. Accessed 11 January 2017.
&lt;<a href="https://charlesreid1.com/wiki/Rubiks_Cube/Permutations">https://charlesreid1.com/wiki/Rubiks_Cube/Permutations</a>&gt;</p>
</li>
<li>
<p>"Github - dwalton76/rubiks-cube-NxNxN-solver". dwalton76, Github Repository, Github Inc. Accessed 11 January 2017.
&lt;<a href="https://github.com/dwalton76/rubiks-cube-NxNxN-solver">https://github.com/dwalton76/rubiks-cube-NxNxN-solver</a>&gt;</p>
</li>
<li>
<p>"Rubik's Cube NxNxN Solver". Git repository, git.charlesreid1.com. Charles Reid. Updated 11 January 2017.
&lt;<a href="https://charlesreid1.com:3000/charlesreid1/rubiks-cube-nnn-solver">https://git.charlesreid1.com/charlesreid1/rubiks-cube-nnn-solver</a>&gt;</p>
</li>
<li>
<p>"Rubiks Cube Cycles". Git repository, git.charlesreid1.com. Charles Reid. Updated 11 January 2017.
&lt;<a href="https://charlesreid1.com:3000/charlesreid1/rubiks-cube-cycles">https://git.charlesreid1.com/charlesreid1/rubiks-cube-cycles</a>&gt;</p>
</li>
</ol></div>

    </div>
</div>

<div class="v20"></div>

<div class="row">
    <div class="col-md-12" style="text-align: left;">

        <div class="tags">
            <p>Tags:&nbsp;&nbsp;&nbsp;
                    <a href="https://charlesreid1.github.io/tag/rubiks-cube.html">rubiks cube</a>
                    &nbsp;&nbsp;
                    <a href="https://charlesreid1.github.io/tag/mathematics.html">mathematics</a>
                    &nbsp;&nbsp;
                    <a href="https://charlesreid1.github.io/tag/combinatorics.html">combinatorics</a>
                    &nbsp;&nbsp;
                    <a href="https://charlesreid1.github.io/tag/permutations.html">permutations</a>
                    &nbsp;&nbsp;
                    <a href="https://charlesreid1.github.io/tag/python.html">python</a>
                    &nbsp;&nbsp;
                    <a href="https://charlesreid1.github.io/tag/puzzles.html">puzzles</a>
                    &nbsp;&nbsp;
        </div>

    </div>
</div>


<div class="v200"></div>
  	            	</article>

<div class="row">
    <div class="col-md-4 col-centered" style="text-align: center;">

        <div class="pagination">

            <a class="next" href="https://charlesreid1.github.io/index10.html">&larr; Newer</a>

            &nbsp;
            &nbsp;
            &nbsp;
            &nbsp;
            &nbsp;

            <a class="prev" href="https://charlesreid1.github.io/index12.html">Older &rarr;</a>
        
          <br />
        </div>

    </div>
</div>

<div class="v50"></div>


        </div>

        <div class="col-md-4" style="text-align: center;">
<a name="a_archive"></a>


        <div class="well">

            <h2>November 2019</h2>

            <p class="archive">
            <a href="https://charlesreid1.github.io/git-workflows-part-2-crafting-commits.html">Git Workflows, Part 2: Crafting Commits</a>
            </p>

        </div>

        <div class="v20"></div>


        <div class="well">

            <h2>October 2019</h2>

            <p class="archive">
            <a href="https://charlesreid1.github.io/git-workflows-part-1-supercharging-your-git-config.html">Git Workflows, Part 1: Supercharging your Git Config</a>
            </p>

        </div>

        <div class="v20"></div>


        <div class="well">

            <h2>September 2019</h2>

            <p class="archive">
            <a href="https://charlesreid1.github.io/mocking-aws-in-unit-tests.html">Mocking AWS in Unit Tests</a>
            </p>

        </div>

        <div class="v20"></div>


        <div class="well">

            <h2>May 2019</h2>

            <p class="archive">
            <a href="https://charlesreid1.github.io/deconvoluting-convolutional-neural-networks.html">Deconvoluting Convolutional Neural Networks</a>
            </p>
            <p class="archive">
            <a href="https://charlesreid1.github.io/graphs-for-bioinformatics-part-1-de-bruijn-graphs-hamiltonian-paths-and-eulerian-paths.html">Graphs for Bioinformatics, Part 1: de Bruijn Graphs, Hamiltonian Paths, and Eulerian Paths</a>
            </p>

        </div>

        <div class="v20"></div>


        <div class="well">

            <h2>April 2019</h2>

            <p class="archive">
            <a href="https://charlesreid1.github.io/the-git-commit-ectomy.html">The Git-Commit-Ectomy</a>
            </p>

        </div>

        <div class="v20"></div>


        <div class="well">

            <h2>March 2019</h2>

            <p class="archive">
            <a href="https://charlesreid1.github.io/the-josephus-problem-part-3-solving-the-double-step-case.html">The Josephus Problem: Part 3: Solving the Double Step Case</a>
            </p>
            <p class="archive">
            <a href="https://charlesreid1.github.io/the-josephus-problem-part-2-two-examples.html">The Josephus Problem: Part 2: Two Examples</a>
            </p>
            <p class="archive">
            <a href="https://charlesreid1.github.io/the-josephus-problem-part-1-the-problem.html">The Josephus Problem: Part 1: The Problem</a>
            </p>
            <p class="archive">
            <a href="https://charlesreid1.github.io/approximating-pi-happy-pi-day.html">Approximating Pi (Happy Pi Day)</a>
            </p>
            <p class="archive">
            <a href="https://charlesreid1.github.io/five-letter-words-part-5-the-try-trie-tree.html">Five Letter Words: Part 5: The Try Trie Tree</a>
            </p>
            <p class="archive">
            <a href="https://charlesreid1.github.io/five-letter-words-part-4-revisiting-diff-by-one.html">Five Letter Words: Part 4: Revisiting Diff by One</a>
            </p>
            <p class="archive">
            <a href="https://charlesreid1.github.io/centillion-a-document-search-engine.html">centillion: a document search engine</a>
            </p>

        </div>

        <div class="v20"></div>


        <div class="well">

            <h2>February 2019</h2>

            <p class="archive">
            <a href="https://charlesreid1.github.io/any-color-you-like-as-long-as-its-00add8.html">Any Color You Like, As Long As It's 00ADD8</a>
            </p>
            <p class="archive">
            <a href="https://charlesreid1.github.io/a-few-of-my-favorite-peps.html">A Few of My Favorite PEPs</a>
            </p>
            <p class="archive">
            <a href="https://charlesreid1.github.io/context-managers-in-python.html">Context Managers in Python</a>
            </p>

        </div>

        <div class="v20"></div>


        <div class="well">

            <h2>January 2019</h2>

            <p class="archive">
            <a href="https://charlesreid1.github.io/building-snakemake-command-line-wrappers-for-kubernetes-workflows.html">Building Snakemake Command Line Wrappers for Kubernetes Workflows</a>
            </p>
            <p class="archive">
            <a href="https://charlesreid1.github.io/building-snakemake-command-line-wrappers-for-workflows.html">Building Snakemake Command Line Wrappers for Workflows</a>
            </p>
            <p class="archive">
            <a href="https://charlesreid1.github.io/recursive-backtracking-in-go-for-bioinformatics-applications-3-go-implementation-of-backtracking.html">Recursive Backtracking in Go for Bioinformatics Applications: 3. Go Implementation of Backtracking</a>
            </p>

        </div>

        <div class="v20"></div>


        <div class="well">

            <h2>December 2018</h2>

            <p class="archive">
            <a href="https://charlesreid1.github.io/recursive-backtracking-in-go-for-bioinformatics-applications-2-generating-variations.html">Recursive Backtracking in Go for Bioinformatics Applications: 2. Generating Variations</a>
            </p>
            <p class="archive">
            <a href="https://charlesreid1.github.io/recursive-backtracking-in-go-for-bioinformatics-applications-1-counting-variations.html">Recursive Backtracking in Go for Bioinformatics Applications: 1. Counting Variations</a>
            </p>
            <p class="archive">
            <a href="https://charlesreid1.github.io/basic-data-structures-in-go-maps.html">Basic Data Structures in Go: Maps</a>
            </p>
            <p class="archive">
            <a href="https://charlesreid1.github.io/learning-bioinformatics-with-go-and-rosalind.html">Learning Bioinformatics with Go and Rosalind</a>
            </p>

        </div>

        <div class="v20"></div>


        <div class="well">

            <h2>October 2018</h2>

            <p class="archive">
            <a href="https://charlesreid1.github.io/first-post-of-the-fall-part-2-flaskadillo.html">First Post of the Fall, Part 2: Flaskadillo</a>
            </p>
            <p class="archive">
            <a href="https://charlesreid1.github.io/first-post-of-the-fall-part-1-data-commons.html">First Post of the Fall, Part 1: Data Commons</a>
            </p>

        </div>

        <div class="v20"></div>


        <div class="well">

            <h2>May 2018</h2>

            <p class="archive">
            <a href="https://charlesreid1.github.io/current-projects.html">Current Projects</a>
            </p>

        </div>

        <div class="v20"></div>


        <div class="well">

            <h2>March 2018</h2>

            <p class="archive">
            <a href="https://charlesreid1.github.io/charlesreid1com-stack.html">Charlesreid1.com Stack</a>
            </p>

        </div>

        <div class="v20"></div>


        <div class="well">

            <h2>February 2018</h2>

            <p class="archive">
            <a href="https://charlesreid1.github.io/d3-calendar-visualizations.html">D3 Calendar Visualizations</a>
            </p>
            <p class="archive">
            <a href="https://charlesreid1.github.io/project-euler-problem-172.html">Project Euler Problem 172</a>
            </p>

        </div>

        <div class="v20"></div>


        <div class="well">

            <h2>January 2018</h2>

            <p class="archive">
            <a href="https://charlesreid1.github.io/4x4-rubiks-cube-part-4-sequence-order.html">4x4 Rubik's Cube: Part 4: Sequence Order</a>
            </p>
            <p class="archive">
            <a href="https://charlesreid1.github.io/4x4-rubiks-cube-part-3-factoring-permutations.html">4x4 Rubik's Cube: Part 3: Factoring Permutations</a>
            </p>
            <p class="archive">
            <a href="https://charlesreid1.github.io/4x4-rubiks-cube-part-2-permutations.html">4x4 Rubik's Cube: Part 2: Permutations</a>
            </p>
            <p class="archive">
            <a href="https://charlesreid1.github.io/4x4-rubiks-cube-part-1-representations.html">4x4 Rubik's Cube: Part 1: Representations</a>
            </p>
            <p class="archive">
            <a href="https://charlesreid1.github.io/lets-generate-permutations.html">Let's Generate Permutations!</a>
            </p>

        </div>

        <div class="v20"></div>


        <div class="well">

            <h2>September 2017</h2>

            <p class="archive">
            <a href="https://charlesreid1.github.io/five-letter-words-part-3-letter-coverage-and-dynamic-programming.html">Five Letter Words: Part 3: Letter Coverage and Dynamic Programming</a>
            </p>
            <p class="archive">
            <a href="https://charlesreid1.github.io/five-letter-words-part-2-more-five-word-algorithms.html">Five Letter Words: Part 2: More Five-Word Algorithms</a>
            </p>
            <p class="archive">
            <a href="https://charlesreid1.github.io/five-letter-words-part-1-getting-familiar-with-the-list.html">Five Letter Words: Part 1: Getting Familiar With The List</a>
            </p>

        </div>

        <div class="v20"></div>


        <div class="well">

            <h2>August 2017</h2>

            <p class="archive">
            <a href="https://charlesreid1.github.io/eulers-theorem-the-totient-function-and-calculating-totients-by-hand.html">Euler's Theorem, the Totient Function, and Calculating Totients By Hand</a>
            </p>

        </div>

        <div class="v20"></div>


        <div class="well">

            <h2>July 2017</h2>

            <p class="archive">
            <a href="https://charlesreid1.github.io/mad-combinatoric-castles.html">Mad Combinatoric Castles</a>
            </p>
            <p class="archive">
            <a href="https://charlesreid1.github.io/project-euler-problem-1.html">Project Euler Problem 1</a>
            </p>
            <p class="archive">
            <a href="https://charlesreid1.github.io/shortest-lattice-paths-and-multiset-permutations.html">Shortest Lattice Paths and Multiset Permutations</a>
            </p>
            <p class="archive">
            <a href="https://charlesreid1.github.io/computing-square-roots-part-2-using-continued-fractions.html">Computing Square Roots: Part 2: Using Continued Fractions</a>
            </p>
            <p class="archive">
            <a href="https://charlesreid1.github.io/computing-square-roots-part-1-using-newtons-method.html">Computing Square Roots: Part 1: Using Newton's Method</a>
            </p>

        </div>

        <div class="v20"></div>


        <div class="well">

            <h2>June 2017</h2>

            <p class="archive">
            <a href="https://charlesreid1.github.io/cse-143-final-project-hilbert-sort-3-the-code.html">CSE 143 Final Project: Hilbert Sort: 3. The Code</a>
            </p>
            <p class="archive">
            <a href="https://charlesreid1.github.io/cse-143-final-project-hilbert-sort-2-the-solution-algorithm.html">CSE 143 Final Project: Hilbert Sort: 2. The Solution Algorithm</a>
            </p>
            <p class="archive">
            <a href="https://charlesreid1.github.io/cse-143-final-project-hilbert-sort-1-the-problem.html">CSE 143 Final Project: Hilbert Sort: 1. The Problem</a>
            </p>
            <p class="archive">
            <a href="https://charlesreid1.github.io/cse-143-final-project-classy.html">CSE 143 Final Project: Classy</a>
            </p>
            <p class="archive">
            <a href="https://charlesreid1.github.io/cse-143-final-project-checkers.html">CSE 143 Final Project: Checkers</a>
            </p>

        </div>

        <div class="v20"></div>


        <div class="well">

            <h2>May 2017</h2>

            <p class="archive">
            <a href="https://charlesreid1.github.io/teaching-recursion-with-the-n-queens-problem.html">Teaching Recursion with the N Queens Problem</a>
            </p>
            <p class="archive">
            <a href="https://charlesreid1.github.io/undergraduate-research-project-wireless-sensor-networks-for-internet-of-things-applications-part-2-the-technologies.html">Undergraduate Research Project: Wireless Sensor Networks for Internet of Things Applications (Part 2: The Technologies)</a>
            </p>
            <p class="archive">
            <a href="https://charlesreid1.github.io/undergraduate-research-project-wireless-sensor-networks-for-internet-of-things-applications-part-1-the-project.html">Undergraduate Research Project: Wireless Sensor Networks for Internet of Things Applications (Part 1: The Project)</a>
            </p>

        </div>

        <div class="v20"></div>


        <div class="well">

            <h2>April 2017</h2>

            <p class="archive">
            <a href="https://charlesreid1.github.io/stunnel.html">Stunnel</a>
            </p>
            <p class="archive">
            <a href="https://charlesreid1.github.io/traveling-schoolteacher-problem.html">Traveling Schoolteacher Problem</a>
            </p>
            <p class="archive">
            <a href="https://charlesreid1.github.io/the-z-machine-a-simple-turing-machine.html">The Z-Machine: A Simple Turing Machine</a>
            </p>
            <p class="archive">
            <a href="https://charlesreid1.github.io/awsome-day-seattle-notes-part-2-networking-security-and-miscellany.html">AWSome Day Seattle Notes: Part 2: Networking, Security, and Miscellany</a>
            </p>
            <p class="archive">
            <a href="https://charlesreid1.github.io/awsome-day-seattle-notes-part-1-the-basics.html">AWSome Day Seattle Notes: Part 1: The Basics</a>
            </p>
            <p class="archive">
            <a href="https://charlesreid1.github.io/setting-up-a-self-hosted-github-clone-with-gitea.html">Setting Up a Self-Hosted Github Clone with Gitea</a>
            </p>
            <p class="archive">
            <a href="https://charlesreid1.github.io/better-timing-of-guava-traveling-salesperson-problem-code-timing-scripts.html">Better Timing of Guava Traveling Salesperson Problem Code: Timing Scripts</a>
            </p>

        </div>

        <div class="v20"></div>


        <div class="well">

            <h2>March 2017</h2>

            <p class="archive">
            <a href="https://charlesreid1.github.io/fixing-bottlenecks-in-the-guava-traveling-salesperson-problem-code.html">Fixing Bottlenecks in the Guava Traveling Salesperson Problem Code</a>
            </p>
            <p class="archive">
            <a href="https://charlesreid1.github.io/python-vs-perl-n-queens-problem.html">Python vs. Perl: N Queens Problem</a>
            </p>
            <p class="archive">
            <a href="https://charlesreid1.github.io/solving-the-traveling-salesperson-problem-with-java-and-guava.html">Solving the Traveling Salesperson Problem with Java and Guava</a>
            </p>
            <p class="archive">
            <a href="https://charlesreid1.github.io/perl-vs-java-n-queens-problem.html">Perl vs. Java: N Queens Problem</a>
            </p>
            <p class="archive">
            <a href="https://charlesreid1.github.io/enigma-cipher-implementation-part-4-combinatorics.html">Enigma Cipher Implementation: Part 4: Combinatorics</a>
            </p>
            <p class="archive">
            <a href="https://charlesreid1.github.io/enigma-cipher-implementation-part-3-enigma-in-java-without-objects.html">Enigma Cipher Implementation: Part 3: Enigma in Java Without Objects</a>
            </p>
            <p class="archive">
            <a href="https://charlesreid1.github.io/enigma-cipher-implementation-part-2-pseudocode.html">Enigma Cipher Implementation: Part 2: Pseudocode</a>
            </p>
            <p class="archive">
            <a href="https://charlesreid1.github.io/enigma-cipher-implementation-part-1-how-it-works.html">Enigma Cipher Implementation: Part 1: How It Works</a>
            </p>

        </div>

        <div class="v20"></div>



<div class="v100"></div>
        </div>

    </div>



</div>



<script type="text/javascript" src="https://charlesreid1.github.io/theme/js/jquery-1.11.2.js"></script>
<script type="text/javascript" src="https://charlesreid1.github.io/theme/js/bootstrap-3.3.4.js"></script>
<script type="text/javascript" src="https://charlesreid1.github.io/theme/js/d3-3.5.5.js"></script><script type="text/javascript" src="https://charlesreid1.github.io/theme/js/jquery-1.11.2.js"></script>
<script type="text/javascript" src="https://charlesreid1.github.io/theme/js/bootstrap-3.3.4.js"></script>

<footer id="contentinfo" class="body">
<p>&nbsp;</p>
<p>&nbsp;</p>
<center>
	<hr />
</center>
<p>&nbsp;</p>
<p style="text-align: center">
    <span class="fa-stack fa-lg">
        <i class="fa fa-square fa-stack-2x" style="color:#000;"></i>
        <i class="fa fa-terminal fa-stack-1x fa-inverse"></i>
    </span>
    Made from the command line with vim by 
    <a href="http://charlesreid1.com">charlesreid1</a><br />
    with help from <a href="https://getbootstrap.com/">Bootstrap</a> and <a href="http://getpelican.com">Pelican</a>.
</p>

<br />

<p style="text-align: center">
    <a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/">
    <span class="fa-stack fa-lg">
        <i class="fa fa-square fa-stack-2x" style="color:#000;"></i>
        <i class="fa fa-creative-commons fa-stack-1x fa-inverse"></i>
    </span>
    </a>
    <br />
    Licensed under the <a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/">Creative Commons Attribution-NonCommercial 4.0 License</a>.
</p>

<!-- Start of StatCounter Code for Default Guide -->
<script type="text/javascript">
var sc_project=11611748;
var sc_invisible=1;
var sc_security="9fcba820";
</script>
<script type="text/javascript"
src="https://www.statcounter.com/counter/counter.js"
async></script>

<noscript><div class="statcounter"><a title="Web Analytics"
href="http://statcounter.com/" target="_blank"><img
class="statcounter"
src="//c.statcounter.com/11611748/0/9fcba820/1/" alt="Web
Analytics"></a></div></noscript>
<!-- End of StatCounter Code for Default Guide -->
</footer><!-- /#contentinfo -->
</body>
</html>