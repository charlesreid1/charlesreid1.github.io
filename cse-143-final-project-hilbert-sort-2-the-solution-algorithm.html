<!DOCTYPE html>
<html lang="en">
<head>
        <title>charlesreid1</title>
        <meta charset="utf-8" />

        <!--
        CSS styles
        -->
        <link href="/theme/css/bootstrap.css"       rel="stylesheet" type="text/css">
        <link href="/theme/css/slate.css"              rel="stylesheet" type="text/css">
        <link href="/theme/css/font-awesome.css"       rel="stylesheet" type="text/css"/>
        <link href="/theme/css/pygment-solarized.css"  rel="stylesheet" type="text/css"/>

        <!--
        my CSS styles
        -->
        <link href="/theme/css/main.css"            rel="stylesheet" type="text/css">
        <link href="/theme/css/dox.css"             rel="stylesheet" type="text/css">


        <!--
        include Angular first
        -->
        <script type="text/javascript" src="/theme/js/angular-1.3.15.js"></script>
        <script type="text/javascript" src="/theme/js/skrollr-0.6.29.js"></script>
        <script type="text/javascript" src="/theme/js/d3-3.5.5.js"></script>

        <!--
        this seems like a bad idea.
        but if I don't put jquery first, I get errors about unrecognized $s.
        -->
        <script type="text/javascript" src="/theme/js/jquery-1.11.2.js"></script>

</head>
<body id="index">
<nav class="navbar navbar-default">
    <div class="container-fluid">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#myNavbar">
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span> 
            </button>
            <a href="https://charlesreid1.github.io" class="navbar-brand">charlesreid1.github.io</a>
        </div>
        <div>
            <div class="collapse navbar-collapse" id="myNavbar">
                <ul class="nav navbar-nav">

                    <li>
                        <a href="https://charlesreid1.com/wiki">Wiki</a>
                    </li>
                    <li>
                        <a href="https://git.charlesreid1.com/explore">Git</a>
                    </li>
                    <li>
                        <a href="http://spotify.charlesreid1.com">Music</a>
                    </li>
                    <li>
                        <a href="https://charlesreid1.com/life">Life</a>
                    </li>
                    <li>
                        <a href="https://charlesreid1.github.io">Blog</a>
                    </li>
                    <li>
                        <a href="https://charlesreid1.com/about">About Me</a>
                    </li>

                </ul>
            </div>
        </div>
    </div>
</nav>



<div class="container">

<header>
<div class="row">


    <div class="col-md-12">
        <div class="headtext" style="text-align: center;">
            <h1><b>
                CSE 143 Final Project: Hilbert Sort: 2. The Solution Algorithm
            </b></h1>
        
            <p class="lead">
                Posted 
                <time datetime="2017-06-27T11:00:00-07:00" pubdate>Tuesday 06/27/2017</time>
                in 
                <a href="/category/computer-science.html">Computer Science</a>
                </p>
            <p>
            <span style="font-size: 14px">
                <a href="/cse-143-final-project-hilbert-sort-2-the-solution-algorithm.html">permalink</a>
            </span>
            </p>
        </div>

    </div>

</div>
</header>


<div class="v50"></div>


<div class="row">
    <div class="col-md-12" style="text-align: left;">

        <div class="entry-content"><h1>Table of Contents</h1>
<p>This is the second in a series of three posts 
detailing the Hilbert Sort problem,
its solution, and its implementation.
This post solves the problem.</p>
<ul>
<li><a href="#hilbert2-problem">Hilbert Sort Problem</a></li>
<li><a href="#hilbert2-space">Space Is The Place</a></li>
<li><a href="#hilbert2-reflections">The Reflections</a><ul>
<li><a href="#hilbert2-quad">Reflected Quadrants</a></li>
<li><a href="#hilbert2-scaling">Scaling</a></li>
<li><a href="#hilbert2-reflection">Reflection</a></li>
</ul>
</li>
<li><a href="#hilbert2-reflection-solution">Solving the Reflection Problem</a></li>
<li><a href="#hilbert2-procedure">Procedure</a></li>
<li><a href="#hilbert2-references">References</a></li>
</ul>
<p><a name="hilbert2-problem"></a></p>
<h1>Hilbert Sort Problem</h1>
<p>In the prior post, we covered the Hilbert Sort problem, 
but we state it once more succinctly here before 
detailing a solution to the problem.</p>
<p>The Hilbert Sort problem asks the following: 
given a set of labeled <span class="math">\((x,y)\)</span> points,
how can we sort the points according to 
the order in which they are visited 
by a space-filling Hilbert curve?</p>
<p>Revisiting the example input and output provided, the input provides 
the number of points and size of the grid on the first line, 
followed by each point's coordinates and label.</p>
<div class="highlight"><pre><span></span><span class="n">Input</span><span class="o">:</span>
    <span class="mi">14</span> <span class="mi">25</span>
    <span class="mi">5</span> <span class="mi">5</span> <span class="n">Honolulu</span>
    <span class="mi">5</span> <span class="mi">10</span> <span class="n">PugetSound</span>
    <span class="mi">5</span> <span class="mi">20</span> <span class="n">Victoria</span>
    <span class="mi">10</span> <span class="mi">5</span> <span class="n">Berkeley</span>
    <span class="mi">10</span> <span class="mi">10</span> <span class="n">Portland</span>
    <span class="mi">10</span> <span class="mi">15</span> <span class="n">Seattle</span>
    <span class="mi">10</span> <span class="mi">20</span> <span class="n">Vancouver</span>
    <span class="mi">15</span> <span class="mi">5</span> <span class="n">LasVegas</span>
    <span class="mi">15</span> <span class="mi">10</span> <span class="n">Sacramento</span>
    <span class="mi">15</span> <span class="mi">15</span> <span class="n">Kelowna</span>
    <span class="mi">15</span> <span class="mi">20</span> <span class="n">PrinceGeorge</span>
    <span class="mi">20</span> <span class="mi">5</span> <span class="n">Phoenix</span>
    <span class="mi">20</span> <span class="mi">10</span> <span class="n">SaltLakeCity</span>
    <span class="mi">20</span> <span class="mi">20</span> <span class="n">Calgary</span>

<span class="n">Output</span><span class="o">:</span>
    <span class="n">Honolulu</span>
    <span class="n">Berkeley</span>
    <span class="n">Portland</span>
    <span class="n">PugetSound</span>
    <span class="n">Victoria</span>
    <span class="n">Vancouver</span>
    <span class="n">Seattle</span>
    <span class="n">Kelowna</span>
    <span class="n">PrinceGeorge</span>
    <span class="n">Calgary</span>
    <span class="n">SaltLakeCity</span>
    <span class="n">Sacramento</span>
    <span class="n">LasVegas</span>
    <span class="n">Phoenix</span>
</pre></div>


<p><a name="hilbert2-space"></a></p>
<h1>Space is the Place</h1>
<p>To solve the Hilbert Sort problem, we have to avoid the temptation
to think about the Hilbert curve and the way that it is constructed.
While we spent quite a bit of time talking about the Hilbert curve
and how it is constructed, the curve itself is not what we are 
interested in - we are interested in the order in which the points
are visited. </p>
<p>Also remember, the motivation of solving the Hilbert Sort problem is to 
arrange spatial <span class="math">\((x,y)\)</span> points so closer points are nearer together.</p>
<p>No matter how many iterations of the Hilbert curve we end up drawing,
we always apply the same procedure: cut the square into four quadrants, 
reflect the southwest corner about the bottom left to top right diagonal,
and reflect the southeast corner about the bottom right to top left diagonal.</p>
<p>We will always visit points in the southwest quadrant before we visit 
points in the northwest quadrant; we will always visit points in the northwest
corner before we visit points in the northeast corner; etc.</p>
<p><a name="hilbert2-reflections"></a></p>
<h1>The Reflections</h1>
<p>The trickiest part of the Hilbert Sort problem is the reflection that happens 
to the lower left and lower right quadrants.</p>
<p><a name="hilbert2-quad"></a></p>
<h2>Reflected Quadrants</h2>
<p>Start with the first step of the Hilbert sort - take a square with points contained in it. 
Split the square into four quadrants (with the intention of creating four sub-problems).
However, to conform to the Hilbert Curve construction process,
the lower left and lower right squares must be reflected.
The lower left square is reflected about the bottom left to upper right diagonal,
while the lower right square is reflected about the bottom right to upper left diagonal.</p>
<p>Convince yourself of this by studying the curve construction procedure as illustrated
by Hilbert himself in his 1890 paper (a.k.a., Hilbert Illustrates A Hilbert Curve):</p>
<p><img alt="Hilbert Illustrates Construction of Hilbert Curve" src="/images/HilbertCurve-OriginalPaper.png"></p>
<p>We are working toward a recursive method - and recursive methods call themselves repeatedly,
apply to subproblems that are trivially similar. However, to translate this into a recursive 
problem, we have to deal with the rotations within the current recursive step, 
in such a way that we don't need to know the orientation of the prior square 
to know the order in which to visit the squares - it is always southwest, northwest, notheast, southwest.</p>
<p>After we split the squares into quadrants, 
after we toss out any quadrants with no points, 
we walk through each of the four quadrants in order 
(southwest, northwest, northeast, southwest).
If there is a single point in the quadrant,
we add it to the priority queue.</p>
<p>It is here that we take care of the rotation - 
before we recursively call the Hilbert sort method
on the quadrant itself.</p>
<p><a name="hilbert2-scaling"></a></p>
<h2>Scaling</h2>
<p>We have a prescribed order for the four quadrants 
in the current recursive level, and the current recursive level
is working its way through each of those four quadrants.
But remember, our algorithm only cares about the order of points.
It does not care about the <span class="math">\((x,y)\)</span> location. 
So we can ireflect <span class="math">\((x,y)\)</span> points by changing their 
<span class="math">\((x,y)\)</span> coordinate locations. Ultimately
we are only changing the program's internal representation
of each point, not the original data on disk, 
so we can think of <span class="math">\((x,y)\)</span> as mutable for our purposes.</p>
<p>This is an important part of our solution:
scaling (and reflecting) each quadrant before 
recursively calling the Hilbert sort method 
on the points contained in it.</p>
<p>If we are considering a single quadrant 
of dimensions <span class="math">\(\frac{S}{2} \times \frac{S}{2}\)</span>,
containing points <span class="math">\((x,y)\)</span>, we may be able to 
pass in the corners of our square, plus the 
<span class="math">\((x,y)\)</span> points contained in it.
However, as our squares get smaller,
the distance between points gets smaller as well,
so this has an upper limit as to how many points 
it can sort.</p>
<p>On the other hand, we can avoid passing all that information around
and using doubles, by just rescaling everything to the given
quadrant. We want each recursive level to completely forget 
about where in the recursive stack it is, how large its square is
relative to the original, etc. All it should be doing is 
solving the same problem repeatedly - which is what recursion
is best at. If we double the sides of the square, we get 
a shape with original size <span class="math">\(S \times S\)</span>. To keep the points 
shifted correctly we double their <span class="math">\((x,y)\)</span> coordinates 
to <span class="math">\((2x, 2y)\)</span>.</p>
<p>Once this transformation is performed, we are ready to call
the Hilbert Sort function recursively - for the 
northwest and northeast quadrants only. The southwest and 
southeast quadrants still have a ways to go.</p>
<p><a name="hilbert2-reflection"></a></p>
<h2>Reflection</h2>
<p>In addition to the scale-up transformation, southwest and southeast 
qaudrant points must be reflected about their diagonals.</p>
<p>Here's an example of what the process looks like in action:</p>
<p><img alt="Hilbert Sort Poster Flowchart" src="/images/hilbert-poster.png"></p>
<p><a name="hilbert2-reflection-solution"></a></p>
<h1>Solving the Reflection Problem</h1>
<p>The above section described where in the process the reflection 
of the <span class="math">\((x,y)\)</span> points should happen. The process of applying the 
reflection differs between the southwest and southeast quadrants.</p>
<p>In the southwest quadrant, points are being reflected about the 
diagonal line <span class="math">\(y=x\)</span>, so the reflection of <span class="math">\((x,y)\)</span> points in the 
southwest quadrant can be performed by swapping the 
<span class="math">\(x\)</span> and <span class="math">\(y\)</span> values of all of the points in that quadrant.</p>
<p>In the southeast quadrant, the points are refelected about the 
diagonal <span class="math">\(y = -x\)</span>, but it is not quite <span class="math">\(y = -x\)</span>, given that there is
an offset of a half-quadrant width on the left. </p>
<p>After an <span class="math">\((x,y)\)</span> point is transformed, it has a height equal to
the distance from the point's x coordinate to the start of the qudarant.
In equations,</p>
<div class="math">$$
y = S - x
$$</div>
<p>Further, after an <span class="math">\((x,y)\)</span> point is transformed, the distance from the 
top of the bounding box to the former y coordinate 
is the new x coordinate, </p>
<div class="math">$$
x = \frac{S}{2} - y
$$</div>
<p>The relative x coordinates of each point 
(relative meaning, 0 starts at the beginning of the curent square,
rather than the whole square) are 
the x coordinates minus the half-quadrant width.</p>
<p>Once these reflections are performed, we pass the 
resulting <span class="math">\((x,y)\)</span> points on to a new Hilbert sort.
The new Hilbert sort will be operating on an <span class="math">\(S x S\)</span> 
square, as before. Importantly, the <span class="math">\((x,y)\)</span> points have been
transformed in such a way that the order in which the Hilbert
curve visits each point has not been affected.</p>
<p><a name="hilbert2-procedure"></a></p>
<h1>Hilbert Sort Procedure</h1>
<p>The implementation strategy is, obviously, recursive. What we want to do at each level is:
<em> Start with a square and points contained in the square. 
</em> Cut the square under consideration into four quadrants.
* Apply a transformation to each square so that it is re-oriented in a manner that matches our original Hilbert curve.</p>
<p>Once each of those squares goes through all of its respective recursive calls, 
it will return a sorted list of points. Then we will know what to do - 
we collect each of the sorted points from each of the four quadrants in order, 
maintain that order, and return those sorted quadrants.</p>
<p>To nail down the details, treat the square under consideration as ranging from 
<span class="math">\((0,0)\)</span> to <span class="math">\((S,S)\)</span>.</p>
<p>Each time we cut a square into quadrants, we re-orient ourselves as to where 
<span class="math">\((0,0)\)</span> is located and which quadrants will be visited in which order.
If we are in the lower left quadrant, <span class="math">\(x\)</span> is below <span class="math">\(\frac{S}{2}\)</span> and 
<span class="math">\(y\)</span> is below <span class="math">\(\frac{S}{2}\)</span>, so we rotate and reflect by swapping x and y:</p>
<div class="highlight"><pre><span></span>        X -&gt; Y
        Y -&gt; X
</pre></div>


<p>If we are in the upper left quadrant, x is below <span class="math">\(\frac{S}{2}\)</span>, y is above <span class="math">\(\frac{S}{2}\)</span>, 
so subtract <span class="math">\(\frac{S}{2}\)</span> from y and we're done.</p>
<div class="highlight"><pre><span></span>        X -&gt; X
        Y -&gt; Y-(S/2)
</pre></div>


<p>If we are in the upper right quadrant, x is above <span class="math">\(\frac{S}{2}\)</span>, y is above <span class="math">\(\frac{S}{2}\)</span>, 
so subtract <span class="math">\(\frac{S}{2}\)</span> from both</p>
<div class="highlight"><pre><span></span>        X -&gt; X - S/2
        Y -&gt; Y - S/2
</pre></div>


<p>If we are in the lower right quadrant, our x and y values are now 
relative to the quadrant bounding box. The distance to the top of the 
bounding box to the y coordinate becomes our new x coordinate, while the 
distance from the right of the bounding box S to the x coordinate becomes 
our new y coordinate:</p>
<div class="highlight"><pre><span></span>        X -&gt; S/2 - Y
        Y -&gt; S - X
</pre></div>


<p>Recursion always requires a base case and a recursive case. Our "base case" is the 
simple comparison of one or no points in each of our four quadrants. If we get to 
this base case, we know the order in which the Hilbert Curve will visit each of 
those points.</p>
<p>If we are not at the base case, if we have a large number of points to sort, 
we can bin together all the points in a given quadrant, and consider the order
in which those points go with an additional level of finer granularity. </p>
<p><a name="hilbert2-pseudocode"></a></p>
<h1>Pseudocode</h1>
<div class="highlight"><pre><span></span>set square dimension S

create unsorted queue
load points into unsorted queue

create sorted queue
sorted queue = hilbert_sort( unsorted queue, square dimension )
</pre></div>


<p>Now here is the Hilbert sort function:</p>
<div class="highlight"><pre><span></span>define hilbert_sort( unsorted queue, square dimension ):
    create southwest queue
    create northwest queue
    create northeast queue
    create southeast queue
    for each point:
        if in southwest:
            create new point using X -&gt; Y, Y -&gt; X
            add to southwest queue
        if in northwest:
            create new point using X -&gt; 2X, Y -&gt; 2Y - S
            add to northwest queue
        if in northeast:
            create new point using X -&gt; 2X - S, Y -&gt; 2Y - S
            add to northeast queue
        if in southeast:
            create new point using X -&gt; S - 2Y, Y -&gt; 2S - 2X
            add to southeast queue

        hilbertsort(southwest queue, square dimension)
        hilbertsort(northwest queue, square dimension)
        hilbertsort(northeast queue, square dimension)
        hilbertsort(southeast queue, square dimension)

        create new results queue
        add points from southwest into results queue
        add points from northwest into results queue
        add points from northeast into results queue
        add points from southeast into results queue
        return results queue
</pre></div>


<p><a name="hilbert2-refs"></a></p>
<h1>References</h1>
<ol>
<li>
<p>"ACM Pacific Region Programming Competition." Association of Computing Machinery. Accessed 19 June 2017.
&lt;<a href="http://acmicpc-pacnw.org/">http://acmicpc-pacnw.org/</a>&gt;</p>
</li>
<li>
<p>"Über die stetige Abbildung einer Linie auf ein Flächenstück." D. Hilbert. 
<strong>Mathematische Annalen</strong> 38 (1891), 459–460. <a href="/files/HilbertCurve.pdf">(pdf)</a></p>
</li>
<li>
<p>"Hilbert Curve." Wikipedia: The Free Encyclopedia. Wikimedia Foundation. Edited 29 April 2017. Accessed 23 June 2017.
&lt;<a href="https://en.wikipedia.org/wiki/Hilbert_curve">https://en.wikipedia.org/wiki/Hilbert_curve</a>&gt;</p>
</li>
</ol>
<script type="text/javascript">if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width < 768) ? "left" : align;
        indent = (screen.width < 768) ? "0em" : indent;
        linebreak = (screen.width < 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
</script></div>

    </div>
</div>

<div class="v20"></div>

<div class="row">
    <div class="col-md-12" style="text-align: left;">

        <div class="tags">
            <p>Tags:&nbsp;&nbsp;&nbsp;
                    <a href="/tag/programming.html">programming</a>
                    &nbsp;&nbsp;
                    <a href="/tag/computer-science.html">computer science</a>
                    &nbsp;&nbsp;
                    <a href="/tag/final-project.html">final project</a>
                    &nbsp;&nbsp;
                    <a href="/tag/competitive-programming.html">competitive programming</a>
                    &nbsp;&nbsp;
                    <a href="/tag/hilbert-sort.html">hilbert sort</a>
                    &nbsp;&nbsp;
        </div>

    </div>
</div>


<div class="v200"></div>

</div>


<script type="text/javascript" src="/theme/js/jquery-1.11.2.js"></script>
<script type="text/javascript" src="/theme/js/bootstrap-3.3.4.js"></script>
<script type="text/javascript" src="/theme/js/d3-3.5.5.js"></script><script type="text/javascript" src="/theme/js/jquery-1.11.2.js"></script>
<script type="text/javascript" src="/theme/js/bootstrap-3.3.4.js"></script>

<footer id="contentinfo" class="body">
<p>&nbsp;</p>
<p>&nbsp;</p>
<center>
	<hr />
</center>
<p>&nbsp;</p>
<p style="text-align: center">
    <span class="fa-stack fa-lg">
        <i class="fa fa-square fa-stack-2x" style="color:#000;"></i>
        <i class="fa fa-terminal fa-stack-1x fa-inverse"></i>
    </span>
    Made from the command line with vim by 
    <a href="http://charlesreid1.com">charlesreid1</a><br />
    with help from <a href="https://getbootstrap.com/">Bootstrap</a> and <a href="http://getpelican.com">Pelican</a>.
</p>

<br />

<p style="text-align: center">
    <a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/">
    <span class="fa-stack fa-lg">
        <i class="fa fa-square fa-stack-2x" style="color:#000;"></i>
        <i class="fa fa-creative-commons fa-stack-1x fa-inverse"></i>
    </span>
    </a>
    <br />
    Licensed under the <a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/">Creative Commons Attribution-NonCommercial 4.0 License</a>.
</p>

<!-- Start of StatCounter Code for Default Guide -->
<script type="text/javascript">
var sc_project=11611748;
var sc_invisible=1;
var sc_security="9fcba820";
</script>
<script type="text/javascript"
src="https://www.statcounter.com/counter/counter.js"
async></script>

<noscript><div class="statcounter"><a title="Web Analytics"
href="http://statcounter.com/" target="_blank"><img
class="statcounter"
src="//c.statcounter.com/11611748/0/9fcba820/1/" alt="Web
Analytics"></a></div></noscript>
<!-- End of StatCounter Code for Default Guide -->
</footer><!-- /#contentinfo -->
</body>
</html>