<!DOCTYPE html>
<html lang="en">
<head>
        <title>charlesreid1</title>
        <meta charset="utf-8" />

        <!--
        CSS styles
        -->
        <link href="https://charlesreid1.github.io/theme/css/bootstrap.css"       rel="stylesheet" type="text/css">
        <link href="https://charlesreid1.github.io/theme/css/slate.css"              rel="stylesheet" type="text/css">
        <link href="https://charlesreid1.github.io/theme/css/font-awesome.css"       rel="stylesheet" type="text/css"/>
        <link href="https://charlesreid1.github.io/theme/css/pygment-solarized.css"  rel="stylesheet" type="text/css"/>

        <!--
        my CSS styles
        -->
        <link href="https://charlesreid1.github.io/theme/css/main.css"            rel="stylesheet" type="text/css">
        <link href="https://charlesreid1.github.io/theme/css/dox.css"             rel="stylesheet" type="text/css">


        <!--
        include Angular first
        -->
        <script type="text/javascript" src="https://charlesreid1.github.io/theme/js/angular-1.3.15.js"></script>
        <script type="text/javascript" src="https://charlesreid1.github.io/theme/js/skrollr-0.6.29.js"></script>
        <script type="text/javascript" src="https://charlesreid1.github.io/theme/js/d3-3.5.5.js"></script>

        <!--
        this seems like a bad idea.
        but if I don't put jquery first, I get errors about unrecognized $s.
        -->
        <script type="text/javascript" src="https://charlesreid1.github.io/theme/js/jquery-1.11.2.js"></script>

</head>
<body id="index">
<nav class="navbar navbar-default">
    <div class="container-fluid">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#myNavbar">
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span> 
            </button>
            <a href="https://charlesreid1.github.io" class="navbar-brand">charlesreid1.github.io</a>
        </div>
        <div>
            <div class="collapse navbar-collapse" id="myNavbar">
                <ul class="nav navbar-nav">

                    <li>
                        <a href="https://charlesreid1.com/wiki">Wiki</a>
                    </li>
                    <li>
                        <a href="https://git.charlesreid1.com/explore">Git</a>
                    </li>
                    <li>
                        <a href="http://spotify.charlesreid1.com">Music</a>
                    </li>
                    <li>
                        <a href="https://charlesreid1.com/life">Life</a>
                    </li>
                    <li>
                        <a href="https://charlesreid1.github.io">Blog</a>
                    </li>
                    <li>
                        <a href="https://charlesreid1.com/about">About Me</a>
                    </li>

                </ul>
            </div>
        </div>
    </div>
</nav>



<div class="container">

<header>
<div class="row">


    <div class="col-md-12">
        <div class="headtext" style="text-align: center;">
            <h1><b>
                Recursive Backtracking in Go for Bioinformatics Applications: 2. Generating Variations
            </b></h1>
        
            <p class="lead">
                Posted 
                <time datetime="2018-12-28T14:00:00-08:00" pubdate>Friday 12/28/2018</time>
                in 
                <a href="https://charlesreid1.github.io/category/computational-biology.html">Computational Biology</a>
                </p>
            <p>
            <span style="font-size: 14px">
                <a href="https://charlesreid1.github.io/recursive-backtracking-in-go-for-bioinformatics-applications-2-generating-variations.html">permalink</a>
            </span>
            </p>
        </div>

    </div>

</div>
</header>


<div class="v50"></div>


<div class="row">
    <div class="col-md-12" style="text-align: left;">

        <div class="entry-content"><p><em>This is the second in a series of three blog posts describing our
solution to a bioinformatics problem from Rosalind.info,
<a href="http://rosalind.info/problems/ba1i/">Problem BA1(i) (Find most frequent words with mismatches
in a string)</a>.
To solve this problem and generate variations of a DNA string
as required, we implemented a recursive backtracking method
in the Go programming language.</em></p>
<ul>
<li><em><a href="https://charlesreid1.github.io/recursive-backtracking-in-go-for-bioinformatics-applications-1-counting-variations.html">Part 1: Counting Variations</a></em></li>
<li><em>Part 2: Generating Variations (you are here)</em></li>
<li><em><a href="https://charlesreid1.github.io/recursive-backtracking-in-go-for-bioinformatics-applications-3-go-implementation-of-backtracking.html">Part 3: Go Implementation of Recursive Backtracking</a></em></li>
</ul>
<p><br />
<br /></p>
<p><a name="toc"></a></p>
<h2>Table of Contents</h2>
<ul>
<li><a href="#problem-descr">Problem Description</a></li>
<li><a href="#perms-combs-vars">Permutations vs Combinations vs Variations</a></li>
<li><a href="#recursion">Recursion</a><ul>
<li><a href="#backtracking">Recursive Backtracking Pseudocode</a></li>
</ul>
</li>
<li><a href="#dna">Appying to DNA Variations</a><ul>
<li><a href="#generating-visits">Generating Visits with Binary Numbers</a></li>
<li><a href="#assembling">Assembling the Variation</a></li>
</ul>
</li>
</ul>
<p><br />
<br /></p>
<p><a name="problem-descr"></a></p>
<h2>Problem Description</h2>
<p>The task at hand is to take a given input strand of DNA,
and generate variations from it that have up to <span class="math">\(d\)</span> differences
(a Hamming distance of <span class="math">\(d\)</span>) in the codons (base pairs).</p>
<p>In <a href="https://charlesreid1.github.io/recursive-backtracking-in-go-for-bioinformatics-applications-1-counting-variations.html">part 1 of this series</a>, we walk through the
construction of an analytical formula to count the number
of variations of a given DNA string that can be generated,
given the constraints of the problem.</p>
<p>In <a href="https://charlesreid1.github.io/recursive-backtracking-in-go-for-bioinformatics-applications-2-generating-variations.html">part 2 of this series</a>, we cover several techniques to
generate variations on a DNA string, and present pseudocode
for the recursive backtracking method that we use here.</p>
<p>In <a href="https://charlesreid1.github.io/recursive-backtracking-in-go-for-bioinformatics-applications-3-go-implementation-of-backtracking.html">part 3 of this series</a>, we will cover our implementation
of the recursive backtracking method in the Go programming
language.</p>
<p><a name="perms-combs-vars"></a></p>
<h2>Permutations vs Combinations vs Variations</h2>
<p>Before covering generation of variations of a DNA string,
we should cover some terminology for clarification.</p>
<p>If we were to use the term <em>permutations</em>, as in, we are
counting (or generating) <em>permutations</em> of the input DNA string, 
that would imply that we were doing some kind of
rearrangement of the elements of the input DNA string
(for example, swapping two codons). This is not the
problem that we are solving, and requires different
formulas. (See <a href="http://mathworld.wolfram.com/Permutation.html">Permutations</a>
entry on Wolfram MathWorld.)</p>
<p>The variations that we are referring to are not
exactly <em>combinations</em>, either, though. If we were
to use the term <em>combinations</em>, it would imply that
we were choosing a set of <span class="math">\(k\)</span> integers from a set
of <span class="math">\(d\)</span> integers <span class="math">\({1, 2, \dots, d}\)</span>.</p>
<p>The variations that we are counting are similar to
combinations, but with the additional act of swapping
out each codon at the position (integer) selected
with three other possible codons, so there are
more variations than combinations (and many
more permutations than variations).</p>
<p><a name="transform"></a></p>
<h2>Transforming the Problem Space</h2>
<p>A surprisingly large variety of problems in combinatorics 
can be transformed into an equivalent problem involving 
binary numbers, which are usually easier to think about.</p>
<p>To generate variations, we can break up the process of
producing a variation into two steps, or choices, and
then convert these choices (and the process of making them)
into an equivalent problem in terms of binary numbers.</p>
<p>We can decompose the cration of a DNA string variation into
the first step of choosing which codons (indices) to edit, 
and the second step of cycling through every possible codon 
(ATGC) at the selected indices.</p>
<p>To translate this into an equivalent binary number problem,
consider the input string of DNA "AAAAA" and let the Hamming
distance that we are considering be <span class="math">\(d = 1\)</span>. Then we can code
each index with a 0 (not chosen) or a 1 (chosen) and turn the
problem into cycling throgh all binary numbers with 1 bit:</p>
<div class="highlight"><pre><span></span><span class="mi">00001</span>
<span class="mi">00010</span>
<span class="mi">00100</span>
<span class="mi">01000</span>
<span class="mi">10000</span>
</pre></div>


<p>The second step is to cycle through each alternate codon at
the given position, so that <code>00001</code> would generate the 
variations:</p>
<div class="highlight"><pre><span></span><span class="n">AAAAC</span>
<span class="n">AAAAG</span>
<span class="n">AAAAT</span>
</pre></div>


<p>and so on.</p>
<p>We saw this two-part technique already when counting the total number of
variations that could be created in <a href="https://charlesreid1.github.io/recursive-backtracking-in-go-for-bioinformatics-applications-1-counting-variations.html">Part 1: Counting Variations</a>.
It resulted in a counting formula with two terms, a binomial term
for step 1 and an exponential term for step 2.</p>
<p>We can think of the problem as forming a tree with several
decision nodes that need to be explored; this type of problem
structure is ideal for a recursive backtracking algorithm.</p>
<p>We will cover the use of recursive backtracking to actually
explore the entire tree of possible outcomes (not just count
it), starting with some review and background on recursive 
backtracking and how it works.</p>
<p><a name="recursion"></a></p>
<h2>Recursion</h2>
<p>Recursion is a common pattern to use for problems that require
exploring a large problem space that requires us to make
several selections.</p>
<p>A recursive backtracking algorithm is analogous to exploring a
maze but laying out a rope as you go, so tht you can revisit
each possible route. In this case, we are using backtracking
to make the choice of which indices of the input DNA string
to modify. We want to explore all possible choices to generate
all possible variations of the input DNA string, and backtracking
gives us the framework to do that.</p>
<p>For example, if we wanted to recursively generate codon choices
for the case of an input DNA string like "AAAAA" and <span class="math">\(d = 2\)</span>,
we would call a recursive method twice; the first time through,
we would choose one of the five indices, and mark it as picked;
then we would call the method again, and choose a second index
(different from the first) and mark it as picked.</p>
<p>When unrolled, this is equivalent to a nested for loop,</p>
<div class="highlight"><pre><span></span><span class="k">for</span> <span class="nv">i</span> <span class="nv">in</span> <span class="nv">range</span><span class="ss">(</span> <span class="mi">0</span> .. <span class="nv">len</span><span class="ss">(</span><span class="nv">dna_string</span><span class="ss">)</span> <span class="ss">)</span>:
    <span class="k">for</span> <span class="nv">j</span> <span class="nv">in</span> <span class="nv">range</span><span class="ss">(</span> <span class="mi">0</span> .. <span class="nv">len</span><span class="ss">(</span><span class="nv">dna_string</span><span class="ss">)</span> <span class="ss">)</span>:
        <span class="k">if</span> <span class="ss">(</span><span class="nv">i</span> <span class="o">!=</span> <span class="nv">j</span><span class="ss">)</span>:
            <span class="nv">Start</span> <span class="nv">with</span> <span class="nv">the</span> <span class="nv">binary</span> <span class="nv">number</span> <span class="mi">00000</span>
            <span class="nv">Set</span> <span class="nv">the</span> <span class="nv">digit</span> <span class="nv">at</span> <span class="nv">index</span> <span class="nv">i</span> <span class="nv">to</span> <span class="mi">1</span>
            <span class="nv">Set</span> <span class="nv">the</span> <span class="nv">digit</span> <span class="nv">at</span> <span class="nv">index</span> <span class="nv">j</span> <span class="nv">to</span> <span class="mi">1</span>
</pre></div>


<p><a name="backtracking"></a></p>
<h3>Recursive Backtracking Pseudocode</h3>
<p>Basic pseudocode for a backtracking method:</p>
<div class="highlight"><pre><span></span><span class="nv">explore</span> <span class="nv">method</span>:
    <span class="nv">base</span> <span class="nv">case</span>:
        <span class="nv">visit</span> <span class="nv">this</span> <span class="nv">solution</span>
    <span class="nv">recursive</span> <span class="nv">case</span>:
        <span class="k">for</span> <span class="nv">each</span> <span class="nv">available</span> <span class="nv">choice</span>:
            <span class="nv">make</span> <span class="nv">a</span> <span class="nv">choice</span>
            <span class="nv">explore</span> <span class="nv">outcomes</span>
            <span class="nv">unmake</span> <span class="nv">the</span> <span class="nv">choice</span>
            <span class="nv">move</span> <span class="nv">on</span> <span class="nv">to</span> <span class="nv">the</span> <span class="k">next</span> <span class="nv">choice</span>
</pre></div>


<p><a name="dna"></a></p>
<h2>Applying to DNA Variations</h2>
<p>There are actually two places where we need to apply
backtracking to our problem.</p>
<p><a name="generating-visits"></a></p>
<h3>Generating Visits with Binary Numbers</h3>
<p>The first application of recursive backtracking is to
carry out step 1, choosing indices in the original
DNA string to modify or cycle through altnerate 
codons. We showed above how generating variations
on a kmer of length <span class="math">\(k\)</span> at a distance <span class="math">\(d\)</span> from the
original kmer was equivalent to generating binary 
numbers with <span class="math">\(d\)</span> bits set to 1.</p>
<p>We can use recursive backtracking to generate these
numbers. By creating a method that recursively selects
an index to switch to 1, and passing that (and all prior
choices) on to further recursive calls, the function
can recurse to a given depth <span class="math">\(d\)</span> and visit all possible
binary numbers with <span class="math">\(d\)</span> bits set to 1.</p>
<p>The base case of this recursive method would be reached
when all <span class="math">\(d\)</span> choices had been made and <span class="math">\(d\)</span> bits were 
set to 1. Then the choice of indices to swap out with
alternate codons would be passed on to a recursive method
that would carry out Step 2 (see below).</p>
<p>For example, to generate variations of the 5-mer <code>AAAAA</code>,
we would start by selecting a Hamming distance <span class="math">\(d\)</span>, then
generate a binary number with <span class="math">\(d\)</span> bits set to 1 to select
indices to modify. Suppose <span class="math">\(d = 2\)</span>; then the first few
binary numbers are:</p>
<div class="highlight"><pre><span></span><span class="n">AAAAA</span>
<span class="mi">11000</span>
<span class="mi">10100</span>
<span class="mi">10010</span>
<span class="mi">10001</span>
<span class="p">...</span>
</pre></div>


<p>To expand on the pseudocode a bit more, to generate a
binary number with <span class="math">\(d\)</span> bits flipped to 1 we will want
to call a recursive method with a depth of <span class="math">\(d\)</span>, making
a choice at each recursive call of which index to set
to 1 next.</p>
<p>The <span class="math">\(n^{th}\)</span> recursive call picks the <span class="math">\(n^{th}\)</span> index for
1. Each index can only be chosen once in the stack of 
recursive calls, and the indices that have been chosen
by prior recursive function calls are passed along.</p>
<p>Thus we need a minimum of two parameters: an integer
indicating the depth level of this recursive function
call, and an integer array of index choices.</p>
<div class="highlight"><pre><span></span><span class="nv">function</span> <span class="nv">generate_binary_numbers</span><span class="ss">(</span> <span class="nv">depth</span>, <span class="nv">choices</span>[], ... <span class="ss">)</span>:

    <span class="k">if</span> <span class="nv">depth</span> <span class="nv">is</span> <span class="mi">0</span>,
        <span class="nv">base</span> <span class="nv">case</span>
        <span class="nv">no</span> <span class="nv">more</span> <span class="nv">choices</span> <span class="nv">left</span> <span class="nv">to</span> <span class="nv">make</span>
        <span class="nv">choices</span>[] <span class="nv">is</span> <span class="nv">full</span>
        <span class="nv">pass</span> <span class="nv">along</span> <span class="nv">choices</span>[] <span class="nv">to</span> <span class="nv">assemble</span> <span class="nv">the</span> <span class="nv">variations</span>

    <span class="k">else</span>,
        <span class="nv">recursive</span> <span class="nv">case</span>
        <span class="k">for</span> <span class="nv">each</span> <span class="nv">possible</span> <span class="nv">index</span>,
            <span class="k">if</span> <span class="nv">this</span> <span class="nv">index</span> <span class="nv">is</span> <span class="nv">not</span> <span class="nv">already</span> <span class="nv">in</span> <span class="nv">choices</span>,
                <span class="nv">add</span> <span class="nv">this</span> <span class="nv">index</span> <span class="nv">to</span> <span class="nv">choices</span>
                <span class="nv">generate_binary_numbers</span><span class="ss">(</span> <span class="nv">depth</span><span class="o">+</span><span class="mi">1</span>, <span class="nv">choices</span>[] <span class="ss">)</span>
                <span class="nv">remove</span> <span class="nv">this</span> <span class="nv">index</span> <span class="nv">from</span> <span class="nv">choices</span>
</pre></div>


<p><a name="assembling"></a></p>
<h3>Assembling the Variation</h3>
<p>Each binary number is then turned into variations by substituting
every combination of 3 codons in every position with a 1
possible, so the first binary number for <span class="math">\(d=2\)</span> would generate
the variations:</p>
<div class="highlight"><pre><span></span><span class="n">AAAAA</span>
<span class="mi">11000</span>
<span class="c1">-----</span>
<span class="n">CCAAA</span>
<span class="n">GCAAA</span>
<span class="n">TCAAA</span>
<span class="n">CGAAA</span>
<span class="n">GGAAA</span>
<span class="n">TGAAA</span>
<span class="n">CTAAA</span>
<span class="n">GTAAA</span>
<span class="n">TTAAA</span>
</pre></div>


<p>This would be repeated for all Hamming distances up to the
maximum specified Hamming distance.</p>
<p>Like the generation of binary numbers, the substitution of all
possible combinations of codons at these positions is a
task conducive to a recursive backtracking algorithm.</p>
<p>Like the prior task's recursive method, this task's recursive 
method will have one parameter for depth (number of choices
left to make) and a range of choices to try (codons).</p>
<div class="highlight"><pre><span></span><span class="nv">function</span> <span class="nv">assemble_variations</span><span class="ss">(</span> <span class="nv">depth</span>, <span class="nv">choices</span>[], ... <span class="ss">)</span>:

    <span class="k">if</span> <span class="nv">depth</span> <span class="nv">is</span> <span class="mi">0</span>,
        <span class="nv">base</span> <span class="nv">case</span>
        <span class="nv">no</span> <span class="nv">more</span> <span class="nv">choices</span> <span class="nv">left</span> <span class="nv">to</span> <span class="nv">make</span>
        <span class="nv">choices</span>[] <span class="nv">is</span> <span class="nv">full</span>
        <span class="nv">pass</span> <span class="nv">along</span> <span class="nv">choices</span>[] <span class="nv">to</span> <span class="nv">assemble</span> <span class="nv">the</span> <span class="nv">variations</span>

    <span class="k">else</span>,
        <span class="nv">recursive</span> <span class="nv">case</span>
        <span class="k">for</span> <span class="nv">each</span> <span class="nv">possible</span> <span class="nv">index</span>,
            <span class="k">if</span> <span class="nv">this</span> <span class="nv">index</span> <span class="nv">is</span> <span class="nv">not</span> <span class="nv">already</span> <span class="nv">in</span> <span class="nv">choices</span>,
                <span class="nv">add</span> <span class="nv">this</span> <span class="nv">index</span> <span class="nv">to</span> <span class="nv">choices</span>
                <span class="nv">generate_binary_numbers</span><span class="ss">(</span> <span class="nv">depth</span><span class="o">+</span><span class="mi">1</span>, <span class="nv">choices</span>[] <span class="ss">)</span>
                <span class="nv">remove</span> <span class="nv">this</span> <span class="nv">index</span> <span class="nv">from</span> <span class="nv">choices</span>
</pre></div>


<p>In the final part, Part 3, of this blog post, we will cover the actual 
Go implementation of these functions.</p>
<script type="text/javascript">if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width < 768) ? "left" : align;
        indent = (screen.width < 768) ? "0em" : indent;
        linebreak = (screen.width < 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
</script></div>

    </div>
</div>

<div class="v20"></div>

<div class="row">
    <div class="col-md-12" style="text-align: left;">

        <div class="tags">
            <p>Tags:&nbsp;&nbsp;&nbsp;
                    <a href="https://charlesreid1.github.io/tag/go.html">go</a>
                    &nbsp;&nbsp;
                    <a href="https://charlesreid1.github.io/tag/golang.html">golang</a>
                    &nbsp;&nbsp;
                    <a href="https://charlesreid1.github.io/tag/rosalind.html">rosalind</a>
                    &nbsp;&nbsp;
                    <a href="https://charlesreid1.github.io/tag/bioinformatics.html">bioinformatics</a>
                    &nbsp;&nbsp;
                    <a href="https://charlesreid1.github.io/tag/recursion.html">recursion</a>
                    &nbsp;&nbsp;
                    <a href="https://charlesreid1.github.io/tag/backtracking.html">backtracking</a>
                    &nbsp;&nbsp;
                    <a href="https://charlesreid1.github.io/tag/strings.html">strings</a>
                    &nbsp;&nbsp;
                    <a href="https://charlesreid1.github.io/tag/combinatorics.html">combinatorics</a>
                    &nbsp;&nbsp;
        </div>

    </div>
</div>


<div class="v200"></div>

</div>


<script type="text/javascript" src="https://charlesreid1.github.io/theme/js/jquery-1.11.2.js"></script>
<script type="text/javascript" src="https://charlesreid1.github.io/theme/js/bootstrap-3.3.4.js"></script>
<script type="text/javascript" src="https://charlesreid1.github.io/theme/js/d3-3.5.5.js"></script><script type="text/javascript" src="https://charlesreid1.github.io/theme/js/jquery-1.11.2.js"></script>
<script type="text/javascript" src="https://charlesreid1.github.io/theme/js/bootstrap-3.3.4.js"></script>

<footer id="contentinfo" class="body">
<p>&nbsp;</p>
<p>&nbsp;</p>
<center>
	<hr />
</center>
<p>&nbsp;</p>
<p style="text-align: center">
    <span class="fa-stack fa-lg">
        <i class="fa fa-square fa-stack-2x" style="color:#000;"></i>
        <i class="fa fa-terminal fa-stack-1x fa-inverse"></i>
    </span>
    Made from the command line with vim by 
    <a href="http://charlesreid1.com">charlesreid1</a><br />
    with help from <a href="https://getbootstrap.com/">Bootstrap</a> and <a href="http://getpelican.com">Pelican</a>.
</p>

<br />

<p style="text-align: center">
    <a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/">
    <span class="fa-stack fa-lg">
        <i class="fa fa-square fa-stack-2x" style="color:#000;"></i>
        <i class="fa fa-creative-commons fa-stack-1x fa-inverse"></i>
    </span>
    </a>
    <br />
    Licensed under the <a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/">Creative Commons Attribution-NonCommercial 4.0 License</a>.
</p>

<!-- Start of StatCounter Code for Default Guide -->
<script type="text/javascript">
var sc_project=11611748;
var sc_invisible=1;
var sc_security="9fcba820";
</script>
<script type="text/javascript"
src="https://www.statcounter.com/counter/counter.js"
async></script>

<noscript><div class="statcounter"><a title="Web Analytics"
href="http://statcounter.com/" target="_blank"><img
class="statcounter"
src="//c.statcounter.com/11611748/0/9fcba820/1/" alt="Web
Analytics"></a></div></noscript>
<!-- End of StatCounter Code for Default Guide -->
</footer><!-- /#contentinfo -->
</body>
</html>