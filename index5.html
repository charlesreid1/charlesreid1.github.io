<!DOCTYPE html>
<html lang="en">
<head>
        <title>charlesreid1</title>
        <meta charset="utf-8" />

        <!--
        CSS styles
        -->
        <link href="/theme/css/bootstrap.css"       rel="stylesheet" type="text/css">
        <link href="/theme/css/slate.css"              rel="stylesheet" type="text/css">
        <link href="/theme/css/font-awesome.css"       rel="stylesheet" type="text/css"/>
        <link href="/theme/css/pygment-solarized.css"  rel="stylesheet" type="text/css"/>

        <!--
        my CSS styles
        -->
        <link href="/theme/css/main.css"            rel="stylesheet" type="text/css">
        <link href="/theme/css/dox.css"             rel="stylesheet" type="text/css">


        <!--
        include Angular first
        -->
        <script type="text/javascript" src="/theme/js/angular-1.3.15.js"></script>
        <script type="text/javascript" src="/theme/js/skrollr-0.6.29.js"></script>
        <script type="text/javascript" src="/theme/js/d3-3.5.5.js"></script>

        <!--
        this seems like a bad idea.
        but if I don't put jquery first, I get errors about unrecognized $s.
        -->
        <script type="text/javascript" src="/theme/js/jquery-1.11.2.js"></script>

</head>
<body id="index">
<nav class="navbar navbar-default">
    <div class="container-fluid">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#myNavbar">
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span> 
            </button>
            <a href="https://charlesreid1.github.io" class="navbar-brand">charlesreid1.github.io</a>
        </div>
        <div>
            <div class="collapse navbar-collapse" id="myNavbar">
                <ul class="nav navbar-nav">

                    <li>
                        <a href="https://charlesreid1.com/wiki">Wiki</a>
                    </li>
                    <li>
                        <a href="https://git.charlesreid1.com/explore">Git</a>
                    </li>
                    <li>
                        <a href="http://spotify.charlesreid1.com">Music</a>
                    </li>
                    <li>
                        <a href="https://charlesreid1.com/life">Life</a>
                    </li>
                    <li>
                        <a href="https://charlesreid1.github.io">Blog</a>
                    </li>
                    <li>
                        <a href="https://charlesreid1.com/about">About Me</a>
                    </li>

                </ul>
            </div>
        </div>
    </div>
</nav>



<div class="container">

    <div class="row">
        <div class="col-md-12 col-centered" style="text-align: center;">
            <div class="v50"></div>
            <div class="cosmojumbo">
                <h1 class="jumbojumbo">charlesreid1.com blog<h1>
            </div>
        </div>
    </div>


    <div class="v50"></div>


    <div class="row">

        <div class="col-md-8" style="text-align: center;">

  	            	<article>
<header>
<div class="row">


    <div class="col-md-12">
        <div class="headtext" style="text-align: center;">
            <h1><b>
                4x4 Rubik's Cube: Part 2: Permutations
            </b></h1>
        
            <p class="lead">
                Posted 
                <time datetime="2018-01-14T20:00:00-08:00" pubdate>Sunday 01/14/2018</time>
                in 
                <a href="/category/rubiks-cube.html">Rubiks Cube</a>
                </p>
            <p>
            <span style="font-size: 14px">
                <a href="/4x4-rubiks-cube-part-2-permutations.html">permalink</a>
            </span>
            </p>
        </div>

    </div>

</div>
</header>


<div class="v50"></div>


<div class="row">
    <div class="col-md-12" style="text-align: left;">

        <div class="entry-content"><p><em>This is Part 2 of a 4-part blog post 
on the mathematics of the 4x4 Rubik's Cube, 
its relation to algorithms, and some 
curious properties of Rubik's Cubes.</em></p>
<p>See Part 1 of this blog post here: <a href="https://charlesreid1.github.io/4x4-rubiks-cube-part-1-representations.html">Part 1: Representations</a></p>
<p>You are currently reading Part 2 of this blog post: <strong>Part 2: Permutations</strong></p>
<p>See Part 3 of this blog post here: <a href="https://charlesreid1.github.io/4x4-rubiks-cube-part-3-factoring-permutations.html">Part 3: Factoring Permutations</a></p>
<p>See Part 4 of this blog post here: <a href="#">Part 4: Sequence Order</a></p>
<h1>Table of Contents</h1>
<ul>
<li>
<p><a href="#rubiks2-intro">Introduction: Sequences and Permutations</a></p>
</li>
<li>
<p><a href="#rubiks2-representing">Representing Permutations: Two-Row Notation</a></p>
<ul>
<li><a href="#rubiks2-representing-tworow">Two-Row Notation</a></li>
<li><a href="#rubiks2-representing-tworow-rubiks">Two-Row Notation for Rubik's Cube</a></li>
</ul>
</li>
<li>
<p><a href="#rubiks2-sequences">Sequences</a></p>
<ul>
<li><a href="#rubiks2-sequences-review">Review of Move/Sequence Notation</a></li>
<li><a href="#rubiks2-sequences-permute-cube">How Moves Permute the Cube</a></li>
</ul>
</li>
<li>
<p><a href="#rubiks2-maps">Rotation Maps</a></p>
<ul>
<li><a href="#rubiks2-maps-u">U Rotation Map</a></li>
<li><a href="#rubiks2-maps-d">D Rotation Map</a></li>
<li><a href="#rubiks2-maps-l">L Rotation Map</a></li>
<li><a href="#rubiks2-maps-r">R Rotation Map</a></li>
<li><a href="#rubiks2-maps-f">F Rotation Map</a></li>
<li><a href="#rubiks2-maps-b">B Rotation Map</a></li>
<li><a href="#rubiks2-maps-rotation">How to Use Rotation Map</a></li>
<li><a href="#rubiks2-maps-code">Face Map Code</a></li>
</ul>
</li>
<li>
<p><a href="#rubiks2-tuples">Tuples for Move Sequences</a></p>
<ul>
<li><a href="#rubiks2-tuples-sequences">Applying Rotation Maps for Sequences</a></li>
</ul>
</li>
<li>
<p><a href="#rubiks2-preview">Preview of Part 3</a></p>
</li>
<li>
<p><a href="#rubiks2-references">References</a></p>
</li>
<li>
<p><a href="#rubiks2-appendix">Appendix: Cube with Numbered Faces</a></p>
</li>
</ul>
<p><br />
<br />
<br /></p>
<p><a name="rubiks2-intro"></a></p>
<h1>Introduction</h1>
<p>In this post, we'll be connecting material from Part 1, about 
how to represent the state of the cube in a mathematical way,
to the ultimate goal of exploring properties of particular
move sequences.</p>
<p>In paticular, we'll expand on the tuple notation from Part 1,
and demonstrate the two-row permutation notation of Knuth.
This notation is useful for representing permutations 
in a way that makes it possible to create a system for 
describing permutations using algebra.</p>
<p>We will not discuss the aim of representing permutations
in this way in the present post, but this will be 
described in Part 3.</p>
<p>Next, we discuss move sequences on the Rubik's Cube - 
these are sequences of rotations of particular faces
on the Rubik's Cube. We discuss the application of the 
two-row permutation notation to describe moves
and to describe move sequences.</p>
<p>Finally, we discuss rotation maps, a useful concept
in the implementation of permutations via move sequences.</p>
<p><a name="rubiks2-representing"></a></p>
<h1>Representing Permutations: Two-Row Notation</h1>
<p>We begin by expanding on and streamlining the tuple notation
introduced in Part 1 of this post so that we have a common
basis for comparing two permutations. We do this using a two-row
notation, where the first row denotes the "solved" or default 
state of the system.</p>
<p>In the case of the Rubik's Cube, this is equivalent to 
starting a cube in the solved state, then describing where
each face ends up, in order to completely specify 
the outcome of a move or a sequence of moves.</p>
<p><a name="rubiks2-representing-tworow"></a></p>
<h2>Two-Row Notation</h2>
<p>We begin by considering a permutation of an <span class="math">\(n\)</span>-tuple,
which, in the last post, we resolved to denote </p>
<div class="math">$$
(2 3 4 \dots n 1)
$$</div>
<p>Now, let us write this as two rows: the first row
consists of each element of the tuple <em>in ascending 
order</em>, while the second line will the tuple corresponding
to the order of the elements in this particular permutation:</p>
<div class="math">$$
a = \bigl(\begin{smallmatrix}
  1 &amp; 2 &amp; 3 &amp; \cdots &amp; n-1 &amp; n \\
  2 &amp; 3 &amp; 4 &amp; \cdots &amp;  n  &amp; 1
\end{smallmatrix}\bigr)
$$</div>
<p>We can think of the first row as denoting the "solved", 
default configuration, and the second row denoting how 
each item is permuted.</p>
<p>If we had a different permutation, we would simply change
the second row:</p>
<div class="math">$$
b = \bigl(\begin{smallmatrix}
  1 &amp; 2 &amp; 3 &amp; \cdots &amp; n-1 &amp; n \\
  n &amp; 4 &amp; 1 &amp; \cdots &amp; 2   &amp; 3
\end{smallmatrix}\bigr)
$$</div>
<p><a name="rubiks2-representing-tworow-rubiks"></a></p>
<h2>Two-Row Notation for Rubik's Cube</h2>
<p>If we adopt the above two-row notation for the Rubik's Cube,
and we utilize the face numbering and tuple indexing from Part 1,
the top row consists of the integers from 1 to 96:</p>
<div class="highlight"><pre><span></span>(1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96)
</pre></div>


<p>Now suppose we perform a rotation of the upper row U on the cube.
Then we end up with the following tuple:</p>
<div class="highlight"><pre><span></span>(13 9 5 1 14 10 6 2 15 11 7 3 16 12 8 4 33 34 35 36 21 22 23 24 25 26 27 28 29 30 31 32 49 50 51 52 37 38 39 40 41 42 43 44 45 46 47 48 65 66 67 68 53 54 55 56 57 58 59 60 61 62 63 64 17 18 19 20 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96)
</pre></div>


<p>This tuple denotes the permutation corresponding to the move U 
performed on a solved cube.</p>
<p><a name="rubiks2-sequences"></a></p>
<h1>Sequences</h1>
<p><a name="rubiks2-sequences-review"></a></p>
<h2>Review of Move/Sequence Notation</h2>
<p>Let's quickly recap what we already know from prior posts about the 
properties of move sequences on the Rubik's Cube.</p>
<p>There are 36 possible moves on a cube, and a series of 
moves applied in a particular order defines a sequence.
The 36 possible rotations were given in the prior blog post
and cover clockwise and counterclockwise rotations of 
each of the six faces - either the first layer, the second layer,
or both of the first two layers.</p>
<p>These moves are denoted with six letters (<code>UDLRFB</code>) for the upper,
downward, left, right, front, and back face of the cube, respectively.</p>
<p>Moves indicated should be clockwise unless they contain an apostrophe
character <code>'</code>, which indicates counterclockwise rotation.</p>
<p>A capital letter indicates a rotation of the first layer only 
(e.g., <code>U</code> indicates a clockwise rotation of the first layer of 
the upper face).</p>
<p>A lowercase letter indicates a roration of the first and second layers
(e.g., <code>r</code> indicates a clockwise rotation of the top two layers of
the right face).</p>
<p>A 2 before the letter indicates that the second layer should be rotated
(e.g., <code>2F</code> indicates a clockwise rotation of the second layer of the 
front face).</p>
<p><a name="rubiks2-sequences-permute-cube"></a></p>
<h2>How Moves Permute the Cube</h2>
<p>This will be a little easier to understand if we consider 
a particular move sequence. We'll start simple and consider 
the move sequence <code>U</code>. This results, as we saw before, in:</p>
<div class="highlight"><pre><span></span>U:
(1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96)
(13 9 5 1 14 10 6 2 15 11 7 3 16 12 8 4 33 34 35 36 21 22 23 24 25 26 27 28 29 30 31 32 49 50 51 52 37 38 39 40 41 42 43 44 45 46 47 48 65 66 67 68 53 54 55 56 57 58 59 60 61 62 63 64 17 18 19 20 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96)
</pre></div>


<p>Now let's consider the move sequence <code>U U</code>, a double rotation of the 
cube's top layer:</p>
<div class="highlight"><pre><span></span>U U:
(1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96)
(16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 49 50 51 52 21 22 23 24 25 26 27 28 29 30 31 32 65 66 67 68 37 38 39 40 41 42 43 44 45 46 47 48 17 18 19 20 53 54 55 56 57 58 59 60 61 62 63 64 33 34 35 36 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96)
</pre></div>


<p>Third, we consider the move sequence <code>U U U</code>, equivalent to <code>U'</code>,
a counterclockwise rotation of the top layer:</p>
<div class="highlight"><pre><span></span>U U U:
(1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96)
(4 8 12 16 3 7 11 15 2 6 10 14 1 5 9 13 65 66 67 68 21 22 23 24 25 26 27 28 29 30 31 32 17 18 19 20 37 38 39 40 41 42 43 44 45 46 47 48 33 34 35 36 53 54 55 56 57 58 59 60 61 62 63 64 49 50 51 52 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96)
</pre></div>


<p>The fourth application of <code>U</code>, of course, will return the cube back to its 
solved state:</p>
<div class="highlight"><pre><span></span>U U U:
(1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96)
(1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96)
</pre></div>


<p>Now if we examine the relationship between each of these tuples, 
we see that the faces are exchanged according to specific patterns.</p>
<p>These groups of four numbered faces are exchanged with one another:</p>
<div class="highlight"><pre><span></span>( 4, 16, 13,  1)
( 8, 15,  9,  2)
(12, 14,  5,  3)
( 7, 11, 10,  6)
(65, 49, 33, 17) 
(66, 50, 34, 18)
(67, 51, 35, 19)
(68, 52, 36, 20)
</pre></div>


<p>There are 8 total faces, composing one upper quadrant of the face
being rotated.</p>
<p>The remaining 64 faces do not move:</p>
<div class="highlight"><pre><span></span>(21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96)
</pre></div>


<p><a name="rubiks2-maps"></a></p>
<h1>Rotation Maps</h1>
<p>While the 96-tuple representation is useful, a better computational
representation of the tuple is a rotation map, which consists of 
2-tuples of face index numbers that are permuted. For example,
the tuple <span class="math">\((4,16)\)</span> would indicate that the position at face 4
would become face 16 after the rotation.</p>
<p>As a reminder, here is the solved cube's face index layout:</p>
<div class="highlight"><pre><span></span>             01 02 03 04
             05 06 07 08
             09 10 11 12
             13 14 15 16

17 18 19 20  33 34 35 36  49 50 51 52  65 66 67 68
21 22 23 24  37 38 39 40  53 54 55 56  69 70 71 72
25 26 27 28  41 42 43 44  57 58 59 60  73 74 75 76
29 30 31 32  45 46 47 48  61 62 63 64  77 78 79 80

             81 82 83 84
             85 86 87 88
             89 90 91 92
             93 94 95 96
</pre></div>


<p>Thus, the rotation map representation of each move would be:</p>
<p><a name="rubiks2-maps-u"></a></p>
<h2>U Rotation Map</h2>
<p>Upon a U rotation, the face 1 will become face 13, indicated by (1,13).</p>
<div class="highlight"><pre><span></span>U:
---------------------
[(1, 13),
 (2, 9),
 (3, 5),
 (4, 1),
 (5, 14),
 (6, 10),
 (7, 6),
 (8, 2),
 (9, 15),
 (10, 11),
 (11, 7),
 (12, 3),
 (13, 16),
 (14, 12),
 (15, 8),
 (16, 4),
 (17, 33),
 (18, 34),
 (19, 35),
 (20, 36),
 (33, 49),
 (34, 50),
 (35, 51),
 (36, 52),
 (49, 65),
 (50, 66),
 (51, 67),
 (52, 68),
 (65, 17),
 (66, 18),
 (67, 19),
 (68, 20)]
</pre></div>


<p><a name="rubiks2-maps-d"></a></p>
<h2>D Rotation Map</h2>
<div class="highlight"><pre><span></span>D:
----------------------------------------
[(81, 93),
 (82, 89),
 (83, 85),
 (84, 81),
 (85, 94),
 (86, 90),
 (87, 86),
 (88, 82),
 (89, 95),
 (90, 91),
 (91, 87),
 (92, 83),
 (93, 96),
 (94, 92),
 (95, 88),
 (96, 84),
 (29, 77),
 (30, 78),
 (31, 79),
 (32, 80),
 (45, 29),
 (46, 30),
 (47, 31),
 (48, 32),
 (61, 45),
 (62, 46),
 (63, 47),
 (64, 48),
 (77, 61),
 (78, 62),
 (79, 63),
 (80, 64)]
</pre></div>


<p><a name="rubiks2-maps-l"></a></p>
<h2>L Rotation Map</h2>
<div class="highlight"><pre><span></span>L:
----------------------------------------
[(17, 29),
 (18, 25),
 (19, 21),
 (20, 17),
 (21, 30),
 (22, 26),
 (23, 22),
 (24, 18),
 (25, 31),
 (26, 27),
 (27, 23),
 (28, 19),
 (29, 32),
 (30, 28),
 (31, 24),
 (32, 20),
 (1, 80),
 (5, 76),
 (9, 72),
 (13, 68),
 (33, 1),
 (37, 5),
 (41, 9),
 (45, 13),
 (81, 33),
 (85, 37),
 (89, 41),
 (93, 45),
 (68, 93),
 (72, 89),
 (76, 85),
 (80, 81)]
</pre></div>


<p><a name="rubiks2-maps-r"></a></p>
<h2>R Rotation Map</h2>
<div class="highlight"><pre><span></span> R:
----------------------------------------
[(49, 61),
 (50, 57),
 (51, 53),
 (52, 49),
 (53, 62),
 (54, 58),
 (55, 54),
 (56, 50),
 (57, 63),
 (58, 59),
 (59, 55),
 (60, 51),
 (61, 64),
 (62, 60),
 (63, 56),
 (64, 52),
 (4, 36),
 (8, 40),
 (12, 44),
 (16, 48),
 (36, 84),
 (40, 88),
 (44, 92),
 (48, 96),
 (84, 77),
 (88, 73),
 (92, 69),
 (96, 65),
 (65, 16),
 (69, 12),
 (73, 8),
 (77, 4)]
</pre></div>


<p><a name="rubiks2-maps-f"></a></p>
<h2>F Rotation Map</h2>
<div class="highlight"><pre><span></span> F:
----------------------------------------
[(33, 45),
 (34, 41),
 (35, 37),
 (36, 33),
 (37, 46),
 (38, 42),
 (39, 38),
 (40, 34),
 (41, 47),
 (42, 43),
 (43, 39),
 (44, 35),
 (45, 48),
 (46, 44),
 (47, 40),
 (48, 36),
 (13, 32),
 (14, 28),
 (15, 24),
 (16, 20),
 (20, 81),
 (24, 82),
 (28, 83),
 (32, 84),
 (81, 61),
 (82, 57),
 (83, 53),
 (84, 49),
 (49, 13),
 (53, 14),
 (57, 15),
 (61, 16)]
</pre></div>


<p><a name="rubiks2-maps-b"></a></p>
<h2>B Rotation Map</h2>
<div class="highlight"><pre><span></span> B:
----------------------------------------
[(65, 77),
 (66, 73),
 (67, 69),
 (68, 65),
 (69, 78),
 (70, 74),
 (71, 70),
 (72, 66),
 (73, 79),
 (74, 75),
 (75, 71),
 (76, 67),
 (77, 80),
 (78, 76),
 (79, 72),
 (80, 68),
 (1, 52),
 (2, 56),
 (3, 60),
 (4, 64),
 (17, 4),
 (21, 3),
 (25, 2),
 (29, 1),
 (93, 17),
 (94, 21),
 (95, 25),
 (96, 29),
 (52, 96),
 (56, 95),
 (60, 94),
 (64, 93)]
</pre></div>


<p><a name="rubiks2-maps-rotation"></a></p>
<h2>How To Use Rotation Map</h2>
<p>The rotation map enables us to represent a 4x4 Rubik's Cube
as a simple tuple, and just use a Rubik's Cube object from the 
<a href="https://git.charlesreid1.com/charlesreid1/rubiks-cube-nnn-solver">forked rubikscubesolver library</a>
at git.charlesreid1.com to get the rotation maps.</p>
<div class="highlight"><pre><span></span><span class="c1"># Python code:</span>
<span class="n">cube0</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">96</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
<span class="n">cube1</span> <span class="o">=</span> <span class="n">cube0</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="n">cube_prior</span> <span class="o">=</span> <span class="n">cube0</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="n">r</span> <span class="o">=</span> <span class="n">get_cube</span><span class="p">()</span>

<span class="k">for</span> <span class="n">c</span><span class="p">,</span><span class="n">move</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">rot</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">)):</span>

    <span class="c1"># Get the rotation map</span>
    <span class="n">rotmap</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">rotation_map</span><span class="p">(</span><span class="n">move</span><span class="p">)</span>

    <span class="c1"># (Print the rotation map here)</span>

    <span class="c1"># Apply each transformation in the rotation map to the new cube</span>
    <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">rotmap</span><span class="p">:</span>
        <span class="c1"># shift item at index m[0] to item at index m[1]</span>
        <span class="n">cube1</span><span class="p">[</span><span class="n">cube_prior</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span> <span class="o">=</span> <span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="n">cube_prior</span> <span class="o">=</span> <span class="n">cube1</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
</pre></div>


<p><a name="rubiks2-maps-code"></a></p>
<h2>Face Map Code</h2>
<p>In this section we present a portion of the code 
that actually generates these face maps. This functionality
was not in the <a href="https://github.com/dwalton76/rubiks-cube-NxNxN-solver">original Rubik's Cube solver library</a>
from <a href="https://github.com/dwalton76/">Github user @dwalton76</a>,
so the library was forked and the functionality added
to the <a href="https://git.charlesreid1.com/charlesreid1/rubiks-cube-nnn-solver">forked Rubik's Cube solver library</a>.</p>
<p>The actual implementation is in the <code>rotation_map(action)</code> method,
defined for the Rubik's Cube object at the same place as the 
<code>rotate(action)</code> method. This definition is in 
<code>rubikscubennnsolver/__init__.py</code> on line 581:</p>
<p><a href="https://git.charlesreid1.com/charlesreid1/rubiks-cube-nnn-solver/src/master/rubikscubennnsolver/__init__.py#L581">link to <code>rubikscubennnsolver/__init__.py</code></a></p>
<p>This method returns a list containing the tuples of index permutations 
(old,new) that correspond to this particular move. Call it like this:</p>
<div class="highlight"><pre><span></span><span class="n">order</span> <span class="o">=</span> <span class="s1">&#39;URFDLB&#39;</span>
<span class="n">cube</span> <span class="o">=</span> <span class="n">RubiksCube444</span><span class="p">(</span><span class="n">solved_4x4x4</span><span class="p">,</span> <span class="n">order</span><span class="p">)</span>
<span class="n">cube</span><span class="o">.</span><span class="n">rotation_map</span><span class="p">(</span><span class="s1">&#39;U&#39;</span><span class="p">)</span>
</pre></div>


<p><a name="rubiks2-tuples"></a></p>
<h1>Tuples for Move Sequences</h1>
<p>So far we have shown the tuple representation for the Rubik's Cube
and how it works, and created a more convenient representation for
implementing the cube on a computer and applying rotations.</p>
<p>Now, we can achieve the goal of this post, which is to be able to
represent the state of a cube, after a certain number of rotations,
in a quantitative and mathematical way.</p>
<p>In Part 3, we'll develop an algebra of permutations to use 
and understand the tuple representations we are presenting in 
this post.</p>
<p><a name="rubiks2-tuples-sequences"></a></p>
<h2>Applying Rotation Maps for Sequences</h2>
<p>The concept here is simple: we use the rotation maps that we defined
above to permute elements according to the formula prescribed for 
that particular rotation.</p>
<p>By applying these permutations sequentially, we can permute the 
96-tuple in a way that represents the permutations created by 
a given sequence of moves.</p>
<p>For example, after applying four sequence maps corresponding to 
the move sequence <code>U R U' R'</code> we get:</p>
<div class="highlight"><pre><span></span>(1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96)
(1 2 3 77 5 6 7 73 9 10 11 69 16 12 8 20 17 18 19 36 21 22 23 24 25 26 27 28 29 30 31 32 49 50 51 33 37 38 39 40 41 42 43 44 45 46 47 48 13 56 60 64 53 54 55 34 57 58 59 35 61 62 63 4 96 66 67 68 14 70 71 72 15 74 75 76 65 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 52)
</pre></div>


<p><a name="rubiks2-preview"></a></p>
<h1>Preview of Part 3</h1>
<p>As a preview of where we are going with Part 3, let's 
return to the permutation corresponding to <code>U R U' R'</code>:</p>
<div class="highlight"><pre><span></span>(1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96)
(1 2 3 77 5 6 7 73 9 10 11 69 16 12 8 20 17 18 19 36 21 22 23 24 25 26 27 28 29 30 31 32 49 50 51 33 37 38 39 40 41 42 43 44 45 46 47 48 13 56 60 64 53 54 55 34 57 58 59 35 61 62 63 4 96 66 67 68 14 70 71 72 15 74 75 76 65 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 52)
</pre></div>


<p>It turns out that, unlike the <code>U</code> move by itself, this move sequence 
results in groups of either three or six faces exchanging places.
(In Part 3 we will cover the algorithm for finding these groups,
which, crucially, relies on the work we did in this post.)</p>
<p>The groups of six faces that are permuted are:</p>
<div class="highlight"><pre><span></span><span class="k">[77, 65, 96, 52, 64, 4]</span>
<span class="k">[16, 20, 36, 33, 49, 13]</span>
</pre></div>


<p>These two sets of six faces all live on corners of the cube, 
so this move sequence swaps six corners.</p>
<p>Likewise, the groups of three faces that are permuted are:</p>
<div class="highlight"><pre><span></span><span class="k">[73, 15, 8]</span>
<span class="k">[69, 14, 12]</span>
<span class="k">[50, 56, 34]</span>
<span class="k">[51, 60, 35]</span>
</pre></div>


<p>These are all faces on double edge pieces: </p>
<ul>
<li><code>[73, 15, 8]</code> and <code>[51, 60, 35]</code> are faces on right-handed double edge pieces</li>
<li><code>[69, 14, 12]</code> and <code>[50, 56, 34]</code> are faces on left-handed double edge pieces</li>
</ul>
<p>The remaining faces do not permute:</p>
<div class="highlight"><pre><span></span>[1, 2, 3, 5, 6, 7, 9, 10, 11, 17, 18, 19, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 53, 54, 55, 57, 58, 59, 61, 62, 63, 66, 67, 68, 70, 71, 72, 74, 75, 76, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95]
</pre></div>


<p>What we will discover is that the least common multiple 
of these two numbers, 6 and 3, yields the number of times
this move sequence needs to be applied to a solved cube (6) 
in order to return the cube back to its solved state.</p>
<p><a name="rubiks2-references"></a></p>
<h1>References</h1>
<ol>
<li>
<p>"Rubik's Cube". Charlesreid1.com wiki, Charles Reid. Edited 14 January 2017. Accessed 14 January 2017.
&lt;<a href="https://charlesreid1.com/wiki/Rubiks_Cube">https://charlesreid1.com/wiki/Rubiks_Cube</a>&gt;</p>
</li>
<li>
<p>"Rubik's Revenge". Charlesreid1.com wiki, Charles Reid. Edited 14 January 2017. Accessed 14 January 2017.
&lt;<a href="https://charlesreid1.com/wiki/Rubiks_Revenge">https://charlesreid1.com/wiki/Rubiks_Revenge</a>&gt;</p>
</li>
<li>
<p>"Rubik's Cube/Tuple". Charlesreid1.com wiki, Charles Reid. Edited 14 January 2017. Accessed 14 January 2017.
&lt;<a href="https://charlesreid1.com/wiki/Rubiks_Cube/Tuple">https://charlesreid1.com/wiki/Rubiks_Cube/Tuple</a>&gt;</p>
</li>
<li>
<p>"Rubik's Cube/Permutations". Charlesreid1.com wiki, Charles Reid. Edited 14 January 2017. Accessed 14 January 2017.
&lt;<a href="https://charlesreid1.com/wiki/Rubiks_Cube/Permutations">https://charlesreid1.com/wiki/Rubiks_Cube/Permutations</a>&gt;</p>
</li>
<li>
<p>"Github - dwalton76/rubiks-cube-NxNxN-solver". dwalton76, Github Repository, Github Inc. Accessed 11 January 2017.
&lt;<a href="https://github.com/dwalton76/rubiks-cube-NxNxN-solver">https://github.com/dwalton76/rubiks-cube-NxNxN-solver</a>&gt;</p>
</li>
<li>
<p>"Rubik's Cube NxNxN Solver". Git repository, git.charlesreid1.com. Charles Reid. Updated 14 January 2017.
&lt;<a href="https://git.charlesreid1.com/charlesreid1/rubiks-cube-nnn-solver">https://git.charlesreid1.com/charlesreid1/rubiks-cube-nnn-solver</a>&gt;</p>
</li>
<li>
<p>"Rubiks Cube Cycles". Git repository, git.charlesreid1.com. Charles Reid. Updated 14 January 2017.
&lt;<a href="https://git.charlesreid1.com/charlesreid1/rubiks-cube-cycles">https://git.charlesreid1.com/charlesreid1/rubiks-cube-cycles</a>&gt;</p>
</li>
</ol>
<p><a name="rubiks2-appendix"></a></p>
<h1>Appendix: Cube with Numbered Faces</h1>
<div class="highlight"><pre><span></span>             01 02 03 04
             05 06 07 08
             09 10 11 12
             13 14 15 16

17 18 19 20  33 34 35 36  49 50 51 52  65 66 67 68
21 22 23 24  37 38 39 40  53 54 55 56  69 70 71 72
25 26 27 28  41 42 43 44  57 58 59 60  73 74 75 76
29 30 31 32  45 46 47 48  61 62 63 64  77 78 79 80

             81 82 83 84
             85 86 87 88
             89 90 91 92
             93 94 95 96
</pre></div>


<script type="text/javascript">if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width < 768) ? "left" : align;
        indent = (screen.width < 768) ? "0em" : indent;
        linebreak = (screen.width < 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
</script></div>

    </div>
</div>

<div class="v20"></div>

<div class="row">
    <div class="col-md-12" style="text-align: left;">

        <div class="tags">
            <p>Tags:&nbsp;&nbsp;&nbsp;
                    <a href="/tag/rubiks-cube.html">rubiks cube</a>
                    &nbsp;&nbsp;
                    <a href="/tag/combinatorics.html">combinatorics</a>
                    &nbsp;&nbsp;
                    <a href="/tag/permutations.html">permutations</a>
                    &nbsp;&nbsp;
                    <a href="/tag/python.html">python</a>
                    &nbsp;&nbsp;
                    <a href="/tag/puzzles.html">puzzles</a>
                    &nbsp;&nbsp;
                    <a href="/tag/art-of-computer-programming.html">art of computer programming</a>
                    &nbsp;&nbsp;
                    <a href="/tag/knuth.html">knuth</a>
                    &nbsp;&nbsp;
        </div>

    </div>
</div>


<div class="v200"></div>
  	            	</article>
  	            	<article>
<header>
<div class="row">


    <div class="col-md-12">
        <div class="headtext" style="text-align: center;">
            <h1><b>
                4x4 Rubik's Cube: Part 1: Representations
            </b></h1>
        
            <p class="lead">
                Posted 
                <time datetime="2018-01-11T15:00:00-08:00" pubdate>Thursday 01/11/2018</time>
                in 
                <a href="/category/rubiks-cube.html">Rubiks Cube</a>
                </p>
            <p>
            <span style="font-size: 14px">
                <a href="/4x4-rubiks-cube-part-1-representations.html">permalink</a>
            </span>
            </p>
        </div>

    </div>

</div>
</header>


<div class="v50"></div>


<div class="row">
    <div class="col-md-12" style="text-align: left;">

        <div class="entry-content"><p><em>This is Part 1 of a 4-part blog post 
on the mathematics of the 4x4 Rubik's Cube, 
its relation to algorithms, and some 
curious properties of Rubik's Cubes.</em></p>
<p>You are currently reading Part 1 of this blog post: <strong>Part 1: Representations</strong></p>
<p>See Part 2 of this blog post here: <a href="https://charlesreid1.github.io/4x4-rubiks-cube-part-2-permutations.html">Part 2: Permutations</a></p>
<p>See Part 3 of this blog post here: <a href="https://charlesreid1.github.io/4x4-rubiks-cube-part-3-factoring-permutations.html">Part 3: Factoring Permutations</a></p>
<p>See Part 4 of this blog post here: <a href="#">Part 4: Sequence Order</a></p>
<h1>Table of Contents</h1>
<ul>
<li>
<p><a href="#rubiks1-intro">Introduction: Why the Rubik's Cube</a></p>
<ul>
<li><a href="#rubiks1-intro-why">Why the 4x4 Rubik's Cube</a></li>
</ul>
</li>
<li>
<p><a href="#rubiks1-how">How the Rubik's Cube Works</a></p>
<ul>
<li><a href="#rubiks1-how-pieces">The Pieces</a></li>
<li><a href="#rubiks1-how-face">Face Notation</a></li>
<li><a href="#rubiks1-how-color">Color Notation</a></li>
<li><a href="#rubiks1-how-move">Move Notation</a><ul>
<li><a href="#rubiks1-how-move-regular">Regular Face Rotations</a></li>
<li><a href="#rubiks1-how-move-reverse">Reverse Face Rotations</a></li>
<li><a href="#rubiks1-how-move-double">Double Face Rotations</a></li>
<li><a href="#rubiks1-how-move-second">Second Layer Face Rotations</a></li>
</ul>
</li>
</ul>
</li>
<li>
<p><a href="#rubiks1-computer">Computer Representation of a Rubik's Cube</a></p>
<ul>
<li><a href="#rubiks1-computer-operations">Operations and Functionality</a></li>
<li><a href="#rubiks1-computer-face">Face Numbering</a></li>
</ul>
</li>
<li>
<p><a href="#rubiks1-tuple">Tuple</a></p>
<ul>
<li><a href="#rubiks1-tuple-requirements">Tuple Representation Requirements</a></li>
<li><a href="#rubiks1-tuple-representation">Tuple Representation</a></li>
</ul>
</li>
<li>
<p><a href="#rubiks1-preview">Preview of Part 2</a></p>
</li>
<li>
<p><a href="#rubiks1-references">References</a></p>
</li>
</ul>
<p><br />
<br />
<br /></p>
<p><a name="rubiks1-intro"></a></p>
<h1>Introduction: Why The Rubik's Cube</h1>
<p>In this series of four posts, we'll take a look at the 
4x4 Rubik's Cube. The Rubik's Cube is an interesting
puzzle that has some profound mathematical connections
to group theory and combinatorics.</p>
<p>Group theory is a branch of mathematics that applies to 
any system that exhibits symmetry; combinatorics is the 
mathematics of counting things.</p>
<p>The Rubik's Cube gives us the opportunity to apply
concepts in group theory and combinatorics to 
better understand how the cube works, and to learn
how to apply these principles to real world systems.</p>
<p>Finally, we will wrap up by discussing some of the 
algorithms that are required to deal with a 
Rubik's Cube computationally.</p>
<p>In the next two posts, we'll talk more about the
mathematical representation of permutations of 
the Rubik's Cube, and how to use this representation 
to understand some of the properties of move 
sequences when applied to the cube.</p>
<p><a name="rubiks1-intro-why"></a></p>
<h2>Why The 4x4 Rubik's Cube</h2>
<p>The 4x4 Rubik's cube, also known as the Rubik's Revenge cube, 
is larger than the standard 3x3 Rubik's Cube - 96 faces, instead of 
the ususal 36. The 4x4 cube exhibits some particularly interesting 
properties as a result of having an even number of squares on each edge. </p>
<p><a name="rubiks1-how"></a></p>
<h1>How the Rubik's Cube Works</h1>
<p>Let's start with a discussion of cube mechanics, since this 
is important to coming up with an accurate mathematical model
of the cube.</p>
<p><a name="rubiks1-how-pieces"></a></p>
<h2>The Pieces</h2>
<p>The 4x4 Rubik's Cube consists of six faces of sixteen squares 
each, for a total of 96 face squares. These face squares are 
not completely interchangeable, however - the 4x4 cube is actually
composed of three types of pieces, called "cubies".</p>
<p><img src="images/cube1.jpg" width="300"/>
<strong>Figure 1: Corner pieces are green.</strong></p>
<p>The first type of piece is a <strong>corner piece</strong>, which contains 
3 faces. Note that it is impossible for the corner pieces
to change their chirality (direction of rotation).
There are 8 corner pieces, each of which can be oriented
in 3 different ways. </p>
<p><img src="images/cube2.jpg" width="300"/>
<strong>Figure 2: Double edge pieces are blue.</strong></p>
<p>The second type of piece is a <strong>double edge (dedge) piece</strong>.
Each edge is composed of two double edges. There are 
24 total double edge pieces, which can be further classified
into 12 left-handed and 12 right-handed dedge pieces.</p>
<p><img src="images/cube3.jpg" width="300"/>
<strong>Figure 3: Center pieces are blue.</strong></p>
<p>Lastly, there are 4 <strong>center pieces</strong> in the center of each
face, for a total of 24 center pieces. Note that each of the 
center pieces of a given color are interchangeable, unlike 
the double edge pieces or corners.</p>
<p><a name="rubiks1-how-face"></a></p>
<h2>Face Notation</h2>
<p>To refer to particular faces on the cube, we use six
letters to indicate different faces:</p>
<p><code>U</code> - upper face (the top of the cube)</p>
<p><code>D</code> - downward face (the bottom of the cube0</p>
<p><code>F</code> - front face (the front of the cube)</p>
<p><code>B</code> - back face (the back side of the cube)</p>
<p><code>L</code> - left face of the cube (on the left side when facing the front F face)</p>
<p><code>R</code> - right face of the cube</p>
<p>This will help refer to how we will rotate the cube.</p>
<p><a name="rubiks1-how-color"></a></p>
<h2>Color Notation</h2>
<p>In the solved state, each cube face has one of six colors.
The orientation of these colors relative to one another
is always fixed; the red and orange colored faces, for example,
are never adjacent. This is due to the nature of the mechanical
pieces that compose the Rubik's Cube.</p>
<p>The standard faces for each color on a solved cube are:</p>
<ul>
<li><code>U</code> = White</li>
<li><code>D</code> = Yellow</li>
<li><code>F</code> = Green</li>
<li><code>B</code> = Blue (Back-Blue)</li>
<li><code>L</code> = Orange</li>
<li><code>R</code> = Red (Red-Right)</li>
</ul>
<p>Note that on a 3x3 cube, we can always determine the
final color a face will have, because the six center pieces
on each side of a 3x3 cube always remain fixed.</p>
<p>On a 4x4 cube, however, all four center squares can rotate 
and move, meaning all 24 center squares are totally 
interchangeable, and there is no link between the 
center colors on a 4x4 cube and the final color
that will be on that face when the cube is solved.</p>
<p><a name="rubiks1-how-move"></a></p>
<h2>Move Notation</h2>
<p>Using the face notation explained above, we can denote 
multiple types of moves on the 4x4 Rubik's Cube.</p>
<p>We have 36 total moves that we can make on the 4x4 Rubik's Cube,
which can be grouped by the dozen:</p>
<div class="highlight"><pre><span></span>L l r R
U u d D
B b f F

L&#39; l&#39; r&#39; R&#39;
U&#39; u&#39; d&#39; D&#39;
B&#39; b&#39; f&#39; F&#39;

2L 2L&#39; 2R 2R&#39;
2U 2U&#39; 2D 2D&#39;
2B 2B&#39; 2F 2F&#39;
</pre></div>


<p>Let's go through the details of the notation.</p>
<p><a name="rubiks1-how-move-regular"></a></p>
<h3>Regular Face Rotations</h3>
<p>The regular face turns are denoted with capital letters:
<code>L R U D B F</code> refer to a single clockwise rotation of the 
respective face. Here, "clockwise" means <em>the direction
that is clockwise when facing the given face head-on.</em></p>
<p><a name="rubiks1-how-move-reverse"></a></p>
<h3>Reverse Face Rotations</h3>
<p>The <code>'</code> apostrophe following moves, as in <code>L' R' U' D' B' F'</code>,
indicates that the move shoud be a <em>counter-clockwise</em> 
rotation of the given face, instead of clockwise.</p>
<p><a name="rubiks1-how-move-double"></a></p>
<h3>Double Face Rotations</h3>
<p>Rotations that are indicated using a lowercase letter
refer to two-layer rotations: <code>l r u d b f</code>.</p>
<p><img src="images/cube4.jpg" width="300"/>
<strong>Figure 4: Cube state after move <code>u</code>.</strong></p>
<p>That is, the lowercase <code>u</code> refers to the <em>clockwise</em> 
rotation of the top two layers of the cube; 
the lowercase <code>r</code> refers to the <em>clockwise</em> 
rotation of the rightmost two
layers of the cube; and so on.</p>
<p>The apostrophe also serves to indicate a 
<em>counter-clockwise</em> rotation: <code>'l r' u' d' b' f'</code>
indicate counter clockwise rotations of the two
left, two right, two upper, two bottom, two back,
and two front layers, respectively.</p>
<p>We have covered the first 24 moves - 
clockwise and counter-clockwise rotations
of single and double layers.</p>
<p><a name="rubiks1-how-move-second"></a></p>
<h3>Second Layer Face Rotations</h3>
<p><img src="images/cube5.jpg" width="300"/>
<strong>Figure 5: Cube state after move <code>2U</code>.</strong></p>
<p>The <code>2</code> notation indicates a rotation of the second layer only. 
For example, <code>2U</code> refers to the clockwise rotation of the second 
layer from the top. This is equivalent to the move sequence 
<code>u U'</code>.</p>
<p>Likewise, the apostrophe indicates a counterclockwise rotation.</p>
<p><a name="rubiks1-computer"></a></p>
<h1>Computer Representation of a Rubik's Cube</h1>
<p>The computer representation we are using is the 
<a href="https://github.com/dwalton76/rubiks-cube-NxNxN-solver">rubiks-cube-NxNxN-solver</a>
library by Github user <a href="https://github.com/dwalton76/">@dwalton</a>.</p>
<p>We have modified this library to provide additional
functionality needed in the project; the fork used 
in this project is available at git.charlesreid1.com:
<a href="https://git.charlesreid1.com/charlesreid1/rubiks-cube-nnn-solver">rubiks-cube-nnn-solver</a></p>
<p>Using this library, here's how we create a 4x4
Rubik's Revenge cube:</p>
<div class="highlight"><pre><span></span><span class="n">In</span> <span class="p">[</span><span class="mi">1</span><span class="p">]:</span> <span class="kn">from</span> <span class="nn">rubikscubennnsolver.RubiksCube444</span> <span class="kn">import</span> <span class="n">RubiksCube444</span><span class="p">,</span> <span class="n">solved_4x4x4</span>

<span class="n">In</span> <span class="p">[</span><span class="mi">2</span><span class="p">]:</span> <span class="n">order</span> <span class="o">=</span> <span class="s1">&#39;URFDLB&#39;</span>

<span class="n">In</span> <span class="p">[</span><span class="mi">3</span><span class="p">]:</span> <span class="n">cube</span> <span class="o">=</span> <span class="n">RubiksCube444</span><span class="p">(</span><span class="n">solved_4x4x4</span><span class="p">,</span> <span class="n">order</span><span class="p">)</span>

<span class="n">In</span> <span class="p">[</span><span class="mi">4</span><span class="p">]:</span> <span class="n">cube</span><span class="o">.</span><span class="n">print_cube</span><span class="p">()</span>
         <span class="n">U</span> <span class="n">U</span> <span class="n">U</span> <span class="n">U</span>
         <span class="n">U</span> <span class="n">U</span> <span class="n">U</span> <span class="n">U</span>
         <span class="n">U</span> <span class="n">U</span> <span class="n">U</span> <span class="n">U</span>
         <span class="n">U</span> <span class="n">U</span> <span class="n">U</span> <span class="n">U</span>

<span class="n">L</span> <span class="n">L</span> <span class="n">L</span> <span class="n">L</span>  <span class="n">F</span> <span class="n">F</span> <span class="n">F</span> <span class="n">F</span>  <span class="n">R</span> <span class="n">R</span> <span class="n">R</span> <span class="n">R</span>  <span class="n">B</span> <span class="n">B</span> <span class="n">B</span> <span class="n">B</span>
<span class="n">L</span> <span class="n">L</span> <span class="n">L</span> <span class="n">L</span>  <span class="n">F</span> <span class="n">F</span> <span class="n">F</span> <span class="n">F</span>  <span class="n">R</span> <span class="n">R</span> <span class="n">R</span> <span class="n">R</span>  <span class="n">B</span> <span class="n">B</span> <span class="n">B</span> <span class="n">B</span>
<span class="n">L</span> <span class="n">L</span> <span class="n">L</span> <span class="n">L</span>  <span class="n">F</span> <span class="n">F</span> <span class="n">F</span> <span class="n">F</span>  <span class="n">R</span> <span class="n">R</span> <span class="n">R</span> <span class="n">R</span>  <span class="n">B</span> <span class="n">B</span> <span class="n">B</span> <span class="n">B</span>
<span class="n">L</span> <span class="n">L</span> <span class="n">L</span> <span class="n">L</span>  <span class="n">F</span> <span class="n">F</span> <span class="n">F</span> <span class="n">F</span>  <span class="n">R</span> <span class="n">R</span> <span class="n">R</span> <span class="n">R</span>  <span class="n">B</span> <span class="n">B</span> <span class="n">B</span> <span class="n">B</span>

         <span class="n">D</span> <span class="n">D</span> <span class="n">D</span> <span class="n">D</span>
         <span class="n">D</span> <span class="n">D</span> <span class="n">D</span> <span class="n">D</span>
         <span class="n">D</span> <span class="n">D</span> <span class="n">D</span> <span class="n">D</span>
         <span class="n">D</span> <span class="n">D</span> <span class="n">D</span> <span class="n">D</span>
</pre></div>


<p><a name="rubiks1-computer-operations"></a></p>
<h2>Operations and Functionality</h2>
<p>Some important functionality:</p>
<ul>
<li>Obtaining each side</li>
<li>Applying rotation</li>
<li>Applying sequence of rotations</li>
<li>Each side</li>
<li>Side face numberings, centers, edges</li>
</ul>
<p>To obtain each side, use the <code>sides</code> attribute:</p>
<div class="highlight"><pre><span></span>In [8]: print(cube.sides)
OrderedDict([(&#39;U&#39;, &lt;rubikscubennnsolver.RubiksSide.Side object at 0x11172d358&gt;), 
             (&#39;L&#39;, &lt;rubikscubennnsolver.RubiksSide.Side object at 0x11172d240&gt;), 
             (&#39;F&#39;, &lt;rubikscubennnsolver.RubiksSide.Side object at 0x11172d5c0&gt;), 
             (&#39;R&#39;, &lt;rubikscubennnsolver.RubiksSide.Side object at 0x11172d5f8&gt;), 
             (&#39;B&#39;, &lt;rubikscubennnsolver.RubiksSide.Side object at 0x11172d518&gt;), 
             (&#39;D&#39;, &lt;rubikscubennnsolver.RubiksSide.Side object at 0x11172d390&gt;)])
</pre></div>


<p>Each Side object has a long list of methods, including methods
to obtain the index numbers of corner, edge, or center faces 
on a particular side.</p>
<p>To apply a rotation of a single face, 
use the <code>rotate()</code> method and pass the 
name of the face:</p>
<div class="highlight"><pre><span></span>In [10]: cube.rotate(&quot;U&quot;)

In [11]: cube.print_cube()
         U U U U
         U U U U
         U U U U
         U U U U

F F F F  R R R R  B B B B  L L L L
L L L L  F F F F  R R R R  B B B B
L L L L  F F F F  R R R R  B B B B
L L L L  F F F F  R R R R  B B B B

         D D D D
         D D D D
         D D D D
         D D D D
</pre></div>


<p>Unfortunately, the rotate method does not 
take sequences of moves, but this is easily
resolved:</p>
<div class="highlight"><pre><span></span>In [12]: cube = RubiksCube444(solved_4x4x4, order)

In [13]: sequence = &quot;U L U&#39; L&#39;&quot;

In [14]: for move in sequence.split():
    ...:     cube.rotate(move)
    ...:

In [15]: cube.print_cube()
         L U U U
         U U U U
         U U U U
         U B B L

D F F F  R L L F  U R R R  B B B B
L L L L  F F F F  R R R R  B B B U
L L L L  F F F F  R R R R  B B B U
L L L L  F F F F  R R R R  B B B U

         D D D D
         D D D D
         D D D D
         B D D D
</pre></div>


<p><a name="rubiks1-computer-face"></a></p>
<h2>Face Numbering</h2>
<p>Here is the numerical representation of the faces,
which we will make extensive use of:</p>
<div class="highlight"><pre><span></span>In [6]: cube.print_cube_layout()
             01 02 03 04
             05 06 07 08
             09 10 11 12
             13 14 15 16

17 18 19 20  33 34 35 36  49 50 51 52  65 66 67 68
21 22 23 24  37 38 39 40  53 54 55 56  69 70 71 72
25 26 27 28  41 42 43 44  57 58 59 60  73 74 75 76
29 30 31 32  45 46 47 48  61 62 63 64  77 78 79 80

             81 82 83 84
             85 86 87 88
             89 90 91 92
             93 94 95 96
</pre></div>


<p><a name="rubiks1-tuple"></a></p>
<h1>Tuple Representation</h1>
<p>We have a goal of finding a way of representing the 
state of the 4x4 Rubik's Revenge using a tuple, 
which is a mathematical object that will enable us
to investigate properties of sequences, moves, and 
rotations.</p>
<p>It is important to note that the mechanics of the
cube restrict some of the 96 total faces to only 
occur in particular configurations. By using a 
tuple of 96 integers, we are overspecifying the 
state of the cube, and we would be able to do much 
better if our goal were a minimal representation 
of the Rubik's Cube state.</p>
<p>However, our goal is <em>not</em> a minimal representation
of the cube, but a <em>unique</em> representation of the cube.
As we will see in a later post, the schema we use
does not actually matter, so long as we can 
represent each unique state of the cube using a sequence
of integers of arbitrary length.</p>
<p><a name="rubiks1-tuple-requirements"></a></p>
<h2>Tuple Representation Requirements</h2>
<p>The 4x4 cube, in the solved state, has a few characteristics that can be used
to indicate a particular permutation or configuration:</p>
<ul>
<li>Face indciators <code>UDFBLR</code></li>
<li>Colors <code>WYGBRO</code></li>
<li>Integers 1-96 to number each face</li>
</ul>
<p>Here is how the faces representation looks:</p>
<div class="highlight"><pre><span></span>In [17]: cube.print_cube()
         U U U U
         U U U U
         U U U U
         U U U U

L L L L  F F F F  R R R R  B B B B
L L L L  F F F F  R R R R  B B B B
L L L L  F F F F  R R R R  B B B B
L L L L  F F F F  R R R R  B B B B

         D D D D
         D D D D
         D D D D
         D D D D
</pre></div>


<p>The equivalent color representation is:</p>
<div class="highlight"><pre><span></span>         W W W W
         W W W W
         W W W W
         W W W W

O O O O  G G G G  R R R R  B B B B
O O O O  G G G G  R R R R  B B B B
O O O O  G G G G  R R R R  B B B B
O O O O  G G G G  R R R R  B B B B

         Y Y Y Y
         Y Y Y Y
         Y Y Y Y
         Y Y Y Y
</pre></div>


<p>However, the tuple representation <em>cannot</em> use 
colors to represent the state of the cube.
This is because a tuple representation using 
"R" to represent each red face would give us no
way of distinguishing between the (non-interchangeable)
red faces on the cube. For example, if the 
red-green double edge piece were replaced 
with a red-blue double edge piece, oriented
with the red face at the same location,
the n-tuple needs to reflect that this face
has a different value than it did the prior move.</p>
<p>For this reason, we must use an integer to index 
each distinct face:</p>
<div class="highlight"><pre><span></span>             01 02 03 04
             05 06 07 08
             09 10 11 12
             13 14 15 16

17 18 19 20  33 34 35 36  49 50 51 52  65 66 67 68
21 22 23 24  37 38 39 40  53 54 55 56  69 70 71 72
25 26 27 28  41 42 43 44  57 58 59 60  73 74 75 76
29 30 31 32  45 46 47 48  61 62 63 64  77 78 79 80

             81 82 83 84
             85 86 87 88
             89 90 91 92
             93 94 95 96
</pre></div>


<p>We can rearrange this into a 96-tuple:</p>
<div class="highlight"><pre><span></span>(1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96)
</pre></div>


<p>If we apply a rotation, for example <code>U R</code>, 
we will end up with a different cube:</p>
<div class="highlight"><pre><span></span>             13 09 05 01
             14 10 06 02
             15 11 07 03
             48 44 40 36

33 34 35 84  61 57 53 49  16 66 67 68  17 18 19 20
21 22 23 24  37 38 39 88  62 58 54 50  12 70 71 72
25 26 27 28  41 42 43 92  63 59 55 51  08 74 75 76
29 30 31 32  45 46 47 96  64 60 56 52  04 78 79 80

             81 82 83 77
             85 86 87 73
             89 90 91 69
             93 94 95 65
</pre></div>


<p>This particular sequence of moves results in 
a cube state uniquely represented by the following 
96-tuple:</p>
<div class="highlight"><pre><span></span>(13 9 5 1 14 10 6 2 15 11 7 3 48 44 40 36 33 34 35 84 21 22 23 24 25 26 27 28 29 30 31 32 61 57 53 49 37 38 39 88 41 42 43 92 45 46 47 96 16 66 67 68 62 58 54 50 63 59 55 51 64 60 56 52 17 18 19 20 12 70 71 72 8 74 75 76 4 78 79 80 81 82 83 77 85 86 87 73 89 90 91 69 93 94 95 65)
</pre></div>


<p><a name="rubiks1-tuple-representation"></a></p>
<h2>Tuple Representation</h2>
<p>Now, we have managed to find a unique representation for any given cube state 
by labeling each individual face 1-96.</p>
<p>But we aren't quite done yet. It turns out that our 
statement, that our representation should treat each
face as unique, is not strictly true for all 96 faces.</p>
<p>The square pieces are completely interchangeable, due to 
the fact that they are not connected to any other faces
(and therefore have no orientation or way of differentiating
them from one another).</p>
<p>If we are doing anything that involves counting 
configurations, it is important to account for this fact,
by treating the following groups of face indices as
interchangeable:</p>
<div class="highlight"><pre><span></span>(6, 7, 10, 11)
(22, 23, 26, 27)
(38, 39, 42, 43)
(54, 55, 58, 59)
(70, 71, 74, 75)
(86, 87, 90, 91)
</pre></div>


<p>In Part 2 and Part 3 of this series, we will 
encounter these concepts again, and it will
become more clear what these caveats and 
notes mean through example.</p>
<p>Following is a preview of Part 2 of this 3-part blog post.</p>
<p><a name="rubiks1-preview"></a></p>
<h1>Preview of Part 2</h1>
<p>In Part 2 of this series, we will utilize the n-tuple representation
of the 4x4 Rubik's Cube in order to write permutations of the cube
corresponding to specific states, and turn a sequence of moves on the 
cube into permutations.</p>
<p>We will also create a map for each type of move, telling us 
where each face index will end up.</p>
<p>In Part 3 we will use these to predict properties of 
rotations applied to the 4x4 Rubik's Cube.</p>
<p><a name="rubiks1-references"></a></p>
<h1>References</h1>
<ol>
<li>
<p>"Rubik's Cube". Charlesreid1.com wiki, Charles Reid. Edited 11 January 2017. Accessed 11 January 2017.
&lt;<a href="https://charlesreid1.com/wiki/Rubiks_Cube">https://charlesreid1.com/wiki/Rubiks_Cube</a>&gt;</p>
</li>
<li>
<p>"Rubik's Revenge". Charlesreid1.com wiki, Charles Reid. Edited 11 January 2017. Accessed 11 January 2017.
&lt;<a href="https://charlesreid1.com/wiki/Rubiks_Revenge">https://charlesreid1.com/wiki/Rubiks_Revenge</a>&gt;</p>
</li>
<li>
<p>"Rubik's Cube/Tuple". Charlesreid1.com wiki, Charles Reid. Edited 11 January 2017. Accessed 11 January 2017.
&lt;<a href="https://charlesreid1.com/wiki/Rubiks_Cube/Tuple">https://charlesreid1.com/wiki/Rubiks_Cube/Tuple</a>&gt;</p>
</li>
<li>
<p>"Rubik's Cube/Permutations". Charlesreid1.com wiki, Charles Reid. Edited 11 January 2017. Accessed 11 January 2017.
&lt;<a href="https://charlesreid1.com/wiki/Rubiks_Cube/Permutations">https://charlesreid1.com/wiki/Rubiks_Cube/Permutations</a>&gt;</p>
</li>
<li>
<p>"Github - dwalton76/rubiks-cube-NxNxN-solver". dwalton76, Github Repository, Github Inc. Accessed 11 January 2017.
&lt;<a href="https://github.com/dwalton76/rubiks-cube-NxNxN-solver">https://github.com/dwalton76/rubiks-cube-NxNxN-solver</a>&gt;</p>
</li>
<li>
<p>"Rubik's Cube NxNxN Solver". Git repository, git.charlesreid1.com. Charles Reid. Updated 11 January 2017.
&lt;<a href="https://charlesreid1.com:3000/charlesreid1/rubiks-cube-nnn-solver">https://git.charlesreid1.com/charlesreid1/rubiks-cube-nnn-solver</a>&gt;</p>
</li>
<li>
<p>"Rubiks Cube Cycles". Git repository, git.charlesreid1.com. Charles Reid. Updated 11 January 2017.
&lt;<a href="https://charlesreid1.com:3000/charlesreid1/rubiks-cube-cycles">https://git.charlesreid1.com/charlesreid1/rubiks-cube-cycles</a>&gt;</p>
</li>
</ol></div>

    </div>
</div>

<div class="v20"></div>

<div class="row">
    <div class="col-md-12" style="text-align: left;">

        <div class="tags">
            <p>Tags:&nbsp;&nbsp;&nbsp;
                    <a href="/tag/rubiks-cube.html">rubiks cube</a>
                    &nbsp;&nbsp;
                    <a href="/tag/mathematics.html">mathematics</a>
                    &nbsp;&nbsp;
                    <a href="/tag/combinatorics.html">combinatorics</a>
                    &nbsp;&nbsp;
                    <a href="/tag/permutations.html">permutations</a>
                    &nbsp;&nbsp;
                    <a href="/tag/python.html">python</a>
                    &nbsp;&nbsp;
                    <a href="/tag/puzzles.html">puzzles</a>
                    &nbsp;&nbsp;
        </div>

    </div>
</div>


<div class="v200"></div>
  	            	</article>
  	            	<article>
<header>
<div class="row">


    <div class="col-md-12">
        <div class="headtext" style="text-align: center;">
            <h1><b>
                Recursive Backtracking in Go for Bioinformatics Applications: 3. Go Implementation of Backtracking
            </b></h1>
        
            <p class="lead">
                Posted 
                <time datetime="2018-01-03T10:30:00-08:00" pubdate>Wednesday 01/03/2018</time>
                in 
                <a href="/category/rosalind.html">Rosalind</a>
                </p>
            <p>
            <span style="font-size: 14px">
                <a href="/recursive-backtracking-in-go-for-bioinformatics-applications-3-go-implementation-of-backtracking.html">permalink</a>
            </span>
            </p>
        </div>

    </div>

</div>
</header>


<div class="v50"></div>


<div class="row">
    <div class="col-md-12" style="text-align: left;">

        <div class="entry-content"><p><em>This is the third in a series of three blog posts describing our
solution to a bioinformatics problem from Rosalind.info,
<a href="http://rosalind.info/problems/ba1i/">Problem BA1(i) (Find most frequent words with mismatches
in a string)</a>.
To solve this problem and generate variations of a DNA string
as required, we implemented a recursive backtracking method
in the Go programming language.</em></p>
<ul>
<li><em><a href="https://charlesreid1.github.io/recursive-backtracking-in-go-for-bioinformatics-applications-1-counting-variations.html">Part 1: Counting Variations</a></em></li>
<li><em><a href="https://charlesreid1.github.io/recursive-backtracking-in-go-for-bioinformatics-applications-2-generating-variations.html">Part 2: Generating Variations</a></em></li>
<li><em>Part 3: Go Implementation of Recursive Backtracking (you are here)</em></li>
</ul>
<p><br />
<br /></p>
<p><a name="toc"></a></p>
<h2>Table of Contents</h2>
<ul>
<li>
<p><a href="#problem-descr">Problem Description</a></p>
</li>
<li>
<p><a href="#backtracking">Recursive Backtracking Pseudocode</a></p>
</li>
<li>
<p><a href="#go-implementation">Recursive Backtracking: Go Implementation</a></p>
<ul>
<li><a href="#visit-hamming">Visit Hamming Neighbors Function</a></li>
<li><a href="#assemble-visit">Assemble Visit Variations Function</a></li>
</ul>
</li>
<li>
<p><a href="#tests">Tests</a></p>
</li>
<li>
<p><a href="#fruitful">Go forth and be fruitful</a></p>
</li>
</ul>
<p><br />
<br /></p>
<p><a name="problem-descr"></a></p>
<h2>Problem Description</h2>
<p>The task at hand is to take a given input strand of DNA,
and generate variations from it that have up to <span class="math">\(d\)</span> differences
(a Hamming distance of <span class="math">\(d\)</span>) in the codons (base pairs).</p>
<p>In <a href="https://charlesreid1.github.io/recursive-backtracking-in-go-for-bioinformatics-applications-1-counting-variations.html">part 1 of this series</a>, we walk through the
construction of an analytical formula to count the number
of variations of a given DNA string that can be generated,
given the constraints of the problem.</p>
<p>In <a href="https://charlesreid1.github.io/recursive-backtracking-in-go-for-bioinformatics-applications-2-generating-variations.html">part 2 of this series</a>, we cover several techniques to
generate variations on a DNA string, and present pseudocode
for the recursive backtracking method that we use here.</p>
<p>In <a href="#">part 3 of this series</a>, we will cover our implementation
of the recursive backtracking method in the Go programming
language.</p>
<p><br />
<br /></p>
<p><a name="backtracking"></a></p>
<h2>Recursive Backtracking Pseudocode</h2>
<p>To review from the prior post, our pseudocode
for recursive backtracking to explore variations
or combinations looks like the following:</p>
<div class="highlight"><pre><span></span>explore method:
    base case:
        visit this solution
    recursive case:
        for each available choice:
            make a choice
            explore outcomes
            unmake the choice
            move on to the next choice
</pre></div>


<p>The key elements there are the base and recursive
cases, and the mechanism of iterating over each
possible choice and making/exploring/unmaking
the choice.</p>
<p><a name="go-implementation"></a></p>
<h2>Recursive Backtracking: Go Implementation</h2>
<p>In total, we have three different methods to
accomplish this task:</p>
<ul>
<li>
<p><code>VisitHammingNeighbors(input,d)</code>: this is the public method
  that the user calls to generate a string array of all
  strings that are a Hamming distance of up to <code>d</code> from
  the input string <code>input</code>. This public method performs
  parameter and error checking, initializes space for
  data, and collects results.</p>
</li>
<li>
<p><code>visitHammingNeighbors_recursive(base_kmer, depth, choices, results_map)</code>:
  this method is the private recursive method available
  only to the package. This method performs the actual
  recursive work. </p>
</li>
</ul>
<p><strong>NOTE:</strong> the function name starts with a lower case letter,
so it is not exported by the package - i.e., it is not available
to the user when they import this package.</p>
<p>The base case of the <code>visitHammingNeighbors_recursive()</code>
function will pass the final set of choices to the final
step:</p>
<ul>
<li><code>assemble_variations(base_kmer, choices, results_map)</code>: 
  this method (private to the package) is a recursive
  method that uses the chosen indices and </li>
</ul>
<p><a name="visit-hamming"></a></p>
<h3>Visit Hamming Neighbors Function</h3>
<p>The function call to visit all Hamming neighbors and add them to the <code>results</code> set
is split into two parts: a non-recursive public function, which provides a public wrapper
that is user-friendly and performs error-checking on the parameters provided, and a
recursive private function that is used internally but not intended to be called by
users directly.</p>
<h4>Public, Non-Recursive Function</h4>
<p>Here is the entry point function that the user calls
when they wish to generate all variations on a given
string of DNA, and have the variations returned as a
string slice.</p>
<div class="highlight"><pre><span></span>// Given an input string of DNA, generate variations
// of said string that are a Hamming distance of
// less than or equal to d.
func VisitHammingNeighbors(input string, d int) (map[string]bool, error) {

    // a.k.a. visit_kmer_neighbors

    // number of codons
    n_codons := 4

    // Use combinatorics to calculate the total
    // number of variation.
    buffsize, _ := CountHammingNeighbors(len(input), d, n_codons)
</pre></div>


<p>The call to <code>CountHammingNeighbors()</code> uses the counting
formula from <a href="https://charlesreid1.github.io/recursive-backtracking-in-go-for-bioinformatics-applications-1-counting-variations.html">Part 1</a>
to predict the number of variations. If the user has selected
an astronomical problem size, the program warns the user.</p>
<div class="highlight"><pre><span></span>    // This blows up quickly, so warn the user
    // if their problem is too big
    MAX := int(1e6)
    if buffsize &gt; MAX {
        msg := fmt.Sprintf(&quot;Error: you are generating over MAX = %d permutations, you probably don&#39;t want to do this.&quot;, d)
        return nil, errors.New(msg)
    }
</pre></div>


<p>Now the actual recursive backtracking algorithm begins.
The code loops over every possible value of Hamming distance
<span class="math">\(d\)</span> and calls the recursive method at each value of <span class="math">\(d\)</span>.</p>
<div class="highlight"><pre><span></span>    // Store the final results in a set (string-&gt;bool map)
    results := make(map[string]bool)

    // Begin backtracking algorithm
    for dd := 0; dd &lt;= d; dd++ {

        // The choices array will change with each recursive call.
        // Go passes all arguments by copy, which is good for us.
        choices := []int{}

        // Populate list of neighbors
        visitHammingNeighbors_recursive(input, dd, choices, results)

    }
</pre></div>


<p>We don't assign any results from the call to <code>visitHammingNeighbors_recursive()</code>
because we pass in a data structure (actually a pointer to a
data structure), <code>results</code>, that is modified in-place.</p>
<p>Thus, when we complete a call to <code>visitHammingNeighbors_recursive()</code>,
results will contain all variations already.</p>
<div class="highlight"><pre><span></span>    // Check if we have the right number of results
    if len(results) != buffsize {
        fmt.Printf(&quot;WARNING: number of results (%d) did not match expected value (%d)\n&quot;, len(results), buffsize)
    }

    return results
}
</pre></div>


<h4>Private, Recursive Function</h4>
<p>In the above function, the call to the recursive
function to visit all Hamming neighbors happens
here:</p>
<div class="highlight"><pre><span></span>        // Populate list of neighbors
        visitHammingNeighbors_recursive(input, dd, choices, results)
</pre></div>


<p>The user passes the original kmer <code>input</code>, along with the
Hamming distance parameter <code>dd</code>, the list of choices
of indices that have already been selected <code>choices</code>,
and the data structure storing all resulting strings
<code>results</code>.</p>
<p>As with the pseudocode, we have a base case and 
a recursive case. The recursive function is being
called repeatedly until it reaches a depth of 0,
with the depth parameter being decremented each call.</p>
<div class="highlight"><pre><span></span>// Recursive function: given an input string of DNA,
// generate Hamming neighbors that are a Hamming
// distance of exactly d. Populate the neighbors
// array with the resulting neighbors.
func visitHammingNeighbors_recursive(base_kmer string, depth int, choices []int, results map[string]bool) error {

    if depth == 0 {

        // Base case

    } else {

        // Recursive case

    }
}
</pre></div>


<p>The base case occurs when we reach a depth of 0 and have
no further choices to make. We reach this base case for
each binary number with <span class="math">\(d\)</span> digits set to 1; once the base
case is reached, we call the <code>assemble_variations()</code> function
to substitute all possible codons at the selected indices.</p>
<div class="highlight"><pre><span></span>func visitHammingNeighbors_recursive(base_kmer string, depth int, choices []int, results map[string]bool) error {

    if depth == 0 {

        // Base case
        assemble_variations(base_kmer, choices, results)
        return nil
</pre></div>


<p>The recursive case is slightly more complicated, but it follows
the same backtracking pseudocode covered previously: from a set
of possible choices, try each choice, recursively call this 
function, then unmake the choice and move on to the next choice.</p>
<p>Here, the choice is which index <code>c</code> in the kmer to modify. Each
kmer can only be modified once, so we have a for loop to
check if the index <code>c</code> is in the list of choices already made.</p>
<div class="highlight"><pre><span></span>    } else {

        // Recursive case
        for c := 0; c &lt;= len(base_kmer); c++ {

            var indexAlreadyTaken bool
            for _, choice := range choices {
                if c == choice {
                    indexAlreadyTaken = true
                }
            }
</pre></div>


<p>As before, the recursive call to this function will
not return any values that need to be stored, since 
<code>results</code> points to a data structure (map) that is 
modified in-place.</p>
<div class="highlight"><pre><span></span>            if !indexAlreadyTaken {

                // This will make a new copy of choices
                // for each recursive function call
                choices2 := append(choices, c)
                err := visitHammingNeighbors_recursive(base_kmer, depth-1, choices2, results)
                if err != nil {
                    return err
                }

            }
        }

    }

    return nil
}
</pre></div>


<p><a name="assemble-visit"></a></p>
<h3>Assemble Visit Variation Function</h3>
<p>Once we've generated each list of indices to modify,
we call a second recursive function to substitute each
codon into each index.</p>
<p>In the recursive method above, each recursive function
call added a new choice to <code>choices</code>; in this recursive
function, each recursive funcction call pops a choice 
from <code>choices</code>. Thus, the base case is when <code>choices</code>
is empty.</p>
<p>Here are the base and recursive cases:</p>
<div class="highlight"><pre><span></span>// Given a base kmer and a choice of indices where
// the kmer should be changed, generate all possible
// variations on this base_kmer.
func assemble_variations(base_kmer string, choices []int, results map[string]bool) {

    if len(choices) &gt; 0 {

        // Recursive case
        ...

    } else {

        // Base case
        ...

    }
}
</pre></div>


<p>The recursive case pops a choice from <code>choices</code>, 
finds which nucleotide (AGCT) is at that location,
and assembles the list of possible choices (the
other 3 nucleotide values). It then performs
the recursive backtracking algorithm, choosing 
from each of the three possible nucleotide values,
exploring the choice by making a recursive call,
then un-making the choice.</p>
<div class="highlight"><pre><span></span>func assemble_variations(base_kmer string, choices []int, results map[string]bool) {

    if len(choices) &gt; 0 {

        // Recursive case

        all_codons := []string{&quot;A&quot;, &quot;T&quot;, &quot;G&quot;, &quot;C&quot;}

        // Pop the next choice
        // https://github.com/golang/go/wiki/SliceTricks
        ch_ix, choices := choices[0], choices[1:]

        // Get the value of the codon at that location
        if ch_ix &lt; len(base_kmer) {
            // slice of string is bytes,
            // so convert back to string
            this_codon := string(base_kmer[ch_ix])
            for _, codon := range all_codons {

                if codon != this_codon {
                    // Swap out the old codon with the new codon
                    new_kmer := base_kmer[0:ch_ix] + codon + base_kmer[ch_ix+1:]
                    assemble_variations(new_kmer, choices, results)
                }
            }
        }

    } else {

        // Base case
        results[base_kmer] = true

    }
}
</pre></div>


<p><br />
<br /></p>
<p><a name="tests"></a></p>
<h2>Tests</h2>
<p>The last step after some debugging was to write tests for the
function to generate all variations of a DNA string, to ensure
the recursive backtracking functions work correctly.</p>
<p>The pattern we use is to create a struct containing test parameters,
then create a test matrix by initializing instances of the
parameter struct with the parameters we want to test.</p>
<p>Here is how we set up the tests:</p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">TestMatrixVisitHammingNeighbors</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">tests</span> <span class="p">=</span> <span class="p">[]</span><span class="kd">struct</span> <span class="p">{</span>
        <span class="nx">input</span> <span class="kt">string</span>
        <span class="nx">d</span>     <span class="kt">int</span>
        <span class="nx">gold</span>  <span class="p">[]</span><span class="kt">string</span>
    <span class="p">}{</span>
        <span class="p">{</span><span class="s">&quot;AAA&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
            <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&quot;AAC&quot;</span><span class="p">,</span> <span class="s">&quot;AAT&quot;</span><span class="p">,</span> <span class="s">&quot;AAG&quot;</span><span class="p">,</span> <span class="s">&quot;AAA&quot;</span><span class="p">,</span> <span class="s">&quot;CAA&quot;</span><span class="p">,</span> <span class="s">&quot;GAA&quot;</span><span class="p">,</span> <span class="s">&quot;TAA&quot;</span><span class="p">,</span> <span class="s">&quot;ATA&quot;</span><span class="p">,</span> <span class="s">&quot;ACA&quot;</span><span class="p">,</span> <span class="s">&quot;AGA&quot;</span><span class="p">},</span>
        <span class="p">},</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">test</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">tests</span> <span class="p">{</span>

        <span class="o">...</span>

    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>Each test case should generate all Hamming neighbors, and compare to the list of
Hamming neighbors provided. This requires two tricks:</p>
<ul>
<li>sort before comparing, to ensure a proper comparison</li>
<li>use a custom <code>EqualStringSlices()</code> function that will iterate through
  two string slices element-wise to check if they are equal.</li>
</ul>
<p>The <code>EqualStringSlices()</code> function is required because Go does not have 
built-in equality checks for slices.</p>
<p>Here is what the tests look like:</p>
<div class="highlight"><pre><span></span>    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">test</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">tests</span> <span class="p">{</span>

        <span class="c1">// Money shot</span>
        <span class="nx">result</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">VisitHammingNeighbors</span><span class="p">(</span><span class="nx">test</span><span class="p">.</span><span class="nx">input</span><span class="p">,</span> <span class="nx">test</span><span class="p">.</span><span class="nx">d</span><span class="p">)</span>

        <span class="c1">// Check if there was error</span>
        <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="nx">msg</span> <span class="o">:=</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&quot;Error: %v&quot;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
            <span class="nx">t</span><span class="p">.</span><span class="nx">Error</span><span class="p">(</span><span class="nx">msg</span><span class="p">)</span>
        <span class="p">}</span>

        <span class="c1">// Sort before comparing</span>
        <span class="nx">sort</span><span class="p">.</span><span class="nx">Strings</span><span class="p">(</span><span class="nx">test</span><span class="p">.</span><span class="nx">gold</span><span class="p">)</span>
        <span class="nx">sort</span><span class="p">.</span><span class="nx">Strings</span><span class="p">(</span><span class="nx">result</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">!</span><span class="nx">EqualStringSlices</span><span class="p">(</span><span class="nx">result</span><span class="p">,</span> <span class="nx">test</span><span class="p">.</span><span class="nx">gold</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">msg</span> <span class="o">:=</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&quot;Error testing VisitHammingNeighbors():\ncomputed = %v\ngold     = %v&quot;</span><span class="p">,</span>
                <span class="nx">result</span><span class="p">,</span> <span class="nx">test</span><span class="p">.</span><span class="nx">gold</span><span class="p">)</span>
            <span class="nx">t</span><span class="p">.</span><span class="nx">Error</span><span class="p">(</span><span class="nx">msg</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
</pre></div>


<p><a name="fruitful"></a></p>
<h2>Go Forth and Be Fruitful</h2>
<p>Now that you have the basic tools to imlement a recursive
backtracking algorithm in Go to generate string variations,
you have one of the key ingredients to solve Rosalind.info
problem <a href="http://rosalind.info/problems/ba1i/">BA1i, "Find Most Frequent Words with Mismatches by
String"</a>.</p>
<p>This problem is tricky principally because it requires generating
every DNA string variation, so now you should have the key
ingredient to solve BA1i (and several problems that follow).</p>
<p>You can use the final version of the methods we covered by importing
the <code>go-rosalind</code> library in your Go code
(<a href="https://godoc.org/github.com/charlesreid1/go-rosalind/rosalind">link to go-rosalind documentation on godoc.org</a>)
or you can implement your own version of these algorithms. 
The Go code we covered in this post is also on Github in the
<a href="https://github.com/charlesreid1/go-rosalind">charlesreid1/go-rosalind</a> repository.</p>
<script type="text/javascript">if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width < 768) ? "left" : align;
        indent = (screen.width < 768) ? "0em" : indent;
        linebreak = (screen.width < 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
</script></div>

    </div>
</div>

<div class="v20"></div>

<div class="row">
    <div class="col-md-12" style="text-align: left;">

        <div class="tags">
            <p>Tags:&nbsp;&nbsp;&nbsp;
                    <a href="/tag/go.html">go</a>
                    &nbsp;&nbsp;
                    <a href="/tag/golang.html">golang</a>
                    &nbsp;&nbsp;
                    <a href="/tag/rosalind.html">rosalind</a>
                    &nbsp;&nbsp;
                    <a href="/tag/bioinformatics.html">bioinformatics</a>
                    &nbsp;&nbsp;
                    <a href="/tag/recursion.html">recursion</a>
                    &nbsp;&nbsp;
                    <a href="/tag/backtracking.html">backtracking</a>
                    &nbsp;&nbsp;
                    <a href="/tag/strings.html">strings</a>
                    &nbsp;&nbsp;
                    <a href="/tag/combinatorics.html">combinatorics</a>
                    &nbsp;&nbsp;
        </div>

    </div>
</div>


<div class="v200"></div>
  	            	</article>

<div class="row">
    <div class="col-md-4 col-centered" style="text-align: center;">

        <div class="pagination">
            <a class="prev" href="/index6.html">&larr; Older</a>
        
            <a class="next" href="/index4.html">Newer &rarr;</a>
          <br />
        </div>

    </div>
</div>

<div class="v50"></div>


        </div>

        <div class="col-md-4" style="text-align: center;">
<a name="a_archive"></a>


        <div class="well">

            <h2>December 2018</h2>

            <p class="archive">
            <a href="/recursive-backtracking-in-go-for-bioinformatics-applications-2-generating-variations.html">Recursive Backtracking in Go for Bioinformatics Applications: 2. Generating Variations</a>
            </p>
            <p class="archive">
            <a href="/recursive-backtracking-in-go-for-bioinformatics-applications-1-counting-variations.html">Recursive Backtracking in Go for Bioinformatics Applications: 1. Counting Variations</a>
            </p>
            <p class="archive">
            <a href="/basic-data-structures-in-go-maps.html">Basic Data Structures in Go: Maps</a>
            </p>
            <p class="archive">
            <a href="/learning-bioinformatics-with-go-and-rosalind.html">Learning Bioinformatics with Go and Rosalind</a>
            </p>

        </div>

        <div class="v20"></div>


        <div class="well">

            <h2>October 2018</h2>

            <p class="archive">
            <a href="/first-post-of-the-fall-part-2-flaskadillo.html">First Post of the Fall, Part 2: Flaskadillo</a>
            </p>
            <p class="archive">
            <a href="/first-post-of-the-fall-part-1-data-commons.html">First Post of the Fall, Part 1: Data Commons</a>
            </p>

        </div>

        <div class="v20"></div>


        <div class="well">

            <h2>May 2018</h2>

            <p class="archive">
            <a href="/current-projects.html">Current Projects</a>
            </p>

        </div>

        <div class="v20"></div>


        <div class="well">

            <h2>March 2018</h2>

            <p class="archive">
            <a href="/charlesreid1com-stack.html">Charlesreid1.com Stack</a>
            </p>

        </div>

        <div class="v20"></div>


        <div class="well">

            <h2>February 2018</h2>

            <p class="archive">
            <a href="/d3-calendar-visualizations.html">D3 Calendar Visualizations</a>
            </p>
            <p class="archive">
            <a href="/project-euler-problem-172.html">Project Euler Problem 172</a>
            </p>

        </div>

        <div class="v20"></div>


        <div class="well">

            <h2>January 2018</h2>

            <p class="archive">
            <a href="/4x4-rubiks-cube-part-4-sequence-order.html">4x4 Rubik's Cube: Part 4: Sequence Order</a>
            </p>
            <p class="archive">
            <a href="/4x4-rubiks-cube-part-3-factoring-permutations.html">4x4 Rubik's Cube: Part 3: Factoring Permutations</a>
            </p>
            <p class="archive">
            <a href="/4x4-rubiks-cube-part-2-permutations.html">4x4 Rubik's Cube: Part 2: Permutations</a>
            </p>
            <p class="archive">
            <a href="/4x4-rubiks-cube-part-1-representations.html">4x4 Rubik's Cube: Part 1: Representations</a>
            </p>
            <p class="archive">
            <a href="/recursive-backtracking-in-go-for-bioinformatics-applications-3-go-implementation-of-backtracking.html">Recursive Backtracking in Go for Bioinformatics Applications: 3. Go Implementation of Backtracking</a>
            </p>
            <p class="archive">
            <a href="/lets-generate-permutations.html">Let's Generate Permutations!</a>
            </p>

        </div>

        <div class="v20"></div>


        <div class="well">

            <h2>September 2017</h2>

            <p class="archive">
            <a href="/five-letter-words-part-3-letter-coverage-and-dynamic-programming.html">Five Letter Words: Part 3: Letter Coverage and Dynamic Programming</a>
            </p>
            <p class="archive">
            <a href="/five-letter-words-part-2-more-five-word-algorithms.html">Five Letter Words: Part 2: More Five-Word Algorithms</a>
            </p>
            <p class="archive">
            <a href="/five-letter-words-part-1-getting-familiar-with-the-list.html">Five Letter Words: Part 1: Getting Familiar With The List</a>
            </p>

        </div>

        <div class="v20"></div>


        <div class="well">

            <h2>August 2017</h2>

            <p class="archive">
            <a href="/eulers-theorem-the-totient-function-and-calculating-totients-by-hand.html">Euler's Theorem, the Totient Function, and Calculating Totients By Hand</a>
            </p>

        </div>

        <div class="v20"></div>


        <div class="well">

            <h2>July 2017</h2>

            <p class="archive">
            <a href="/mad-combinatoric-castles.html">Mad Combinatoric Castles</a>
            </p>
            <p class="archive">
            <a href="/project-euler-problem-1.html">Project Euler Problem 1</a>
            </p>
            <p class="archive">
            <a href="/shortest-lattice-paths-and-multiset-permutations.html">Shortest Lattice Paths and Multiset Permutations</a>
            </p>
            <p class="archive">
            <a href="/computing-square-roots-part-2-using-continued-fractions.html">Computing Square Roots: Part 2: Using Continued Fractions</a>
            </p>
            <p class="archive">
            <a href="/computing-square-roots-part-1-using-newtons-method.html">Computing Square Roots: Part 1: Using Newton's Method</a>
            </p>

        </div>

        <div class="v20"></div>


        <div class="well">

            <h2>June 2017</h2>

            <p class="archive">
            <a href="/cse-143-final-project-hilbert-sort-3-the-code.html">CSE 143 Final Project: Hilbert Sort: 3. The Code</a>
            </p>
            <p class="archive">
            <a href="/cse-143-final-project-hilbert-sort-2-the-solution-algorithm.html">CSE 143 Final Project: Hilbert Sort: 2. The Solution Algorithm</a>
            </p>
            <p class="archive">
            <a href="/cse-143-final-project-hilbert-sort-1-the-problem.html">CSE 143 Final Project: Hilbert Sort: 1. The Problem</a>
            </p>
            <p class="archive">
            <a href="/cse-143-final-project-classy.html">CSE 143 Final Project: Classy</a>
            </p>
            <p class="archive">
            <a href="/cse-143-final-project-checkers.html">CSE 143 Final Project: Checkers</a>
            </p>

        </div>

        <div class="v20"></div>


        <div class="well">

            <h2>May 2017</h2>

            <p class="archive">
            <a href="/teaching-recursion-with-the-n-queens-problem.html">Teaching Recursion with the N Queens Problem</a>
            </p>
            <p class="archive">
            <a href="/undergraduate-research-project-wireless-sensor-networks-for-internet-of-things-applications-part-2-the-technologies.html">Undergraduate Research Project: Wireless Sensor Networks for Internet of Things Applications (Part 2: The Technologies)</a>
            </p>
            <p class="archive">
            <a href="/undergraduate-research-project-wireless-sensor-networks-for-internet-of-things-applications-part-1-the-project.html">Undergraduate Research Project: Wireless Sensor Networks for Internet of Things Applications (Part 1: The Project)</a>
            </p>

        </div>

        <div class="v20"></div>


        <div class="well">

            <h2>April 2017</h2>

            <p class="archive">
            <a href="/stunnel.html">Stunnel</a>
            </p>
            <p class="archive">
            <a href="/traveling-schoolteacher-problem.html">Traveling Schoolteacher Problem</a>
            </p>
            <p class="archive">
            <a href="/the-z-machine-a-simple-turing-machine.html">The Z-Machine: A Simple Turing Machine</a>
            </p>
            <p class="archive">
            <a href="/awsome-day-seattle-notes-part-2-networking-security-and-miscellany.html">AWSome Day Seattle Notes: Part 2: Networking, Security, and Miscellany</a>
            </p>
            <p class="archive">
            <a href="/awsome-day-seattle-notes-part-1-the-basics.html">AWSome Day Seattle Notes: Part 1: The Basics</a>
            </p>
            <p class="archive">
            <a href="/setting-up-a-self-hosted-github-clone-with-gitea.html">Setting Up a Self-Hosted Github Clone with Gitea</a>
            </p>
            <p class="archive">
            <a href="/better-timing-of-guava-traveling-salesperson-problem-code-timing-scripts.html">Better Timing of Guava Traveling Salesperson Problem Code: Timing Scripts</a>
            </p>

        </div>

        <div class="v20"></div>


        <div class="well">

            <h2>March 2017</h2>

            <p class="archive">
            <a href="/fixing-bottlenecks-in-the-guava-traveling-salesperson-problem-code.html">Fixing Bottlenecks in the Guava Traveling Salesperson Problem Code</a>
            </p>
            <p class="archive">
            <a href="/python-vs-perl-n-queens-problem.html">Python vs. Perl: N Queens Problem</a>
            </p>
            <p class="archive">
            <a href="/solving-the-traveling-salesperson-problem-with-java-and-guava.html">Solving the Traveling Salesperson Problem with Java and Guava</a>
            </p>
            <p class="archive">
            <a href="/perl-vs-java-n-queens-problem.html">Perl vs. Java: N Queens Problem</a>
            </p>
            <p class="archive">
            <a href="/enigma-cipher-implementation-part-4-combinatorics.html">Enigma Cipher Implementation: Part 4: Combinatorics</a>
            </p>
            <p class="archive">
            <a href="/enigma-cipher-implementation-part-3-enigma-in-java-without-objects.html">Enigma Cipher Implementation: Part 3: Enigma in Java Without Objects</a>
            </p>
            <p class="archive">
            <a href="/enigma-cipher-implementation-part-2-pseudocode.html">Enigma Cipher Implementation: Part 2: Pseudocode</a>
            </p>
            <p class="archive">
            <a href="/enigma-cipher-implementation-part-1-how-it-works.html">Enigma Cipher Implementation: Part 1: How It Works</a>
            </p>

        </div>

        <div class="v20"></div>



<div class="v100"></div>
        </div>

    </div>



</div>



<script type="text/javascript" src="/theme/js/jquery-1.11.2.js"></script>
<script type="text/javascript" src="/theme/js/bootstrap-3.3.4.js"></script>
<script type="text/javascript" src="/theme/js/d3-3.5.5.js"></script>
<!--
<script type="text/javascript" src="/theme/js/leaflet-0.7.3.js"></script>
<script type="text/javascript" src="/theme/js/leaflet.ajax.min.js"></script>
--><script type="text/javascript" src="/theme/js/jquery-1.11.2.js"></script>
<script type="text/javascript" src="/theme/js/bootstrap-3.3.4.js"></script>

<footer id="contentinfo" class="body">
<p>&nbsp;</p>
<p>&nbsp;</p>
<center>
	<hr />
</center>
<p>&nbsp;</p>
<p style="text-align: center">
    <span class="fa-stack fa-lg">
        <i class="fa fa-square fa-stack-2x" style="color:#000;"></i>
        <i class="fa fa-terminal fa-stack-1x fa-inverse"></i>
    </span>
    Made from the command line with vim by 
    <a href="http://charlesreid1.com">charlesreid1</a><br />
    with help from <a href="https://getbootstrap.com/">Bootstrap</a> and <a href="http://getpelican.com">Pelican</a>.
</p>

<br />

<p style="text-align: center">
    <a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/">
    <span class="fa-stack fa-lg">
        <i class="fa fa-square fa-stack-2x" style="color:#000;"></i>
        <i class="fa fa-creative-commons fa-stack-1x fa-inverse"></i>
    </span>
    </a>
    <br />
    Licensed under the <a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/">Creative Commons Attribution-NonCommercial 4.0 License</a>.
</p>

<!-- Start of StatCounter Code for Default Guide -->
<script type="text/javascript">
var sc_project=11611748;
var sc_invisible=1;
var sc_security="9fcba820";
</script>
<script type="text/javascript"
src="https://www.statcounter.com/counter/counter.js"
async></script>

<noscript><div class="statcounter"><a title="Web Analytics"
href="http://statcounter.com/" target="_blank"><img
class="statcounter"
src="//c.statcounter.com/11611748/0/9fcba820/1/" alt="Web
Analytics"></a></div></noscript>
<!-- End of StatCounter Code for Default Guide -->
</footer><!-- /#contentinfo -->
</body>
</html>