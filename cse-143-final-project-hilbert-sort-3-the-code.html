<!DOCTYPE html>
<html lang="en">
<head>
        <title>charlesreid1</title>
        <meta charset="utf-8" />

        <!--
        CSS styles
        -->
        <link href="/theme/css/bootstrap.css"       rel="stylesheet" type="text/css">
        <link href="/theme/css/slate.css"              rel="stylesheet" type="text/css">
        <link href="/theme/css/font-awesome.css"       rel="stylesheet" type="text/css"/>
        <link href="/theme/css/pygment-solarized.css"  rel="stylesheet" type="text/css"/>

        <!--
        my CSS styles
        -->
        <link href="/theme/css/main.css"            rel="stylesheet" type="text/css">
        <link href="/theme/css/dox.css"             rel="stylesheet" type="text/css">


        <!--
        include Angular first
        -->
        <script type="text/javascript" src="/theme/js/angular-1.3.15.js"></script>
        <script type="text/javascript" src="/theme/js/skrollr-0.6.29.js"></script>
        <script type="text/javascript" src="/theme/js/d3-3.5.5.js"></script>

        <!--
        this seems like a bad idea.
        but if I don't put jquery first, I get errors about unrecognized $s.
        -->
        <script type="text/javascript" src="/theme/js/jquery-1.11.2.js"></script>

</head>
<body id="index">
<nav class="navbar navbar-default">
    <div class="container-fluid">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#myNavbar">
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span> 
            </button>
            <a href="https://charlesreid1.github.io" class="navbar-brand">charlesreid1.github.io</a>
        </div>
        <div>
            <div class="collapse navbar-collapse" id="myNavbar">
                <ul class="nav navbar-nav">

                    <li>
                        <a href="https://charlesreid1.com/wiki">Wiki</a>
                    </li>
                    <li>
                        <a href="https://git.charlesreid1.com/explore">git.charlesreid1.com</a>
                    </li>
                    <li>
                        <a href="https://github.com/charlesreid1/charlesreid1-awesome/">charlesreid1 Awesome List</a>
                    </li>
                    <li>
                        <a href="https://charlesreid1.com/life">Life</a>
                    </li>
                    <li>
                        <a href="https://charlesreid1.github.io">Blog</a>
                    </li>
                    <li>
                        <a href="/contact">Contact Me</a>
                    </li>

                </ul>
            </div>
        </div>
    </div>
</nav>



<div class="container">

<header>
<div class="row">


    <div class="col-md-12">
        <div class="headtext" style="text-align: center;">
            <h1><b>
                CSE 143 Final Project: Hilbert Sort: 3. The Code
            </b></h1>
        
            <p class="lead">
                Posted 
                <time datetime="2017-06-30T20:00:00-07:00" pubdate>Friday 06/30/2017</time>
                in 
                <a href="/category/computer-science.html">Computer Science</a>
                </p>
            <p>
            <span style="font-size: 14px">
                <a href="/cse-143-final-project-hilbert-sort-3-the-code.html">permalink</a>
            </span>
            </p>
        </div>

    </div>

</div>
</header>


<div class="v50"></div>


<div class="row">
    <div class="col-md-12" style="text-align: left;">

        <div class="entry-content"><h1>Table of Contents</h1>
<p>This is the third in a series of three posts 
detailing the Hilbert Sort problem,
its solution, and its implementation.
This post deals with the code to solve the
Hilbert Sort problem.</p>
<ul>
<li>
<p><a href="#hilbert3-pseudocode">Pseudocode</a></p>
</li>
<li>
<p><a href="#hilbert3-code">Code</a></p>
<ul>
<li><a href="#hilbert3-utility">Utility Classes</a></li>
<li><a href="#hilbert3-recursive">Recursive Sort Function</a></li>
<li><a href="#hilbert3-main">Main Method</a></li>
</ul>
</li>
<li>
<p><a href="#hilbert2-references">References</a></p>
</li>
</ul>
<p><a name="hilbert3-pseudocode"></a></p>
<h1>Hilbert Sort: Pseudocode</h1>
<p>From our prior post, here is the psudocode for our Hilbert Sort function:</p>
<div class="highlight"><pre><span></span>define hilbert_sort( unsorted queue, square dimension ):
    create southwest queue
    create northwest queue
    create northeast queue
    create southeast queue
    for each point:
        if in southwest:
            create new point using X -&gt; Y, Y -&gt; X
            add to southwest queue
        if in northwest:
            create new point using X -&gt; 2X, Y -&gt; 2Y - S
            add to northwest queue
        if in northeast:
            create new point using X -&gt; 2X - S, Y -&gt; 2Y - S
            add to northeast queue
        if in southeast:
            create new point using X -&gt; S - 2Y, Y -&gt; 2S - 2X
            add to southeast queue

        hilbertsort(southwest queue, square dimension)
        hilbertsort(northwest queue, square dimension)
        hilbertsort(northeast queue, square dimension)
        hilbertsort(southeast queue, square dimension)

        create new results queue
        add points from southwest into results queue
        add points from northwest into results queue
        add points from northeast into results queue
        add points from southeast into results queue
        return results queue
</pre></div>


<p>Because we are manually sorting, and we want order to be preserved,
we should be using a queue to organize points as we sort them.
That way, we add them in sorted order, and we are then able to remove
them in sorted order.</p>
<p><a name="hilbert3-code"></a></p>
<h1>Hilbert Sort: Code</h1>
<p>We begin by covering a utility class used by the Hilbert Sort method
to store <span class="math">\((X,Y)\)</span> points. This is a simple example of a composition 
design pattern. Next, we cover the bulk of the problem solution: 
the recursive sort method that partiions points into quadrants.
Finally, we cover the main method, which demonstrates reading data
from an input file and passing it to the sort method.</p>
<p><a name="hilbert3-utility"></a></p>
<h2>Hilbert Sort: Utility Classes</h2>
<p>To organize <span class="math">\((X,Y)\)</span> point data, we use a simple class
using composition. This is defined next to the HilbertSort 
class.</p>
<div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm"> * An (x,y) Point class. </span>
<span class="cm"> */</span>
<span class="kr">class</span> <span class="nx">Point</span> <span class="p">{</span>
    <span class="kr">int</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">;</span> <span class="c1">// (x,y) point.</span>
    <span class="nb">String</span> <span class="nx">name</span><span class="p">;</span> <span class="c1">// Each (x,y) point has a name in the file. Used for output.</span>
    <span class="cm">/** Constructor. */</span>
    <span class="kr">public</span> <span class="nx">Point</span><span class="p">(</span><span class="kr">int</span> <span class="nx">x</span><span class="p">,</span> <span class="kr">int</span> <span class="nx">y</span><span class="p">,</span> <span class="nb">String</span> <span class="nx">name</span><span class="p">)</span> <span class="p">{</span> 
        <span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="nx">x</span><span class="p">;</span> <span class="k">this</span><span class="p">.</span><span class="nx">y</span> <span class="o">=</span> <span class="nx">y</span><span class="p">;</span> <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="cm">/** String representation (x,y). */</span>
    <span class="kr">public</span> <span class="nb">String</span> <span class="nx">toString() {</span> 
        <span class="k">return</span> <span class="s2">&quot;(&quot;</span><span class="o">+</span><span class="k">this</span><span class="p">.</span><span class="nx">x</span><span class="o">+</span><span class="s2">&quot;,&quot;</span><span class="o">+</span><span class="k">this</span><span class="p">.</span><span class="nx">y</span><span class="o">+</span><span class="s2">&quot;,&quot;</span><span class="o">+</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="o">+</span><span class="s2">&quot;)&quot;</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p><a name="hilbert3-recursive"></a></p>
<h2>Recursive Sort Function</h2>
<p>Following is the recursive sort method, which (like merge sort)
consists of a split step, which partitions an <span class="math">\(S \times S\)</span> 
square into quadrants and distributes points in the square into their
corresponding quadrants, and a merge step, which stitches together
each quadrant in the correct order. </p>
<div class="highlight"><pre><span></span>    /** Recursive implementation of a Hilbert sort. */
    public static Queue&lt;Point&gt; hilbertSort(Queue&lt;Point&gt; inputP, int S) {
        // Recursive method:
        // Apply the Hilbert geometrical quadrant division 
        // to sort points by when they are visited by a Hilbert curve.
        //
        // Base case: 
        // There are 1 or fewer points in each quadrant.
        // Keep splitting into quadrants until we reach the base case. 
        if(inputP.size()&lt;1) {
            return new LinkedList&lt;Point&gt;();
        } else if(inputP.size()==1) {
            return inputP;
        }

        // split by quadrant
        Queue&lt;Point&gt; qSW = new LinkedList&lt;Point&gt;();
        Queue&lt;Point&gt; qNW = new LinkedList&lt;Point&gt;();
        Queue&lt;Point&gt; qNE = new LinkedList&lt;Point&gt;();
        Queue&lt;Point&gt; qSE = new LinkedList&lt;Point&gt;();

        // Sort points by dividing into quadrants
        for(Point p : inputP) { 

            // Prepare for the tricky part.
            //
            // Rotate the quadrant, and points in it,
            // so that everything is now translated to fit
            // how the template of the Hilbert curve is being drawn.
            // (SW-&gt;NW-&gt;NE-SE)

            boolean inSWquadrant = (2*p.x &lt;= S) &amp;&amp; (2*p.y &lt;= S);
            boolean inNWquadrant = (2*p.x &lt;= S) &amp;&amp; (2*p.y &gt;= S);

            boolean inNEquadrant = (2*p.x &gt;= S) &amp;&amp; (2*p.y &gt;= S);
            boolean inSEquadrant = (2*p.x &gt;= S) &amp;&amp; (2*p.y &lt;= S);

            // Each time we sort (x,y) points into quadrants,
            // we also transform each coordinate point 
            // in such a way that it rescales to an S x S square,
            // but does not modify the order of the points. 
            //
            // Note that we can keep everything as integers by
            // continuing to look at an S x S square,
            // and double the x and y values to shift them over/up.
            //
            // Two easy cases:
            if(inNWquadrant) {
                // Northwest quadrant: 
                // - shift y down by S/2
                // - keep x and y in same order
                qNW.add( new Point(2*p.x, 2*p.y-S, p.name) );

            } else if(inNEquadrant) {
                // Northeast quadrant:
                // - shift x and y down by S/2
                // - keep x and y in same order
                qNE.add( new Point(2*p.x - S, 2*p.y - S, p.name) );

            } else if(inSWquadrant) { 
                // Southwest quadrant:
                // - x and y need to swap places 
                // - that&#39;s it.
                qSW.add( new Point(2*p.y, 2*p.x, p.name) );

            } else if(inSEquadrant) { 
                // Southeast quadrant:
                // - trickiest quadrant.
                // - We want to preserve S - x, distance from right side
                // - we want to use it as the new y coordinate
                qSE.add( new Point(S - 2*p.y, 2*(S - p.x), p.name) );

            }

        }
        // Sort til you reach the base case.
        qSW = hilbertSort(qSW, S); 
        qNW = hilbertSort(qNW, S); 
        qNE = hilbertSort(qNE, S); 
        qSE = hilbertSort(qSE, S);

        Queue&lt;Point&gt; result = new LinkedList&lt;Point&gt;();
        for(Point q : qSW) result.add(q);
        for(Point q : qNW) result.add(q);
        for(Point q : qNE) result.add(q); 
        for(Point q : qSE) result.add(q);

        return result;
    }
</pre></div>


<p><a name="hilbert3-main"></a></p>
<h2>Main Method</h2>
<p>The last part of the code is the portion that loads the points and their labels 
from a file, and populates a Queue of Point objects from it.
This queue of points is then sorted and returned in order.</p>
<div class="highlight"><pre><span></span>    /** Main driver. */
    public static void main(String[] args) { 

        Scanner stdin = new Scanner(new BufferedReader(new InputStreamReader(System.in)));

        int n = stdin.nextInt();
        int S = stdin.nextInt();

        // n lines of 3 tokens each
        Queue&lt;Point&gt; inputPoints = new LinkedList&lt;Point&gt;();
        for(int i=0; i&lt;n; i++) { 
            int x0 = stdin.nextInt();
            int y0 = stdin.nextInt();
            String label = stdin.next();
            inputPoints.add(new Point(x0,y0,label));
        }
        Queue&lt;Point&gt; sortedPoints = hilbertSort(inputPoints, S);
        for(Point p : sortedPoints) { 
            System.out.println(p.name);
        }
    }
</pre></div>


<p><a name="hilbert3-refs"></a></p>
<h1>References</h1>
<ol>
<li>
<p>"ACM Pacific Region Programming Competition." Association of Computing Machinery. Accessed 19 June 2017.
&lt;<a href="http://acmicpc-pacnw.org/">http://acmicpc-pacnw.org/</a>&gt;</p>
</li>
<li>
<p>"Hilbert Sort." Git repository, git.charlesreid1.com. Charles Reid. Updated 16 June 2017.
&lt;<a href="https://git.charlesreid1.com/cs/finalproject-143/src/master/hilbert/HilbertSort.java">https://git.charlesreid1.com/cs/finalproject-143/src/master/hilbert/HilbertSort.java</a>&gt;</p>
</li>
</ol>
<script type="text/javascript">if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width < 768) ? "left" : align;
        indent = (screen.width < 768) ? "0em" : indent;
        linebreak = (screen.width < 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
</script></div>

    </div>
</div>

<div class="v20"></div>

<div class="row">
    <div class="col-md-12" style="text-align: left;">

        <div class="tags">
            <p>Tags:&nbsp;&nbsp;&nbsp;
                    <a href="/tag/programming.html">programming</a>
                    &nbsp;&nbsp;
                    <a href="/tag/computer-science.html">computer science</a>
                    &nbsp;&nbsp;
                    <a href="/tag/final-project.html">final project</a>
                    &nbsp;&nbsp;
                    <a href="/tag/competitive-programming.html">competitive programming</a>
                    &nbsp;&nbsp;
                    <a href="/tag/hilbert-sort.html">hilbert sort</a>
                    &nbsp;&nbsp;
                    <a href="/tag/java.html">java</a>
                    &nbsp;&nbsp;
        </div>

    </div>
</div>


<div class="v200"></div>

</div>


<script type="text/javascript" src="/theme/js/jquery-1.11.2.js"></script>
<script type="text/javascript" src="/theme/js/bootstrap-3.3.4.js"></script>
<script type="text/javascript" src="/theme/js/d3-3.5.5.js"></script>
<!--
<script type="text/javascript" src="/theme/js/leaflet-0.7.3.js"></script>
<script type="text/javascript" src="/theme/js/leaflet.ajax.min.js"></script>
--><script type="text/javascript" src="/theme/js/jquery-1.11.2.js"></script>
<script type="text/javascript" src="/theme/js/bootstrap-3.3.4.js"></script>

<footer id="contentinfo" class="body">
<p>&nbsp;</p>
<p>&nbsp;</p>
<center>
	<hr />
</center>
<p>&nbsp;</p>
<p style="text-align: center">
    <span class="fa-stack fa-lg">
        <i class="fa fa-square fa-stack-2x" style="color:#000;"></i>
        <i class="fa fa-terminal fa-stack-1x fa-inverse"></i>
    </span>
    Made from the command line with vim by 
    <a href="http://charlesreid1.com">charlesreid1</a><br />
    with help from <a href="https://getbootstrap.com/">Bootstrap</a> and <a href="http://getpelican.com">Pelican</a>.
</p>

<br />

<p style="text-align: center">
    <a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/">
    <span class="fa-stack fa-lg">
        <i class="fa fa-square fa-stack-2x" style="color:#000;"></i>
        <i class="fa fa-creative-commons fa-stack-1x fa-inverse"></i>
    </span>
    </a>
    <br />
    Licensed under the <a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/">Creative Commons Attribution-NonCommercial 4.0 License</a>.
</p>

<!-- Start of StatCounter Code for Default Guide -->
<script type="text/javascript">
var sc_project=11611748;
var sc_invisible=1;
var sc_security="9fcba820";
</script>
<script type="text/javascript"
src="https://www.statcounter.com/counter/counter.js"
async></script>

<noscript><div class="statcounter"><a title="Web Analytics"
href="http://statcounter.com/" target="_blank"><img
class="statcounter"
src="//c.statcounter.com/11611748/0/9fcba820/1/" alt="Web
Analytics"></a></div></noscript>
<!-- End of StatCounter Code for Default Guide -->
</footer><!-- /#contentinfo -->
</body>
</html>