<!DOCTYPE html>
<html lang="en">
<head>
        <title>charlesreid1</title>
        <meta charset="utf-8" />

        <!--
        CSS styles
        -->
        <link href="/theme/css/bootstrap.css"       rel="stylesheet" type="text/css">
        <!--
        <link href="/theme/css/cyborg.css"          rel="stylesheet" type="text/css">
        <link href="/theme/css/cosmo.css"           rel="stylesheet" type="text/css">
        <link href="/theme/css/sandstone.css"       rel="stylesheet" type="text/css">
        -->
        <link href="/theme/css/slate.css"              rel="stylesheet" type="text/css">
        <link href="/theme/css/font-awesome.css"       rel="stylesheet" type="text/css"/>
        <link href="/theme/css/pygment-solarized.css"  rel="stylesheet" type="text/css"/>


        <!--
        my CSS styles
        -->
        <link href="/theme/css/main.css"            rel="stylesheet" type="text/css">
        <link href="/theme/css/dox.css"             rel="stylesheet" type="text/css">


        <!--
        include Angular first
        -->
        <script type="text/javascript" src="/theme/js/angular-1.3.15.js"></script>
        <script type="text/javascript" src="/theme/js/skrollr-0.6.29.js"></script>
        <script type="text/javascript" src="/theme/js/d3-3.5.5.js"></script>

        <!--
        this seems like a bad idea.
        but if I don't put jquery first, I get errors about unrecognized $s.
        -->
        <script type="text/javascript" src="/theme/js/jquery-1.11.2.js"></script>

</head>
<body id="index">
<nav class="navbar navbar-default">
    <div class="container-fluid">
        <div class="navbar-header">
            <!--
            http://www.w3schools.com/bootstrap/bootstrap_case_navigation.asp
            -->
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#myNavbar">
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span> 
            </button>
            <a href="/" class="navbar-brand">charlesreid1.com</a>
        </div>
        <div>
            <div class="collapse navbar-collapse" id="myNavbar">
                <ul class="nav navbar-nav">

                    <li>
                        <a href="https://charlesreid1.com/projects">Projects</a>
                    </li>
                    <li>
                        <a href="https://charlesreid1.com/wiki">Wiki</a>
                    </li>
                    <li>
                        <a href="https://charlesreid1.github.io">Research Blog</a>
                    </li>
                    <li>
                        <a href="http://git.charlesreid1.com">git.charlesreid1.com</a>
                    </li>
                    <li>
                        <a href="https://charlesreid1.com/contact">Contact Me</a>
                    </li>

                </ul>
            </div>
        </div>
    </div>
</nav>


<div class="container">

<header>
<div class="row">


    <div class="col-md-12">
        <div class="headtext" style="text-align: center;">
            <h1><b>
                Solving the Traveling Salesperson Problem with Java and Guava
            </b></h1>
        
            <p class="lead">
                Posted 
                <time datetime="2017-03-23T11:00:00-07:00" pubdate>Thursday 03/23/2017</time>
                in 
                <a href="/category/java.html">Java</a>
                </p>
            <p>
            <span style="font-size: 14px">
                <a href="/solving-the-traveling-salesperson-problem-with-java-and-guava.html">permalink</a>
            </span>
            </p>
        </div>

    </div>

</div>
</header>


<div class="v50"></div>


<div class="row">
    <div class="col-md-12" style="text-align: left;">

        <div class="entry-content"><ul>
<li><a href="#bkg">Background: Traveling Salesperson Problem (TSP)</a></li>
<li><a href="#bktk">Solution: Recursive Backtracking</a> </li>
<li><a href="#guava">Solving the TSP with Java and Guava</a> <ul>
<li><a href="#basic-guava">Basics of Guava</a></li>
<li><a href="#guava-graphs">Guava Graphs</a></li>
<li><a href="#guava-mutable-immutable">Guava Mutable vs Immutable</a></li>
<li><a href="#importing-guava">Importing Guava</a></li>
<li><a href="#tsp-class">TSP Class</a></li>
<li><a href="#node-class">Node Class</a></li>
<li><a href="#edge-class">Edge Class</a></li>
</ul>
</li>
<li><a href="#building-graph">TSP Constructor and Building the Graph</a><ul>
<li><a href="#constructor">Constructor</a></li>
<li><a href="#build-graph-method">Build Graph Method</a></li>
</ul>
</li>
<li><a href="#solving-exploring">Solving and Exploring with Recursive Backtracking</a><ul>
<li><a href="#solve">Solve Method</a></li>
<li><a href="#explore">Explore (Backtrack) Method</a></li>
</ul>
</li>
</ul>
<p><a name="bkg"></a></p>
<h2>Background: Traveling Salesperson Problem (TSP)</h2>
<p>The traveling salesperson problem, or TSP, is a classic programming problem and an important one in computer science,
and applications in operations research and optimization.</p>
<p>The idea is that you have a set of <span class="math">\(N\)</span> cities, connected by various roads, each with their own distances.
That is, we have a set of <span class="math">\(R\)</span> roads, each with their own distance <span class="math">\(d_j, j=1 \dots R\)</span>. There will be an upper limit of <span class="math">\(R = N!\)</span>. </p>
<p>The question is, what is the shortest path that a salesperson can take to visit all <span class="math">\(N\)</span> cities, traveling the shortest possible total distance
and visiting each city once and only once?</p>
<p>Like the N queens problem, the traveling salesperson problem is a good candidate for recursive backtracking.
Also like the N queens problem, there are certain shortcuts we can take to trim down the possibilities we explore.</p>
<p><a href="https://en.wikipedia.org/wiki/Travelling_salesman_problem">Wikipedia article for traveling salesman problem</a></p>
<p><a name="graphs"></a></p>
<h2>Graphs</h2>
<p>Graphs are mathematical objects first utilized by Leonhard Euler to solve the
<a href="https://en.wikipedia.org/wiki/Seven_Bridges_of_K%C3%B6nigsberg">Seven Bridges of KÃ¶ningsberg</a> problem.
The concept is simple: you have a bunch of dots connected with lines.</p>
<p>The dots are called nodes, and the lines are called edges.</p>
<p>Graphs can be directed, meaning the edges are like arrows with particular directions, or undirected, 
meaning the edges simply represent a connection between the two nodes.</p>
<p>Here is an example of a graph with five nodes, with each edge labeled with its distance:</p>
<p><img style="background:#fff;" alt="A basic graph with five nodes" src="/images/basic-graph.png" /></p>
<p><a name="bktk"></a></p>
<h2>Solution: Recursive Backtracking</h2>
<p>Here is pseudocode for a recursive backtracking method:</p>
<div class="highlight"><pre><span></span>explore(neighbors):

    if(no more unvisited neighbors):
        # This is the base case.
        if total distance is less than current minimum:
            save path and new minimum

    else:
        # This is the recursive case.
        for neighbor in unvisited neighbors:
            visit neighbor
            explore(new_neighbors)
            unvisit neighbor
</pre></div>


<p>Care is needed to prevent infinite loops in which the traveling salesperson goes back and forth between two cities.
As we traverse the graph, we can mark each node as visited, to ensure we don't revisit nodes and go in circles.</p>
<p>Nodes can be implemented as a <code>Node</code> object in Java, with each Node having a few characteristics:</p>
<ul>
<li>String label</li>
<li>Container of Node pointers pointing to neighbors</li>
<li>Boolean flag: have we visited this node already?</li>
</ul>
<p>Likewise, the graph edges can be represented using integers or doubles.</p>
<p><a name="guava"></a></p>
<h2>Solving the TSP with Java and Guava</h2>
<p><a href="https://github.com/google/guava">Google Guava</a> is a library of high-performance data containers in Java.
The library provides some useful graph objects that we can use to easily solve the TSP on a graph.</p>
<p><a name="basic-guava"></a></p>
<h3>Basics of Guava</h3>
<p>Install and use Guava by visiting the <a href="https://github.com/google/guava">Guava project on Github</a>, 
find the page for their latest release (<a href="https://github.com/google/guava/wiki/Release21">here is version 21.0</a>), 
and getting the latest <code>.jar</code> file.</p>
<p>To compile with the jar file, you can either utilize an IDE like <a href="http://www.eclipse.org/">Eclipse</a> or <a href="https://www.jetbrains.com/idea/">IntelliJ</a>,
or you can compile from the command line, specifying the class path using the <code>-cp</code> flag:</p>
<div class="highlight"><pre><span></span>$ javac -cp <span class="s1">&#39;.:/path/to/guava/jars/guava-21.0.jar&#39;</span> TSP.java
$ java -cp <span class="s1">&#39;.:/path/to/guava/jars/guava-21.0.jar&#39;</span> TSP
</pre></div>


<p>More information can be found on the charlesreid1.com wiki: <a href="https://charlesreid1.com/wiki/Guava">Guava</a></p>
<p><a name="guava-graphs"></a></p>
<h3>Guava Graphs</h3>
<p>Graph objects in Guava are implemented using a set of objects: Graphs, ValueGraphs, and Networks.</p>
<p>Graph objects treat edges as very simple and assumes they contain no information and simply link nodes. </p>
<p>ValueGraphs associate a single non-unique value with each edge on the graph. This can also be used to solve the TSP.</p>
<p>Network objects treat nodes and edges both as objects, and has the ability to deal with more complex edges: model multi-edges, repeated edges, directed edges, etc.</p>
<p>We will use a Network object and design our own graph Node and Edge objects.</p>
<p><a href="https://github.com/google/guava/wiki/GraphsExplained#building-graph-instances">Link to Guava wiki on how to build graph instances</a></p>
<p><a href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/graph/Network.html">Guava API Documentation: Network</a></p>
<p><a href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/graph/Graph.html">Guava API Documentation: Graph</a></p>
<p><a href="http://google.github.io/guava/releases/snapshot/api/docs/com/google/common/graph/ValueGraph.html">Guava API Documentation: ValueGraph</a></p>
<p><a name="guava-mutable-immutable"></a></p>
<h3>Guava Mutable vs Immutable</h3>
<p>Guava makes a distinction between mutable graphs, which can be modified, and immutable graphs, which cannot.
Immutability provides some safety and assurances to programmers, and can make things faster.</p>
<p>When we construct the network, we need a mutable graph to modify (add nodes and edges). 
But once the network is constructed, it is finished: we don't need to modify the network while we're solving the problem.</p>
<p>Therefore, we construct a mutable network, assemble the graph for the given problem, and copy it into an immutable graph.
We then use the immutable graph to access the graph while solving.</p>
<p><a name="importing-guava"></a></p>
<h3>Importing Guava</h3>
<p>Starting with import statements, we'll use a couple of objects from the Java API, and from Google's Guava library:</p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">java.util.Set</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Map</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.TreeMap</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">com.google.common.graph.Network</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">com.google.common.graph.NetworkBuilder</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">com.google.common.graph.ImmutableNetwork</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">com.google.common.graph.MutableNetwork</span><span class="o">;</span>
</pre></div>


<p>For more info on why we don't just do the lazier</p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">com.google.common.graph.*</span><span class="o">;</span>
</pre></div>


<p>see <a href="https://google.github.io/styleguide/javaguide.html">Google's Java style guide</a>.</p>
<p><a name="tsp-class"></a></p>
<h3>TSP Class</h3>
<p>Let's lay out the TSP class definition. This class is simple, and wraps a few pieces of data:
the current route, the current distance, and the minimum distance.
Note that we could also save the solution in a container, instead of printing it,
by defining a static class to hold solutions, but we'll keep it simple.</p>
<div class="highlight"><pre><span></span><span class="cm">/** This class solves the traveling salesman problem on a graph. */</span>
<span class="kd">class</span> <span class="nc">TSP</span> <span class="o">{</span>
    <span class="c1">// The actual graph of cities</span>
    <span class="n">ImmutableNetwork</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">,</span><span class="n">Edge</span><span class="o">&gt;</span> <span class="n">graph</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">graphSize</span><span class="o">;</span>

    <span class="c1">// Storage variables used when searching for a solution </span>
    <span class="n">String</span><span class="o">[]</span> <span class="n">route</span><span class="o">;</span>         <span class="c1">// store the route</span>
    <span class="kt">double</span> <span class="n">this_distance</span><span class="o">;</span>   <span class="c1">// store the total distance</span>
    <span class="kt">double</span> <span class="n">min_distance</span><span class="o">;</span>    <span class="c1">// store the shortest path found so far</span>

    <span class="cm">/** Defaut constructor generates the graph and initializes storage variables */</span>
    <span class="kd">public</span> <span class="nf">TSP</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">// TODO</span>
    <span class="o">}</span>

    <span class="cm">/** This method actually constructs the graph. */</span>
    <span class="kd">public</span> <span class="n">ImmutableNetwork</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">,</span><span class="n">Edge</span><span class="o">&gt;</span> <span class="nf">buildGraph</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">// TODO</span>
    <span class="o">}</span>

    <span class="cm">/** Public solve method will call the recursive backtracking method to search for solutions on the graph */</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">solve</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">// TODO</span>
    <span class="o">}</span>

    <span class="cm">/** Recursive backtracking method: explore possible solutions starting at this node, having made nchoices */</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">explore</span><span class="o">(</span><span class="n">Node</span> <span class="n">node</span><span class="o">,</span> <span class="kt">int</span> <span class="n">nchoices</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// TODO</span>
    <span class="o">}</span>

    <span class="cm">/** Print out solution */</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">printSolution</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">// TODO</span>
    <span class="o">}</span>

    <span class="cm">/** Print out failed path */</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">printFailure</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">// TODO</span>
    <span class="o">}</span>
</pre></div>


<p><a name="node-class"></a></p>
<h3>Node Class (Cities)</h3>
<p>Now we can define the Node class to represent cities on the graph.</p>
<div class="highlight"><pre><span></span><span class="kd">class</span> <span class="nc">Node</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="n">String</span> <span class="n">label</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="n">visited</span><span class="o">;</span> <span class="c1">// Helps us to keep track of where we&#39;ve been on the graph</span>
    <span class="kd">public</span> <span class="nf">Node</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">){</span>
        <span class="k">this</span><span class="o">.</span><span class="na">label</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">visited</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">visit</span><span class="o">(){</span>
        <span class="k">this</span><span class="o">.</span><span class="na">visited</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">unvisit</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">visited</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>


<p>Like a lined list node, we want to keep graph nodes simple. 
Note that Nodes don't need to store information about their neighbors.
That's what we'll use Google Guava for!</p>
<p><a name="edge-class"></a></p>
<h3>Edge Class (Roads)</h3>
<p>Edge classes are even simpler, wrapping a single integer:</p>
<div class="highlight"><pre><span></span><span class="kd">class</span> <span class="nc">Edge</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="n">value</span><span class="o">;</span>
    <span class="kd">public</span> <span class="n">String</span> <span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">;</span> <span class="c1">// For convenience in construction process. Not necessary.</span>
    <span class="kd">public</span> <span class="nf">Edge</span><span class="o">(</span><span class="n">String</span> <span class="n">left</span><span class="o">,</span> <span class="n">String</span> <span class="n">right</span><span class="o">,</span> <span class="kt">int</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">left</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">right</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>


<p>Note that left and right are used for convenience only during the graph construction process.
Like the nodes, the edges don't need to know who their neighbors are, 
since that's what the Google Guava graph object will take care of.</p>
<p><a name="building-graph"></a></p>
<h2>TSP Constructor and Building the Graph</h2>
<p><a name="constructor"></a></p>
<h3>Constructor</h3>
<p>The TSP class constructor should do a few things:</p>
<ul>
<li>Construct a graph, with a given set of cities and distances.</li>
<li>Initialize arrays and cumulative variables that will be used by the backtracking method.</li>
</ul>
<p>The actual graph construction process is put into another function called <code>buildGraph()</code>,
so really the constructor just calls a function and then does #2.</p>
<div class="highlight"><pre><span></span>    <span class="cm">/** Defaut constructor generates the graph and initializes storage variables */</span>
    <span class="kd">public</span> <span class="nf">TSP</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">// Build the graph</span>
        <span class="k">this</span><span class="o">.</span><span class="na">graph</span> <span class="o">=</span> <span class="n">buildGraph</span><span class="o">();</span>
        <span class="k">this</span><span class="o">.</span><span class="na">graphSize</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">graph</span><span class="o">.</span><span class="na">nodes</span><span class="o">().</span><span class="na">size</span><span class="o">();</span>

        <span class="c1">// Initialize route variable, shared across recursive method instances</span>
        <span class="k">this</span><span class="o">.</span><span class="na">route</span> <span class="o">=</span> <span class="k">new</span> <span class="n">String</span><span class="o">[</span><span class="k">this</span><span class="o">.</span><span class="na">graphSize</span><span class="o">];</span>

        <span class="c1">// Initialize distance variable, shared across recursive method instances</span>
        <span class="k">this</span><span class="o">.</span><span class="na">this_distance</span> <span class="o">=</span> <span class="mf">0.0</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">min_distance</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span><span class="o">;</span> <span class="c1">// negative min means uninitialized</span>
    <span class="o">}</span>
</pre></div>


<p><a name="build-graph-method"></a></p>
<h3>Build Graph Method</h3>
<p>Now we actually use Guava's Immutable Network object,
which takes two templated types, T1 and T2, 
which correspond to the node types and the edge types.</p>
<p>We use a NetworkBuilder object to build the Network 
(an example of the factory template).
This returns a MutableNetwork of Node and Edge objects,
which we can then connect up using some built-in methods.</p>
<p>Here are some built-in methods available for a MutableNetwork:</p>
<div class="highlight"><pre><span></span>    addEdge(node1, node2, edge)
    addNode(node1)
    removeEdge(edge)
    removeNode(node)
</pre></div>


<p>Now here is the construction of the graph, using the Google Guava library.
There are two loops here: one for cities, and one for edges.
In the loop over each city,we create a new node and add it to the graph.
To be able to easily retrieve the Nodes we have created, 
we also store references to the nodes in a map called <code>all_nodes</code>.</p>
<p>When we construct edges, we use the map of all nodes <code>all_nodes</code> to get references to the Node objects
that correspond to a label. That way, if an edge connects "A" with "B" at a distance of 24, 
we can turn "A" and "B" into references to the Node objects A and B.</p>
<div class="highlight"><pre><span></span>    <span class="cm">/** This method actually constructs the graph. */</span>
    <span class="kd">public</span> <span class="n">ImmutableNetwork</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">,</span><span class="n">Edge</span><span class="o">&gt;</span> <span class="nf">buildGraph</span><span class="o">()</span> <span class="o">{</span>

        <span class="c1">// MutableNetwork is an interface requiring a type for nodes and a type for edges</span>
        <span class="n">MutableNetwork</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">,</span><span class="n">Edge</span><span class="o">&gt;</span> <span class="n">roads</span> <span class="o">=</span> <span class="n">NetworkBuilder</span><span class="o">.</span><span class="na">undirected</span><span class="o">().</span><span class="na">build</span><span class="o">();</span>

        <span class="c1">// Construct Nodes for cities,</span>
        <span class="c1">// and add them to a map</span>
        <span class="n">String</span><span class="o">[]</span> <span class="n">cities</span> <span class="o">=</span> <span class="o">{</span><span class="s">&quot;A&quot;</span><span class="o">,</span><span class="s">&quot;B&quot;</span><span class="o">,</span><span class="s">&quot;C&quot;</span><span class="o">,</span><span class="s">&quot;D&quot;</span><span class="o">,</span><span class="s">&quot;E&quot;</span><span class="o">};</span>
        <span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span><span class="n">Node</span><span class="o">&gt;</span> <span class="n">all_nodes</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TreeMap</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span><span class="n">Node</span><span class="o">&gt;();</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">cities</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// Add nodes to map</span>
            <span class="n">Node</span> <span class="n">node</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="o">(</span><span class="n">cities</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
            <span class="n">all_nodes</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">cities</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">node</span><span class="o">);</span>

            <span class="c1">// Add nodes to network</span>
            <span class="n">roads</span><span class="o">.</span><span class="na">addNode</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="c1">// Construct Edges for roads,</span>
        <span class="c1">// and add them to a map</span>
        <span class="n">String</span><span class="o">[]</span> <span class="n">distances</span> <span class="o">=</span> <span class="o">{</span><span class="s">&quot;A:B:24&quot;</span><span class="o">,</span><span class="s">&quot;A:C:5&quot;</span><span class="o">,</span><span class="s">&quot;A:D:20&quot;</span><span class="o">,</span><span class="s">&quot;A:E:18&quot;</span><span class="o">,</span><span class="s">&quot;B:C:10&quot;</span><span class="o">,</span><span class="s">&quot;B:D:20&quot;</span><span class="o">,</span><span class="s">&quot;C:D:4&quot;</span><span class="o">,</span><span class="s">&quot;C:E:28&quot;</span><span class="o">,</span><span class="s">&quot;D:E:3&quot;</span><span class="o">};</span>
        <span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span><span class="n">Edge</span><span class="o">&gt;</span> <span class="n">all_edges</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TreeMap</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span><span class="n">Edge</span><span class="o">&gt;();</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">distances</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// Parse out (city1):(city2):(distance)</span>
            <span class="n">String</span><span class="o">[]</span> <span class="n">splitresult</span> <span class="o">=</span> <span class="n">distances</span><span class="o">[</span><span class="n">j</span><span class="o">].</span><span class="na">split</span><span class="o">(</span><span class="s">&quot;:&quot;</span><span class="o">);</span>
            <span class="n">String</span> <span class="n">left</span> <span class="o">=</span> <span class="n">splitresult</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
            <span class="n">String</span> <span class="n">right</span> <span class="o">=</span> <span class="n">splitresult</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span>
            <span class="n">String</span> <span class="n">label</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="s">&quot;:&quot;</span> <span class="o">+</span> <span class="n">right</span><span class="o">;</span>
            <span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">splitresult</span><span class="o">[</span><span class="mi">2</span><span class="o">]);</span>

            <span class="c1">// Add edges to map</span>
            <span class="n">Edge</span> <span class="n">edge</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Edge</span><span class="o">(</span><span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">,</span> <span class="n">value</span><span class="o">);</span>
            <span class="n">all_edges</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">label</span><span class="o">,</span> <span class="n">edge</span><span class="o">);</span>

            <span class="c1">// Add edges to network</span>
            <span class="n">roads</span><span class="o">.</span><span class="na">addEdge</span><span class="o">(</span><span class="n">all_nodes</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">edge</span><span class="o">.</span><span class="na">left</span><span class="o">),</span> <span class="n">all_nodes</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">edge</span><span class="o">.</span><span class="na">right</span><span class="o">),</span> <span class="n">edge</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="c1">// Freeze the network</span>
        <span class="n">ImmutableNetwork</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">,</span><span class="n">Edge</span><span class="o">&gt;</span> <span class="n">frozen_roads</span> <span class="o">=</span> <span class="n">ImmutableNetwork</span><span class="o">.</span><span class="na">copyOf</span><span class="o">(</span><span class="n">roads</span><span class="o">);</span>

        <span class="k">return</span> <span class="n">frozen_roads</span><span class="o">;</span>
    <span class="o">}</span>
</pre></div>


<p><a name="recursive-backtracking"></a></p>
<h2>Solving and Exploring with Recursive Backtracking</h2>
<h3>Solve Method</h3>
<p>The structure of some recursive backtracking problems is to create a public and a private interface,
with the public interface taking no parameters or a single parameter that the user will know, 
and the private method taking a parameter specific to the implementation. That's the pattern we use here.</p>
<p>The solve method sets up the problem by picking a starting node (in this case, an arbitrary starting node).
It then gets a reference to that node on the graph, and calls the recursive <code>explore()</code> method,
which begins the recursive backtracking method.</p>
<div class="highlight"><pre><span></span>    <span class="cm">/** Public solve method will call the recursive backtracking method to search for solutions on the graph */</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">solve</span><span class="o">()</span> <span class="o">{</span>
        <span class="cm">/** To solve the traveling salesman problem:</span>
<span class="cm">         * Set up the graph, choose a starting node, then call the recursive backtracking method and pass it the starting node.</span>
<span class="cm">         */</span>

        <span class="c1">// We need to pass a starting node to recursive backtracking method</span>
        <span class="n">Node</span> <span class="n">startNode</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>

        <span class="c1">// Grab a node, any node...</span>
        <span class="k">for</span><span class="o">(</span> <span class="n">Node</span> <span class="n">n</span> <span class="o">:</span> <span class="n">graph</span><span class="o">.</span><span class="na">nodes</span><span class="o">()</span> <span class="o">)</span> <span class="o">{</span>
            <span class="n">startNode</span> <span class="o">=</span> <span class="n">n</span><span class="o">;</span>
            <span class="k">break</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// Visit the first node</span>
        <span class="n">startNode</span><span class="o">.</span><span class="na">visit</span><span class="o">();</span>

        <span class="c1">// Add first node to the route</span>
        <span class="k">this</span><span class="o">.</span><span class="na">route</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">startNode</span><span class="o">.</span><span class="na">label</span><span class="o">;</span>

        <span class="c1">// Pass the number of choices made</span>
        <span class="kt">int</span> <span class="n">nchoices</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>

        <span class="c1">// Recursive backtracking</span>
        <span class="n">explore</span><span class="o">(</span><span class="n">startNode</span><span class="o">,</span> <span class="n">nchoices</span><span class="o">);</span>
    <span class="o">}</span>
</pre></div>


<h3>Explore (Backtrack) Method</h3>
<p>And now, on to the recursive backtracking method.</p>
<p>The method takes as a parameter which node we are currently on and the number of cities we have visited.
As multiple explore methods choose different paths, they pass references to different node objects in the graph,
and they pass different values of <code>nchoices</code>. </p>
<p>The methods, when they do not encounter a solution, will choose a next node and call the explore method on it.
Each instance of the explore method marks nodes as visited or unvisited on the same shared graph object.
This allows instances of the function to share information about their choices with other instances of the function.</p>
<p>All recursive methods must consist of a base case and a recursive case:</p>
<p>Base case:
- We've visited as many cities as are on the graph.
- Check if this is a new solution (distance less than the current minimum).</p>
<p>Recursive case:
- Make a choice (mark node as visited, add city to route).
- Explore the consequences (recursive call).
- Unmake the choice (mark node as unvisited, remove city from route).
- Move on to next choice.</p>
<div class="highlight"><pre><span></span>    <span class="cm">/** Recursive backtracking method: explore possible solutions starting at this node, having made nchoices */</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">explore</span><span class="o">(</span><span class="n">Node</span> <span class="n">node</span><span class="o">,</span> <span class="kt">int</span> <span class="n">nchoices</span><span class="o">)</span> <span class="o">{</span>
        <span class="cm">/**</span>
<span class="cm">         * Solution strategy: recursive backtracking.</span>
<span class="cm">         */</span>

        <span class="k">if</span><span class="o">(</span><span class="n">nchoices</span> <span class="o">==</span> <span class="n">graphSize</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// </span>
            <span class="c1">// BASE CASE</span>
            <span class="c1">//</span>
            <span class="k">if</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">this_distance</span> <span class="o">&lt;</span> <span class="k">this</span><span class="o">.</span><span class="na">min_distance</span> <span class="o">||</span> <span class="k">this</span><span class="o">.</span><span class="na">min_distance</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// if this_distance &lt; min_distance, this is our new minimum distance</span>
                <span class="c1">// if min_distance &lt; 0, this is our first minimium distance</span>
                <span class="k">this</span><span class="o">.</span><span class="na">min_distance</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">this_distance</span><span class="o">;</span>
                <span class="n">printSolution</span><span class="o">();</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="n">printFailure</span><span class="o">();</span>
            <span class="o">}</span>

        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="c1">//</span>
            <span class="c1">// RECURSIVE CASE</span>
            <span class="c1">//  </span>
            <span class="n">Set</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span> <span class="n">neighbors</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="na">adjacentNodes</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>
            <span class="k">for</span><span class="o">(</span><span class="n">Node</span> <span class="n">neighbor</span> <span class="o">:</span> <span class="n">neighbors</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">if</span><span class="o">(</span><span class="n">neighbor</span><span class="o">.</span><span class="na">visited</span> <span class="o">==</span> <span class="kc">false</span><span class="o">)</span> <span class="o">{</span>

                    <span class="kt">int</span> <span class="n">distance_btwn</span><span class="o">;</span>

                    <span class="k">for</span><span class="o">(</span> <span class="n">Edge</span> <span class="n">edge</span> <span class="o">:</span> <span class="n">graph</span><span class="o">.</span><span class="na">edgesConnecting</span><span class="o">(</span><span class="n">node</span><span class="o">,</span> <span class="n">neighbor</span><span class="o">)</span> <span class="o">)</span> <span class="o">{</span>
                        <span class="n">distance_btwn</span> <span class="o">=</span> <span class="n">edge</span><span class="o">.</span><span class="na">value</span><span class="o">;</span>
                    <span class="o">}</span>

                    <span class="c1">// Make a choice</span>
                    <span class="k">this</span><span class="o">.</span><span class="na">route</span><span class="o">[</span><span class="n">nchoices</span><span class="o">]</span> <span class="o">=</span> <span class="n">neighbor</span><span class="o">.</span><span class="na">label</span><span class="o">;</span>
                    <span class="n">neighbor</span><span class="o">.</span><span class="na">visit</span><span class="o">();</span>
                    <span class="k">this</span><span class="o">.</span><span class="na">this_distance</span> <span class="o">+=</span> <span class="n">distance_btwn</span><span class="o">;</span>

                    <span class="c1">// Explore the consequences</span>
                    <span class="n">explore</span><span class="o">(</span><span class="n">neighbor</span><span class="o">,</span><span class="n">nchoices</span><span class="o">+</span><span class="mi">1</span><span class="o">);</span>

                    <span class="c1">// Unmake the choice</span>
                    <span class="k">this</span><span class="o">.</span><span class="na">route</span><span class="o">[</span><span class="n">nchoices</span><span class="o">]</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
                    <span class="n">neighbor</span><span class="o">.</span><span class="na">unvisit</span><span class="o">();</span>
                    <span class="k">this</span><span class="o">.</span><span class="na">this_distance</span> <span class="o">-=</span> <span class="n">distance_btwn</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="c1">// Move on to the next choice (continue loop)</span>
            <span class="o">}</span>               
        <span class="o">}</span> <span class="c1">// End base/recursive case</span>
    <span class="o">}</span>
</pre></div>


<h2>Main and Utility Methods</h2>
<p>Last but not least, add the method that actually calls the TSP object's solve method,
and define what to do when we encounter a new solution.
This program just prints out new solutions as they are found, 
but you could also add them to a map (map routes to distances),
or quietly keep track of the shortest path and not print it until the end.</p>
<div class="highlight"><pre><span></span><span class="kd">class</span> <span class="nc">TSP</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span> 
        <span class="n">TSP</span> <span class="n">t</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TSP</span><span class="o">();</span>
        <span class="n">t</span><span class="o">.</span><span class="na">solve</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="o">...</span>
</pre></div>


<p>Additionally, we may want to perform a certain action when we find a new minimum distance.
Note that this method may be called multiple times during the solution procedure.</p>
<div class="highlight"><pre><span></span>    <span class="cm">/** Print out solution */</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">printSolution</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">&quot;@@@@@@@@@@\tNEW SOLUTION\t&quot;</span><span class="o">);</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Route: &quot;</span><span class="o">+</span><span class="n">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">route</span><span class="o">)</span>
                          <span class="o">+</span><span class="s">&quot;\tDistance: &quot;</span><span class="o">+</span><span class="k">this</span><span class="o">.</span><span class="na">min_distance</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="cm">/** Do nothing with failed path */</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">printFailure</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">// Nope</span>
    <span class="o">}</span>
</pre></div>


<h2>Program Output</h2>
<p>In the construction of the graph, we defined our graph as:</p>
<div class="highlight"><pre><span></span><span class="n">String</span><span class="o">[]</span> <span class="n">distances</span> <span class="o">=</span> <span class="o">{</span><span class="s">&quot;A:B:24&quot;</span><span class="o">,</span><span class="s">&quot;A:C:5&quot;</span><span class="o">,</span><span class="s">&quot;A:D:20&quot;</span><span class="o">,</span><span class="s">&quot;A:E:18&quot;</span><span class="o">,</span><span class="s">&quot;B:C:10&quot;</span><span class="o">,</span><span class="s">&quot;B:D:20&quot;</span><span class="o">,</span><span class="s">&quot;C:D:4&quot;</span><span class="o">,</span><span class="s">&quot;C:E:28&quot;</span><span class="o">,</span><span class="s">&quot;D:E:3&quot;</span><span class="o">};</span>
</pre></div>


<p>This is the graph that we're solving the TSP problem on.
Here are the results when the program is compiled and run:</p>
<div class="highlight"><pre><span></span>$ javac -cp <span class="s1">&#39;.:/Users/charles/codes/guava/jars/guava-21.0.jar&#39;</span> TSP.java

$ java -cp <span class="s1">&#39;.:/Users/charles/codes/guava/jars/guava-21.0.jar&#39;</span> TSP

@@@@@@@@@@  NEW SOLUTION    Route: <span class="o">[</span>A, B, C, D, E<span class="o">]</span>  Distance: <span class="m">41</span>.0
@@@@@@@@@@  NEW SOLUTION    Route: <span class="o">[</span>A, C, B, D, E<span class="o">]</span>  Distance: <span class="m">38</span>.0
@@@@@@@@@@  NEW SOLUTION    Route: <span class="o">[</span>A, E, D, C, B<span class="o">]</span>  Distance: <span class="m">35</span>.0
</pre></div>


<script type="text/javascript">if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width < 768) ? "left" : align;
        indent = (screen.width < 768) ? "0em" : indent;
        linebreak = (screen.width < 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' && location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
</script></div>

    </div>
</div>

<div class="v20"></div>

<div class="row">
    <div class="col-md-12" style="text-align: left;">

        <div class="tags">
            <p>Tags:&nbsp;&nbsp;&nbsp;
                    <a href="/tag/computer-science.html">computer science</a>
                    &nbsp;&nbsp;
                    <a href="/tag/guava.html">guava</a>
                    &nbsp;&nbsp;
                    <a href="/tag/graph.html">graph</a>
                    &nbsp;&nbsp;
                    <a href="/tag/tsp.html">TSP</a>
                    &nbsp;&nbsp;
        </div>

    </div>
</div>


<div class="v200"></div>

</div>


<script type="text/javascript" src="/theme/js/jquery-1.11.2.js"></script>
<script type="text/javascript" src="/theme/js/bootstrap-3.3.4.js"></script>
<script type="text/javascript" src="/theme/js/d3-3.5.5.js"></script>
<!--
<script type="text/javascript" src="/theme/js/leaflet-0.7.3.js"></script>
<script type="text/javascript" src="/theme/js/leaflet.ajax.min.js"></script>
--><footer id="contentinfo" class="body">
<hr />
<p style="text-align: center">
    <span class="fa-stack fa-lg">
        <i class="fa fa-square fa-stack-2x" style="color:#000;"></i>
        <i class="fa fa-terminal fa-stack-1x fa-inverse"></i>
    </span>
    Made from the command line with vim by 
    <a href="http://charlesreid1.com">charlesreid1</a><br />
    with help from <a href="http://d3js.org">D3.js</a>, <a href="http://angularjs.org">Angular.js</a>, and <a href="http://getpelican.com">Pelican</a>.
</p>

<script type="text/javascript" src="/theme/js/jquery-1.11.2.js"></script>
<script type="text/javascript" src="/theme/js/jquery_load_template-1.4.5.min.js"></script>
<script type="text/javascript" src="/theme/js/bootstrap-3.3.4.js"></script>

</footer><!-- /#contentinfo -->
</body>
</html>