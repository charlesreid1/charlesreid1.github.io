<!DOCTYPE html>
<html lang="en">
<head>
        <title>charlesreid1</title>
        <meta charset="utf-8" />

        <!--
        CSS styles
        -->
        <link href="/theme/css/bootstrap.css"       rel="stylesheet" type="text/css">
        <link href="/theme/css/slate.css"              rel="stylesheet" type="text/css">
        <link href="/theme/css/font-awesome.css"       rel="stylesheet" type="text/css"/>
        <link href="/theme/css/pygment-solarized.css"  rel="stylesheet" type="text/css"/>

        <!--
        my CSS styles
        -->
        <link href="/theme/css/main.css"            rel="stylesheet" type="text/css">
        <link href="/theme/css/dox.css"             rel="stylesheet" type="text/css">


        <!--
        include Angular first
        -->
        <script type="text/javascript" src="/theme/js/angular-1.3.15.js"></script>
        <script type="text/javascript" src="/theme/js/skrollr-0.6.29.js"></script>
        <script type="text/javascript" src="/theme/js/d3-3.5.5.js"></script>

        <!--
        this seems like a bad idea.
        but if I don't put jquery first, I get errors about unrecognized $s.
        -->
        <script type="text/javascript" src="/theme/js/jquery-1.11.2.js"></script>

</head>
<body id="index">
<nav class="navbar navbar-default">
    <div class="container-fluid">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#myNavbar">
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span> 
            </button>
            <a href="https://charlesreid1.github.io" class="navbar-brand">charlesreid1.github.io</a>
        </div>
        <div>
            <div class="collapse navbar-collapse" id="myNavbar">
                <ul class="nav navbar-nav">

                    <li>
                        <a href="https://charlesreid1.com/wiki">Wiki</a>
                    </li>
                    <li>
                        <a href="https://git.charlesreid1.com/explore">Git</a>
                    </li>
                    <li>
                        <a href="http://spotify.charlesreid1.com">Music</a>
                    </li>
                    <li>
                        <a href="https://charlesreid1.com/life">Life</a>
                    </li>
                    <li>
                        <a href="https://charlesreid1.github.io">Blog</a>
                    </li>
                    <li>
                        <a href="https://charlesreid1.com/about">About Me</a>
                    </li>

                </ul>
            </div>
        </div>
    </div>
</nav>



<div class="container">

    <div class="row">
        <div class="col-md-12 col-centered" style="text-align: center;">
            <div class="v50"></div>
            <div class="cosmojumbo">
                <h1 class="jumbojumbo">charlesreid1.com blog<h1>
            </div>
        </div>
    </div>


    <div class="v50"></div>


    <div class="row">

        <div class="col-md-8" style="text-align: center;">

  	            	<article>
<header>
<div class="row">


    <div class="col-md-12">
        <div class="headtext" style="text-align: center;">
            <h1><b>
                Five Letter Words: Part 5: The Try Trie Tree
            </b></h1>
        
            <p class="lead">
                Posted 
                <time datetime="2019-03-11T18:00:00-07:00" pubdate>Monday 03/11/2019</time>
                in 
                <a href="/category/computer-science.html">Computer Science</a>
                </p>
            <p>
            <span style="font-size: 14px">
                <a href="/five-letter-words-part-5-the-try-trie-tree.html">permalink</a>
            </span>
            </p>
        </div>

    </div>

</div>
</header>


<div class="v50"></div>


<div class="row">
    <div class="col-md-12" style="text-align: left;">

        <div class="entry-content"><h2>Table of Contents</h2>
<ul>
<li><a href="#table-of-contents">Table of Contents</a></li>
<li><a href="#about-the-five-letter-words">About the Five-Letter Words</a></li>
<li><a href="#introduction-to-the-try-trie-tree-problem">Introduction to the Try Trie Tree Problem</a></li>
<li><a href="#the-try-trie-tree">The Try Trie Tree</a></li>
<li><a href="#constructing-the-try-trie-tree">Constructing the Try Trie Tree</a></li>
<li><a href="#checking-for-minimum-number-of-matching-words">Checking for Minimum Number of Matching Words</a></li>
<li><a href="#assemble-method">Assemble Method</a></li>
<li><a href="#verifying-branches-and-bubbling-up-counts">Verifying Branches and Bubbling Up Counts</a></li>
<li><a href="#bubble-up-method">Bubble Up Method</a></li>
<li><a href="#try-trie-tree-code">Try Trie Tree Code</a></li>
<li><a href="#try-trie-trie-class">Try Trie Trie Class</a></li>
<li><a href="#code-for-assembling-the-tree">Code for Assembling the Tree</a></li>
<li><a href="#code-for-bubbling-up-large-children-counts">Code for Bubbling Up Large Children Counts</a></li>
<li><a href="#wrap-it-in-a-bow">Wrap it in a Bow</a></li>
<li><a href="#output">Output</a></li>
</ul>
<h2>About the Five-Letter Words</h2>
<p>In Volume 4 Fascicle 0 of Donald Knuth's <u>Art of Computer Programming</u>, 
Knuth introduces a tool for exploring concepts in graph theory: the five-letter
words. This is a collection of 5,757 five-letter words compiled by Knuth
and useful in exploring ways of constructing efficient algorithms.</p>
<p>The word list is large enough that an <span class="math">\(O(N^2)\)</span> algorithm will take a solid
chunk of CPU time, so there's a definite incentive to think carefully about
implementation.</p>
<p>Knuth introduces a list of five-letter words, as well as associated exercises
utilizing techniques from dynamic programming and graph theory, among other 
topics.</p>
<p>We have covered this topic before in prior blog posts:</p>
<ul>
<li><a href="https://charlesreid1.github.io/five-letter-words-part-1-getting-familiar-with-the-list.html">Five Letter Words: Part 1: Getting Familiar With The List</a></li>
<li><a href="https://charlesreid1.github.io/five-letter-words-part-2-more-five-word-algorithms.html">Five Letter Words: Part 2: More Five-Word Algorithms</a></li>
<li><a href="https://charlesreid1.github.io/five-letter-words-part-3-letter-coverage-and-dynamic-programming.html">Five Letter Words: Part 3: Letter Coverage and Dynamic Programming</a></li>
</ul>
<p>and a recent addendum to Part 1:</p>
<ul>
<li><a href="https://charlesreid1.github.io/five-letter-words-part-4-revisiting-diff-by-one.html">Five Letter Words: Part 4: Revisiting Diff by One</a></li>
</ul>
<p>We continue our coverage in this blog post with a newer problem,
one that is rated by Knuth at 26, on his scale of 0 to 50:</p>
<div class="highlight"><pre><span></span>00  Immediate
10  Simple (1 minute)
20  Medium (quarter hour)
30  Moderately hard
40  Term project
50  Research problem
</pre></div>


<p>(from Volume 1, Notes on the Exercises.)</p>
<p>Here's the <a href="https://github.com/charlesreid1/five-letter-words/blob/master/sgb-words.txt">list of words</a>
if you want to play along.</p>
<p>Link to the <a href="http://www3.cs.stonybrook.edu/~algorith/implement/graphbase/implement.shtml">Stanford Graph Base</a>.</p>
<p>Visit <a href="https://charlesreid1.com/wiki/Five_Letter_Words">Five Letter Words</a>
on the charlesreid1.com wiki for details.</p>
<h2>Introduction to the Try Trie Tree Problem</h2>
<p>In this blog post, we'll cover Exercise 35 of Volume 4, Fascicle 
of Donald Knuth's <u>Art of Computer Programming</u>.</p>
<p>The problem is as follows:</p>
<blockquote>
<p>Sixteen well-chosen elements of <code>WORDS(1000)</code> lead to the 
branching pattern (figure), which is a complete binary 
trie of words that begin with the letter <code>s</code>.
But there's no such pattern of words beginning with <code>a</code>,
even if we consider the full collection <code>WORDS(5757)</code>.</p>
<p>What letters of the alphabet can be used as the starting
letter of sixteen words that form a complete binary trie
within <code>WORDS(n)</code>, given n?</p>
</blockquote>
<p>For the benefit of those without the book, here is an attempt
to represent the trie that Knuth includes in the exercise:</p>
<div class="highlight"><pre><span></span>                     s

            h                 t

        e       o         a       e

      e   l   r   w     l   r   a   e

      sheep             stalk
      sheet             stall

          shelf             stars
          shell             start

              shore             steal
              short             steam

                  shown             steel
                  shows             steep
</pre></div>


<p>To answer the question, of whether a complete binary
trie can be completed for a given letter, given a
set of n words, we construct a "try trie tree,"
which is a tree data structure that greedily builds
a trie with as many branches as possible.</p>
<p>The full trie of <span class="math">\(26^4+1 = 456,977\)</span> nodes
would be expensive to assemble in full, for each
starting letter. Instead we use the word list 
to build up a tree of possible candidate branches
for the trie. Once we've constructed all possible
branches using the faster but less precise method,
we verify that each candidate branch we have
constructed either meets our criteria (can be
included as a branch in a complete binary trie),
or is pruned.</p>
<h2>The Try Trie Tree</h2>
<p>To solve this problem, we define a TryTrieTree
class that holds the nodes and links that make
up our tree. We define some methods for it
to perform the assembly and verification operations
described below, then assemble one try trie tree
for each letter of the alphabet to come up with 
an answer to the exercise.</p>
<h2>Constructing the Try Trie Tree</h2>
<p>The construction procedure for the try trie tree
is top-down.</p>
<p>We construct the trie starting at the root (the 
starting letter) and go level by level.</p>
<h3>Checking for Minimum Number of Matching Words</h3>
<p>At each level of the trie, we count
the number of words in <code>WORDS(n)</code> whose prefix 
matches the prefix at that trie location.
If enough words match, that branch of the trie
is possibly (but not definitely) complete.</p>
<p><strong>Example:</strong> If we are attempting to assemble
a complete trie for the letter <code>z</code> using <code>WORDS(1000)</code>,
we can stop at the very first level, because 
we already know there are not enough words 
starting with the letter z to make a complete
binary trie. (If a complete binary trie requires
16 words, and only 10 start with z, we don't need
to go any further.)</p>
<p><strong>Example:</strong> If we are assembling the complete
trie for <code>s</code> given by the author in the exercise,
we can verify that there are at least 16 words that
begin with the letter <code>s</code>. We would then verify that
there are at least 8 words that begin with <code>sa</code>,
which there are. Then we would verify that there
are at least 4 words that begin with <code>saa</code>, which
there are not, so we would move on to verifying
that there are at least 4 words that begin with
<code>sab</code>, which there are. We would proceed in this
fashion until we had assembled a candidate trie
branch, <code>s-a-b-r</code> (which contains two words,
<code>sabra</code> and <code>sabre</code>). So far, so good.</p>
<p>At each level of the trie, we apply the procedure:
- At level 1, we require a minimum of <span class="math">\(2^{5-1} = 16\)</span> words.
- At level 2, we require a minimum of <span class="math">\(2^{5-2} = 8\)</span> words.
- At level 3, we require a minimum of <span class="math">\(2^{5-3} = 4\)</span> words.
- At level 4, we require a minimum of <span class="math">\(2^{5-4} = 2\)</span> words.</p>
<p><strong>NOTE:</strong> We are not explicitly constructing the trie,
so we don't need to assemble the word leaves.</p>
<h3>Assemble Method</h3>
<p>See the <a href="#try-trie-tree-code">Try Trie Tree Code</a> section 
for the code for the public and private assembly methods.</p>
<p>To peform the assembly of all possible branches of the
try trie, we use the <code>assemble()</code> method. This is a 
public method that initializes a call to a private
recursive assembly method.</p>
<p>We explore every possible prefix starting with the
root letter, so "sa", "sb", "sc", "sd", and so on.
Within each of those, we try each letter another 
level further, "saa", "sab", and so on, and then
we try each letter in a final step, for a total
of <span class="math">\(26^4 = 456,976\)</span> iterations (checks for existence
of words starting with a given substring).</p>
<p><strong>NOTE:</strong> If we want to speed up our program,
we would be wise to start by speeding up
the way we check the number of words that
start with a given substring.</p>
<p>The recursive assembly method therefore takes
a prefix string (location in the tree), and
explores each possible child in the trie,
counting how many words occur at that possible
child. If enough of them exist, the branch
is added to the TryTrieTree.</p>
<h3>Verifying Branches and Bubbling Up Counts</h3>
<p>However, the above counts are just the <em>minimum</em> required,
and do not guarantee that a trie branch can be used in
a complete binary trie. That requires checking the entire
trie. We will end up pruning some of the branches of the
try trie we assembled above.</p>
<p>Continuing with the example above for <code>s</code>, we
assembled the branch <code>s-a-b-r</code>, which contains
the minimum two words required. However, <code>s-a-b</code>
is not a common enough prefix! The only child
of <code>s-a-b</code> with two or more words matching
is <code>s-a-b-r</code>, which means we can't form a complete
binary trie using this <code>s-a-b</code> branch.</p>
<p>Importantly, this procedure is <em>bottom-up</em>.</p>
<p>We perform a pre-traversal depth-first search
of the entire tree, ensuring that we visit
each of the leaves of the tree <em>first</em>, and
to ensure that we have always visited every child
of a node before we visit the node itself.</p>
<p>This is important because we will "bubble up"
the count of valid branches. </p>
<p>In our TryTrieTree, a complete binary trie is 
only possible if each node at each level has
<em>two or more</em> children that are "large enough",
where "large enough" means that either (a) both child
nodes have <em>two or more</em> children that are
"large enough", or (b) if we are at a leaf node
(representing 4 characters), and there are
<em>two or more</em> words that begin with the 4 characters
corresponding to this trie node.</p>
<h3>Bubble Up Method</h3>
<p>See the <a href="#try-trie-tree-code">Try Trie Tree Code</a> section 
for the code for the public and private bubble up methods.</p>
<p>Similar to the assembly method, our bubble up method
is also a recursive method, performing a depth-first
pre-order traversal. This ensures we reach leaf nodes
before beginning our task, and that counts proceed
from bottom-up.</p>
<h2>Try Trie Tree Code</h2>
<h3>Try Trie Trie Class</h3>
<p>Before we define the TryTrieTree class,
we start with a utility tree node class:</p>
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Node</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">letter</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">letter</span> <span class="o">=</span> <span class="n">letter</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">count</span> <span class="o">=</span> <span class="n">count</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">children</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="bp">None</span>
</pre></div>


<p>The TryTrieTree class has a constructor that 
initializes the root node to None. The tree
should also contain a pointer to the original
word set, so that we can reference it in later
methods where needed.</p>
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">TryTrieTree</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">words</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">root</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">words</span> <span class="o">=</span> <span class="n">words</span>
</pre></div>


<p>In the final class we defined a <code>__str__()</code>
method to create a string representation
of the TryTrieTree, but we will skip that
for now.</p>
<p>Next we have a method to set the root to
a given Node:</p>
<div class="highlight"><pre><span></span>    <span class="k">def</span> <span class="nf">set_root</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">root_letter</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">root</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">root_letter</span><span class="p">)</span>
</pre></div>


<p>Additionally, we have two utility methods that 
help us navigate between locations in the tree 
and the corresponding string prefixes:</p>
<ul>
<li>
<p><code>get_prefix_from_node()</code> (utility method): given a
  Node in the trie, return the string prefix that would
  lead to that Node.</p>
</li>
<li>
<p><code>get_node_from_prefix()</code> (utility method): given a
  string prefix, return the Node in the trie that 
  corresponds to the given string prefix.
  Return None if no such Node exists.</p>
</li>
</ul>
<p>These methods are given below:</p>
<div class="highlight"><pre><span></span>    <span class="k">def</span> <span class="nf">get_prefix_from_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">node</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Given a node in the trie,</span>
<span class="sd">        return the string prefix that</span>
<span class="sd">        would lead to that node.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">node</span><span class="o">==</span><span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;&quot;</span>
        <span class="k">elif</span> <span class="n">node</span><span class="o">==</span><span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">prefix</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
            <span class="k">while</span> <span class="n">node</span><span class="o">.</span><span class="n">parent</span> <span class="o">!=</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">parent</span>
                <span class="n">prefix</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">letter</span> <span class="o">+</span> <span class="n">prefix</span>
            <span class="k">return</span> <span class="n">prefix</span>
</pre></div>


<p>and the reverse:</p>
<div class="highlight"><pre><span></span>    <span class="k">def</span> <span class="nf">get_node_from_prefix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">prefix</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Given a string prefix,</span>
<span class="sd">        return the node that represents</span>
<span class="sd">        the tail end of that sequence</span>
<span class="sd">        of letters in this trie. Return</span>
<span class="sd">        None if the path does not exist.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="o">!=</span><span class="bp">None</span>

        <span class="k">if</span> <span class="n">prefix</span><span class="o">==</span><span class="s1">&#39;&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>

        <span class="k">assert</span> <span class="n">prefix</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">letter</span>

        <span class="c1"># Base case</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">prefix</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">root</span>

        <span class="c1"># Recursive case</span>
        <span class="n">parent_prefix</span><span class="p">,</span> <span class="n">suffix</span> <span class="o">=</span> <span class="n">prefix</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">prefix</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">prefix</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">prefix</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">parent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_node_from_prefix</span><span class="p">(</span><span class="n">parent_prefix</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">parent</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">child</span><span class="o">.</span><span class="n">letter</span> <span class="o">==</span> <span class="n">suffix</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">child</span>

        <span class="c1"># We know this will end because we handle</span>
        <span class="c1"># the base case of prefix=&quot;&quot;, and prefix</span>
        <span class="c1"># is cut down by one letter each iteration.</span>
</pre></div>


<h3>Code for Assembling the Tree</h3>
<p>We assemble the tree using a private recursive
method. Here is how that looks (again, these
methods are defined on the <code>TryTrieTree</code>
class):</p>
<div class="highlight"><pre><span></span>    <span class="k">def</span> <span class="nf">assemble</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Assemble the trie from the set of words</span>
<span class="sd">        passed to the constructor.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="o">!=</span><span class="bp">None</span>

        <span class="n">words</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">words</span>

        <span class="c1"># start with an empty prefix</span>
        <span class="n">prefix</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="n">candidate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">letter</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assemble</span><span class="p">(</span><span class="n">prefix</span><span class="p">,</span><span class="n">candidate</span><span class="p">,</span><span class="n">words</span><span class="p">)</span>
</pre></div>


<p>In the private recursive method, we assemble the branches
of the tree, only checking to make sure each branch has
the minimum number of words required. In a later method</p>
<div class="highlight"><pre><span></span>    <span class="k">def</span> <span class="nf">_assemble</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">prefix</span><span class="p">,</span><span class="n">candidate</span><span class="p">,</span><span class="n">words</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Recursive private method called by assemble().</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">prefix_depth</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">prefix</span><span class="p">)</span>
        <span class="n">candidate_depth</span> <span class="o">=</span> <span class="n">prefix_depth</span><span class="o">+</span><span class="mi">1</span>

        <span class="n">ppc</span> <span class="o">=</span> <span class="n">prefix</span><span class="o">+</span><span class="n">candidate</span>
        <span class="n">words_with_candidate</span> <span class="o">=</span> <span class="p">[</span><span class="n">w</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">words</span> <span class="k">if</span> <span class="n">w</span><span class="p">[:</span><span class="n">candidate_depth</span><span class="p">]</span><span class="o">==</span><span class="n">ppc</span><span class="p">]</span>

        <span class="n">min_branches_req</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">pow</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="o">-</span><span class="n">candidate_depth</span><span class="p">))</span>
        <span class="n">max_number_branches</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">words_with_candidate</span><span class="p">)</span>

        <span class="c1"># If we exceed the minimum number of </span>
        <span class="c1"># branches required, add candidate</span>
        <span class="c1"># as a new node on the trie.</span>
        <span class="k">if</span> <span class="n">max_number_branches</span> <span class="o">&gt;=</span> <span class="n">min_branches_req</span><span class="p">:</span>

            <span class="n">parent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_node_from_prefix</span><span class="p">(</span><span class="n">prefix</span><span class="p">)</span>

            <span class="c1"># If we are looking at the root node,</span>
            <span class="k">if</span> <span class="n">prefix</span><span class="o">==</span><span class="s1">&#39;&#39;</span><span class="p">:</span>
                <span class="c1"># parent will be None.</span>
                <span class="c1"># In this case don&#39;t worry about</span>
                <span class="c1"># creating new child or introducing</span>
                <span class="c1"># parent and child, b/c the &quot;new child&quot;</span>
                <span class="c1"># is the root (already exists).</span>
                <span class="k">pass</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Otherwise, create the new child,</span>
                <span class="c1"># and introduce the parent &amp; child.</span>
                <span class="n">new_child</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">candidate</span><span class="p">)</span>
                <span class="n">new_child</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">parent</span>
                <span class="n">parent</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_child</span><span class="p">)</span>

            <span class="c1"># Base case</span>
            <span class="k">if</span> <span class="n">candidate_depth</span><span class="o">==</span><span class="mi">4</span><span class="p">:</span>
                <span class="n">new_child</span><span class="o">.</span><span class="n">count</span> <span class="o">=</span> <span class="n">max_number_branches</span>
                <span class="k">return</span>

            <span class="c1"># Recursive case</span>
            <span class="k">for</span> <span class="n">new_candidate</span> <span class="ow">in</span> <span class="n">ALPHABET</span><span class="p">:</span>
                <span class="n">new_prefix</span> <span class="o">=</span> <span class="n">prefix</span> <span class="o">+</span> <span class="n">candidate</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_assemble</span><span class="p">(</span><span class="n">new_prefix</span><span class="p">,</span><span class="n">new_candidate</span><span class="p">,</span><span class="n">words_with_candidate</span><span class="p">)</span>

        <span class="c1"># otherwise, we don&#39;t have enough</span>
        <span class="c1"># branches to continue downward,</span>
        <span class="c1"># so stop here and do nothing.</span>
        <span class="k">return</span>
</pre></div>


<h3>Code for Bubbling Up Large Children Counts</h3>
<p>These are a little shorter and simpler than the
assembly method above:</p>
<div class="highlight"><pre><span></span>    <span class="k">def</span> <span class="nf">bubble_up</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Do a depth-first traversal of the</span>
<span class="sd">        entire trytrietree, pruning as we go.</span>
<span class="sd">        This is a pre-order traversal,</span>
<span class="sd">        meaning we traverse children first,</span>
<span class="sd">        then the parents, so we always </span>
<span class="sd">        know the counts of children</span>
<span class="sd">        (or we are on a leaf node).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_bubble_up</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">root</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">_bubble_up</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">node</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Pre-order depth-first traversal</span>
<span class="sd">        starting at the leaf nodes and proceeding</span>
<span class="sd">        upwards.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Base case</span>
            <span class="c1"># Leaf nodes already have counts          </span>
            <span class="c1"># Do nothing</span>
            <span class="k">return</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Recursive case</span>
            <span class="c1"># Pre-order traversal: visit/bubble up children first</span>
            <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_bubble_up</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>

            <span class="c1"># Now that we&#39;ve completed leaf node counts, we can do interior node counts.</span>
            <span class="c1"># Interior node counts are equal to number of large (&gt;=2) children.</span>
            <span class="n">large_children</span> <span class="o">=</span> <span class="p">[</span><span class="n">child</span> <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span> <span class="k">if</span> <span class="n">child</span><span class="o">.</span><span class="n">count</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">]</span>
            <span class="n">node</span><span class="o">.</span><span class="n">count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">large_children</span><span class="p">)</span>
</pre></div>


<p>You can see how we converted the definition of
"large children" into a rule above - we use the
recursive case of the "large children" definition
in the recursive case, and we use the base case
of the "large children definition" (for leaf nodes)
when we are on the base case.</p>
<p>Also note that each leaf node was initialized with
the number of words that start with the corresponding
4-letter prefix (that was done in the assembly method),
but we could just as easily do it in the base case,
as the leaf nodes are the base case.</p>
<h2>Wrap it in a Bow</h2>
<p>We can add some extra wrapping around our class,
and call each of the methods in order for the
various letters of the alphabet.</p>
<p>Below, we process an input argument n (which is
the size of the wordlist, 5757, if the user does
not specify n). It then creates a TryTrieTree
for each letter, and determines if a complete
binary trie can be constructed. Finally, it prints
a summary of the results.</p>
<div class="highlight"><pre><span></span><span class="ch">#!/usr/bin/env python</span>
<span class="kn">from</span> <span class="nn">get_words</span> <span class="kn">import</span> <span class="n">get_words</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">math</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">tries.py</span>

<span class="sd">Donald Knuth, Art of Computer Programming, Volume 4 Fascicle 0</span>
<span class="sd">Exercise #35</span>

<span class="sd">Problem:</span>
<span class="sd">What letters of the alphabet can be used</span>
<span class="sd">as the starting letter of sixteen words that</span>
<span class="sd">form a complete binary trie within</span>
<span class="sd">WORDS(n), given n?</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="n">ALPHABET</span> <span class="o">=</span> <span class="s2">&quot;abcdefghijklmnopqrstuvwxyz&quot;</span>
<span class="n">FIVE</span> <span class="o">=</span> <span class="mi">5</span>


<span class="k">class</span> <span class="nc">Node</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="o">...</span>


<span class="k">class</span> <span class="nc">TryTrieTree</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="o">...</span>

<span class="k">def</span> <span class="nf">trie_search</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>

    <span class="n">words</span> <span class="o">=</span> <span class="n">get_words</span><span class="p">()</span>
    <span class="n">words</span> <span class="o">=</span> <span class="n">words</span><span class="p">[:</span><span class="n">n</span><span class="p">]</span>

    <span class="n">perfect_count</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">imperfect_count</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">letter</span> <span class="ow">in</span> <span class="n">ALPHABET</span><span class="p">:</span>

        <span class="n">tree</span> <span class="o">=</span> <span class="n">TryTrieTree</span><span class="p">(</span><span class="n">words</span><span class="p">)</span>
        <span class="n">tree</span><span class="o">.</span><span class="n">set_root</span><span class="p">(</span><span class="n">letter</span><span class="p">)</span>
        <span class="n">tree</span><span class="o">.</span><span class="n">assemble</span><span class="p">()</span>
        <span class="n">tree</span><span class="o">.</span><span class="n">bubble_up</span><span class="p">()</span>
        <span class="c1">#print(tree)</span>

        <span class="k">if</span> <span class="n">tree</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">count</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>

            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="k">print</span><span class="p">(</span><span class="s2">&quot;The letter {0:s} has a perfect binary trie in WORDS({1:d}).&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">letter</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
            <span class="n">perfect_count</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">else</span><span class="p">:</span>

            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="k">print</span><span class="p">(</span><span class="s2">&quot;The letter {0:s} has no perfect binary trie in WORDS({1:d}).&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">letter</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
            <span class="n">imperfect_count</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="s2">&quot;Perfect count: {:d}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">perfect_count</span><span class="p">))</span>
        <span class="k">print</span><span class="p">(</span><span class="s2">&quot;Imperfect count: {:d}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">imperfect_count</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">perfect_count</span><span class="p">,</span> <span class="n">imperfect_count</span>



<span class="k">def</span> <span class="nf">trie_table</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Compute and print a table of</span>
<span class="sd">    number of words n versus number of</span>
<span class="sd">    perfect tries formed.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%8s</span><span class="se">\t</span><span class="si">%8s</span><span class="s2">&quot;</span><span class="o">%</span><span class="p">(</span><span class="s2">&quot;n&quot;</span><span class="p">,</span><span class="s2">&quot;perfect tries&quot;</span><span class="p">))</span>

    <span class="n">ns</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span><span class="mi">5757</span><span class="p">,</span><span class="mi">500</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">ns</span><span class="p">:</span>
        <span class="n">p</span><span class="p">,</span><span class="n">i</span> <span class="o">=</span> <span class="n">trie_search</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%8d</span><span class="se">\t</span><span class="si">%8d</span><span class="s2">&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">p</span><span class="p">))</span>

    <span class="n">n</span> <span class="o">=</span> <span class="mi">5757</span>
    <span class="n">p</span><span class="p">,</span><span class="n">i</span> <span class="o">=</span> <span class="n">trie_search</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%8d</span><span class="se">\t</span><span class="si">%8d</span><span class="s2">&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">p</span><span class="p">))</span>


<span class="k">if</span> <span class="vm">__name__</span><span class="o">==</span><span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">)</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">=</span> <span class="mi">5757</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">5757</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="mi">5757</span>

    <span class="n">_</span><span class="p">,</span><span class="n">_</span> <span class="o">=</span> <span class="n">trie_search</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

    <span class="c1">#trie_table()</span>
</pre></div>


<h2>Output</h2>
<p>When we run with n = 1000, we can see that <code>s</code> is the only letter
that forms a perfect binary trie for that value of n:</p>
<div class="highlight"><pre><span></span>$ python tries.py <span class="m">1000</span>
The letter a has no perfect binary trie in WORDS<span class="o">(</span><span class="m">1000</span><span class="o">)</span>.
The letter b has no perfect binary trie in WORDS<span class="o">(</span><span class="m">1000</span><span class="o">)</span>.
The letter c has no perfect binary trie in WORDS<span class="o">(</span><span class="m">1000</span><span class="o">)</span>.
The letter d has no perfect binary trie in WORDS<span class="o">(</span><span class="m">1000</span><span class="o">)</span>.
The letter e has no perfect binary trie in WORDS<span class="o">(</span><span class="m">1000</span><span class="o">)</span>.
The letter f has no perfect binary trie in WORDS<span class="o">(</span><span class="m">1000</span><span class="o">)</span>.
The letter g has no perfect binary trie in WORDS<span class="o">(</span><span class="m">1000</span><span class="o">)</span>.
The letter h has no perfect binary trie in WORDS<span class="o">(</span><span class="m">1000</span><span class="o">)</span>.
The letter i has no perfect binary trie in WORDS<span class="o">(</span><span class="m">1000</span><span class="o">)</span>.
The letter j has no perfect binary trie in WORDS<span class="o">(</span><span class="m">1000</span><span class="o">)</span>.
The letter k has no perfect binary trie in WORDS<span class="o">(</span><span class="m">1000</span><span class="o">)</span>.
The letter l has no perfect binary trie in WORDS<span class="o">(</span><span class="m">1000</span><span class="o">)</span>.
The letter m has no perfect binary trie in WORDS<span class="o">(</span><span class="m">1000</span><span class="o">)</span>.
The letter n has no perfect binary trie in WORDS<span class="o">(</span><span class="m">1000</span><span class="o">)</span>.
The letter o has no perfect binary trie in WORDS<span class="o">(</span><span class="m">1000</span><span class="o">)</span>.
The letter p has no perfect binary trie in WORDS<span class="o">(</span><span class="m">1000</span><span class="o">)</span>.
The letter q has no perfect binary trie in WORDS<span class="o">(</span><span class="m">1000</span><span class="o">)</span>.
The letter r has no perfect binary trie in WORDS<span class="o">(</span><span class="m">1000</span><span class="o">)</span>.
The letter s has a perfect binary trie in WORDS<span class="o">(</span><span class="m">1000</span><span class="o">)</span>.
The letter t has no perfect binary trie in WORDS<span class="o">(</span><span class="m">1000</span><span class="o">)</span>.
The letter u has no perfect binary trie in WORDS<span class="o">(</span><span class="m">1000</span><span class="o">)</span>.
The letter v has no perfect binary trie in WORDS<span class="o">(</span><span class="m">1000</span><span class="o">)</span>.
The letter w has no perfect binary trie in WORDS<span class="o">(</span><span class="m">1000</span><span class="o">)</span>.
The letter x has no perfect binary trie in WORDS<span class="o">(</span><span class="m">1000</span><span class="o">)</span>.
The letter y has no perfect binary trie in WORDS<span class="o">(</span><span class="m">1000</span><span class="o">)</span>.
The letter z has no perfect binary trie in WORDS<span class="o">(</span><span class="m">1000</span><span class="o">)</span>.

Perfect count: <span class="m">1</span>
Imperfect count: <span class="m">25</span>
</pre></div>


<p>In fact, 978 is the smallest number of words to find any perfect tries:</p>
<div class="highlight"><pre><span></span>$ python tries.py <span class="m">978</span>
The letter a has no perfect binary trie in WORDS<span class="o">(</span><span class="m">978</span><span class="o">)</span>.
The letter b has no perfect binary trie in WORDS<span class="o">(</span><span class="m">978</span><span class="o">)</span>.
The letter c has no perfect binary trie in WORDS<span class="o">(</span><span class="m">978</span><span class="o">)</span>.
The letter d has no perfect binary trie in WORDS<span class="o">(</span><span class="m">978</span><span class="o">)</span>.
The letter e has no perfect binary trie in WORDS<span class="o">(</span><span class="m">978</span><span class="o">)</span>.
The letter f has no perfect binary trie in WORDS<span class="o">(</span><span class="m">978</span><span class="o">)</span>.
The letter g has no perfect binary trie in WORDS<span class="o">(</span><span class="m">978</span><span class="o">)</span>.
The letter h has no perfect binary trie in WORDS<span class="o">(</span><span class="m">978</span><span class="o">)</span>.
The letter i has no perfect binary trie in WORDS<span class="o">(</span><span class="m">978</span><span class="o">)</span>.
The letter j has no perfect binary trie in WORDS<span class="o">(</span><span class="m">978</span><span class="o">)</span>.
The letter k has no perfect binary trie in WORDS<span class="o">(</span><span class="m">978</span><span class="o">)</span>.
The letter l has no perfect binary trie in WORDS<span class="o">(</span><span class="m">978</span><span class="o">)</span>.
The letter m has no perfect binary trie in WORDS<span class="o">(</span><span class="m">978</span><span class="o">)</span>.
The letter n has no perfect binary trie in WORDS<span class="o">(</span><span class="m">978</span><span class="o">)</span>.
The letter o has no perfect binary trie in WORDS<span class="o">(</span><span class="m">978</span><span class="o">)</span>.
The letter p has no perfect binary trie in WORDS<span class="o">(</span><span class="m">978</span><span class="o">)</span>.
The letter q has no perfect binary trie in WORDS<span class="o">(</span><span class="m">978</span><span class="o">)</span>.
The letter r has no perfect binary trie in WORDS<span class="o">(</span><span class="m">978</span><span class="o">)</span>.
The letter s has a perfect binary trie in WORDS<span class="o">(</span><span class="m">978</span><span class="o">)</span>.
The letter t has no perfect binary trie in WORDS<span class="o">(</span><span class="m">978</span><span class="o">)</span>.
The letter u has no perfect binary trie in WORDS<span class="o">(</span><span class="m">978</span><span class="o">)</span>.
The letter v has no perfect binary trie in WORDS<span class="o">(</span><span class="m">978</span><span class="o">)</span>.
The letter w has no perfect binary trie in WORDS<span class="o">(</span><span class="m">978</span><span class="o">)</span>.
The letter x has no perfect binary trie in WORDS<span class="o">(</span><span class="m">978</span><span class="o">)</span>.
The letter y has no perfect binary trie in WORDS<span class="o">(</span><span class="m">978</span><span class="o">)</span>.
The letter z has no perfect binary trie in WORDS<span class="o">(</span><span class="m">978</span><span class="o">)</span>.

Perfect count: <span class="m">1</span>
Imperfect count: <span class="m">25</span>
</pre></div>


<p>Running with the full 5757 words leads to 11 more perfect tries:</p>
<div class="highlight"><pre><span></span>$ python tries.py <span class="m">5757</span>
The letter a has no perfect binary trie in WORDS<span class="o">(</span><span class="m">5757</span><span class="o">)</span>.
The letter b has a perfect binary trie in WORDS<span class="o">(</span><span class="m">5757</span><span class="o">)</span>.
The letter c has a perfect binary trie in WORDS<span class="o">(</span><span class="m">5757</span><span class="o">)</span>.
The letter d has a perfect binary trie in WORDS<span class="o">(</span><span class="m">5757</span><span class="o">)</span>.
The letter e has no perfect binary trie in WORDS<span class="o">(</span><span class="m">5757</span><span class="o">)</span>.
The letter f has a perfect binary trie in WORDS<span class="o">(</span><span class="m">5757</span><span class="o">)</span>.
The letter g has no perfect binary trie in WORDS<span class="o">(</span><span class="m">5757</span><span class="o">)</span>.
The letter h has a perfect binary trie in WORDS<span class="o">(</span><span class="m">5757</span><span class="o">)</span>.
The letter i has no perfect binary trie in WORDS<span class="o">(</span><span class="m">5757</span><span class="o">)</span>.
The letter j has no perfect binary trie in WORDS<span class="o">(</span><span class="m">5757</span><span class="o">)</span>.
The letter k has no perfect binary trie in WORDS<span class="o">(</span><span class="m">5757</span><span class="o">)</span>.
The letter l has a perfect binary trie in WORDS<span class="o">(</span><span class="m">5757</span><span class="o">)</span>.
The letter m has a perfect binary trie in WORDS<span class="o">(</span><span class="m">5757</span><span class="o">)</span>.
The letter n has no perfect binary trie in WORDS<span class="o">(</span><span class="m">5757</span><span class="o">)</span>.
The letter o has no perfect binary trie in WORDS<span class="o">(</span><span class="m">5757</span><span class="o">)</span>.
The letter p has a perfect binary trie in WORDS<span class="o">(</span><span class="m">5757</span><span class="o">)</span>.
The letter q has no perfect binary trie in WORDS<span class="o">(</span><span class="m">5757</span><span class="o">)</span>.
The letter r has a perfect binary trie in WORDS<span class="o">(</span><span class="m">5757</span><span class="o">)</span>.
The letter s has a perfect binary trie in WORDS<span class="o">(</span><span class="m">5757</span><span class="o">)</span>.
The letter t has a perfect binary trie in WORDS<span class="o">(</span><span class="m">5757</span><span class="o">)</span>.
The letter u has no perfect binary trie in WORDS<span class="o">(</span><span class="m">5757</span><span class="o">)</span>.
The letter v has no perfect binary trie in WORDS<span class="o">(</span><span class="m">5757</span><span class="o">)</span>.
The letter w has a perfect binary trie in WORDS<span class="o">(</span><span class="m">5757</span><span class="o">)</span>.
The letter x has no perfect binary trie in WORDS<span class="o">(</span><span class="m">5757</span><span class="o">)</span>.
The letter y has no perfect binary trie in WORDS<span class="o">(</span><span class="m">5757</span><span class="o">)</span>.
The letter z has no perfect binary trie in WORDS<span class="o">(</span><span class="m">5757</span><span class="o">)</span>.

Perfect count: <span class="m">12</span>
Imperfect count: <span class="m">14</span>
</pre></div>


<p>If we assemble a table of number of five letter words n
versus number of perfect tries formed, nearly half show up
only after we include 4,500 words.</p>
<div class="highlight"><pre><span></span>       n    perfect tries
    1000           1
    1500           1
    2000           1
    2500           1
    3000           3
    3500           3
    4000           4
    4500           6
    5000          11
    5500          12
    5757          12
</pre></div>


<script type="text/javascript">if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width < 768) ? "left" : align;
        indent = (screen.width < 768) ? "0em" : indent;
        linebreak = (screen.width < 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
</script></div>

    </div>
</div>

<div class="v20"></div>

<div class="row">
    <div class="col-md-12" style="text-align: left;">

        <div class="tags">
            <p>Tags:&nbsp;&nbsp;&nbsp;
                    <a href="/tag/python.html">python</a>
                    &nbsp;&nbsp;
                    <a href="/tag/computer-science.html">computer science</a>
                    &nbsp;&nbsp;
                    <a href="/tag/graphs.html">graphs</a>
                    &nbsp;&nbsp;
                    <a href="/tag/algorithms.html">algorithms</a>
                    &nbsp;&nbsp;
                    <a href="/tag/art-of-computer-programming.html">art of computer programming</a>
                    &nbsp;&nbsp;
                    <a href="/tag/knuth.html">knuth</a>
                    &nbsp;&nbsp;
                    <a href="/tag/five-letter-words.html">five letter words</a>
                    &nbsp;&nbsp;
                    <a href="/tag/tries.html">tries</a>
                    &nbsp;&nbsp;
                    <a href="/tag/trees.html">trees</a>
                    &nbsp;&nbsp;
        </div>

    </div>
</div>


<div class="v200"></div>
  	            	</article>
  	            	<article>
<header>
<div class="row">


    <div class="col-md-12">
        <div class="headtext" style="text-align: center;">
            <h1><b>
                Five Letter Words: Part 4: Revisiting Diff by One
            </b></h1>
        
            <p class="lead">
                Posted 
                <time datetime="2019-03-10T10:00:00-07:00" pubdate>Sunday 03/10/2019</time>
                in 
                <a href="/category/computer-science.html">Computer Science</a>
                </p>
            <p>
            <span style="font-size: 14px">
                <a href="/five-letter-words-part-4-revisiting-diff-by-one.html">permalink</a>
            </span>
            </p>
        </div>

    </div>

</div>
</header>


<div class="v50"></div>


<div class="row">
    <div class="col-md-12" style="text-align: left;">

        <div class="entry-content"><h2>Table of Contents</h2>
<ul>
<li><a href="#five4-about">Five Letter Words, Revisited</a></li>
<li><a href="#five4-diff-by-one">Different By One, Revisited</a></li>
<li><a href="#five4-diff-by-n">Different By N, Revisited</a></li>
</ul>
<p><a name="five4-about"></a></p>
<h2>About the Five-Letter Words</h2>
<p>In Volume 4, Facsimile 0 of Donald Knuth's <u>Art of Computer Programming</u>, 
in which Knuth covers graph theory, he introduces a list of five-letter words
as part of a data set useful in exploring graph theory and graph algorithms.</p>
<p>The <a href="https://github.com/charlesreid1/five-letter-words/blob/master/sgb-words.txt">list of words</a> 
is part of the <a href="http://www3.cs.stonybrook.edu/~algorith/implement/graphbase/implement.shtml">Stanford Graph Base</a>, 
a set of data sets that are useful for studying graph theory and networks.</p>
<p>See <a href="https://charlesreid1.com/wiki/Five_Letter_Words">Five Letter Words</a>
on the charlesreid1.com wiki for details.</p>
<p><a name="five4-diff-by-one"></a></p>
<h2>Different by 1, Revisited</h2>
<p>This post is revisiting an exercise from the above volume,
Exercise 28:</p>
<blockquote>
<p>Find pairs of SGB word vectors that differ by
+/- 1 in each component.</p>
</blockquote>
<p>In a prior blog post (<a href="#">Part 1</a>),
we had inerpreted the question as finding
word vectors whose Euclidean distance differed
by 1 total, which is the same as a Hamming
distance of 1.</p>
<p>However, on revisiting the (more interesting)
question actually being posed by the author,
we find a different and more difficult problem.</p>
<p>As an example of what Knuth is asking for:</p>
<div class="highlight"><pre><span></span>rover -&gt; spuds
</pre></div>


<p>Each letter of the words are within an edit
distance of 1, at each position.</p>
<p>There are 38 such pairs:</p>
<div class="highlight"><pre><span></span>$ python diff_by_one_fixed.py
abaft babes
absit baths
adder beefs
ambit blahs
anger boffs
anode boned
bider chefs
bidet chefs
biffs cheer
ghost hints
hobos inapt
holds inker
honed inode
hoods inner
hoofs inner
hoots input
hoped inode
ingot johns
needs odder
needs offer
rider sheds
rifer sheds
rinds shoer
robed spade
robot snaps
robot spans
rover spuds
ruffs steer
runts stout
rusts strut
sheer tiffs
sheet tiffs
shout tints
sides theft
sneer toffs
splat tombs
spuds toter
stuns tutor
Found <span class="m">38</span> pairs of words that differ by +/-1 in each component.
</pre></div>


<p>The approach we used was as follows:</p>
<ul>
<li>Iterate over each word in the wordlist
  (use the first 1,000 words to keep it
  shorter for testing)</li>
<li>For each word:</li>
<li>Generate all variations that are within +/-1 
    using recursive backtracking (could also use
    algorithm to generate all 32 binary codes of 
    length 5, where 0 = -1, 1 = +1)</li>
<li>For each of the 32 variations,<ul>
<li>Check if the word is in the wordset
  (O(1) cost if using a hash table/set)</li>
<li>If so, add ordered pair (word1,word2)
  to a set of solutions (to avoid dupes)</li>
</ul>
</li>
</ul>
<p><a name="five4-diff-by-n"></a></p>
<h2>Different by N, Revisited</h2>
<p>We went back and modified the code to take a
distance parameter d, but storage and compute
cost, as well as the sparsity of the graph of
shared bigrams and trigrams among these 5,000
words, means the number of pairs increases 
exponentially.</p>
<div class="highlight"><pre><span></span>| Distance  | Number of pairs   | Walltime       |
|-----------|-------------------|----------------|
| 1         | 38                |     0.26 s     |
| 2         | 525               |     5.26 s     |
| 3         | 4982              |    38.87 s     |
| 4         | ?? (10^5 est.)    |  10 min (est.) |
</pre></div>


<p>You can find the <code>diff_by_n.py</code> script here:
<a href="https://git.charlesreid1.com/cs/five-letter-words/">https://git.charlesreid1.com/cs/five-letter-words/</a></p>
<p>The output:</p>
<div class="highlight"><pre><span></span>$ python diff_by_n.py
abaft babes
absit baths
adder beefs
ambit blahs
anger boffs
anode boned
bider chefs
bidet chefs
biffs cheer
ghost hints
..
Found <span class="m">38</span> pairs of words that differ by +/-1 in each component.
Time: <span class="m">0</span>.2673 s

aback babel
aback cabal
abaft babes
abash cacti
abide baked
abide caged
abide caked
abler bands
abler bangs
abode caned
...
Found <span class="m">525</span> pairs of words that differ by +/-2 in each component.
Time: <span class="m">5</span>.2617 s

abaca ceded
abaci babel
abaci cabal
abaci decaf
abaci decal
aback babel
aback cabal
aback decal
abaft babes
abaft bedew
...
Found <span class="m">4982</span> pairs of words that differ by +/-3 in each component.
Time: <span class="m">38</span>.8743 s
</pre></div></div>

    </div>
</div>

<div class="v20"></div>

<div class="row">
    <div class="col-md-12" style="text-align: left;">

        <div class="tags">
            <p>Tags:&nbsp;&nbsp;&nbsp;
                    <a href="/tag/python.html">python</a>
                    &nbsp;&nbsp;
                    <a href="/tag/computer-science.html">computer science</a>
                    &nbsp;&nbsp;
                    <a href="/tag/graphs.html">graphs</a>
                    &nbsp;&nbsp;
                    <a href="/tag/algorithms.html">algorithms</a>
                    &nbsp;&nbsp;
                    <a href="/tag/art-of-computer-programming.html">art of computer programming</a>
                    &nbsp;&nbsp;
                    <a href="/tag/knuth.html">knuth</a>
                    &nbsp;&nbsp;
                    <a href="/tag/five-letter-words.html">five letter words</a>
                    &nbsp;&nbsp;
        </div>

    </div>
</div>


<div class="v200"></div>
  	            	</article>
  	            	<article>
<header>
<div class="row">


    <div class="col-md-12">
        <div class="headtext" style="text-align: center;">
            <h1><b>
                centillion: a document search engine
            </b></h1>
        
            <p class="lead">
                Posted 
                <time datetime="2019-03-10T09:00:00-07:00" pubdate>Sunday 03/10/2019</time>
                in 
                <a href="/category/python.html">Python</a>
                </p>
            <p>
            <span style="font-size: 14px">
                <a href="/centillion-a-document-search-engine.html">permalink</a>
            </span>
            </p>
        </div>

    </div>

</div>
</header>


<div class="v50"></div>


<div class="row">
    <div class="col-md-12" style="text-align: left;">

        <div class="entry-content"><p>We're excited to announce the public release of <a href="https://github.com/dcppc/centillion">centillion</a>,
a document search engine. </p>
<p>centillion is a search tool that can be used by any individual or organization
to index Github repositories (including the content of markdown files),
Google Drive folders (including the content of .docx files), and Disqus
comment threads.</p>
<p>centillion is <a href="https://travis-ci.org/dcppc/centillion">tested using Travis CI</a>.</p>
<p>centillion was originally written for the <a href="https://public.nihdatacommons.us">NIH Data Commons</a>
effort (which recently concluded).  centillion was built to facilitate information-finding
in a project with hundreds of people at dozens of institutions generating a sea of email threads,
Google Drive folders, markdown files, websites, and Github repositories.</p>
<p>centillion provided a single comprehensive way of searching across All The Things 
and earned the author many thanks from members across the Data Commons. It is the
author's hope that centillion can prove equally useful for other organizations.</p>
<p>Under the hood centillion uses <a href="http://flask.pocoo.org/">Flask</a> (a web server
microframework) and <a href="https://whoosh.readthedocs.io/en/latest/">Whoosh</a> (a Python-based
search engine tool).</p>
<p>You can get a copy of the latest centillion release here: <a href="https://github.com/dcppc/centillion">https://github.com/dcppc/centillion</a></p>
<p>You can find the latest centillion documentation here: <a href="http://nih-data-commons.us/centillion/">http://nih-data-commons.us/centillion/</a></p></div>

    </div>
</div>

<div class="v20"></div>

<div class="row">
    <div class="col-md-12" style="text-align: left;">

        <div class="tags">
            <p>Tags:&nbsp;&nbsp;&nbsp;
                    <a href="/tag/python.html">python</a>
                    &nbsp;&nbsp;
                    <a href="/tag/centillion.html">centillion</a>
                    &nbsp;&nbsp;
                    <a href="/tag/search.html">search</a>
                    &nbsp;&nbsp;
                    <a href="/tag/search-engine.html">search engine</a>
                    &nbsp;&nbsp;
                    <a href="/tag/google-drive.html">google drive</a>
                    &nbsp;&nbsp;
                    <a href="/tag/github.html">github</a>
                    &nbsp;&nbsp;
                    <a href="/tag/flask.html">flask</a>
                    &nbsp;&nbsp;
        </div>

    </div>
</div>


<div class="v200"></div>
  	            	</article>

<div class="row">
    <div class="col-md-4 col-centered" style="text-align: center;">

        <div class="pagination">



            <a class="prev" href="/index2.html">Older &rarr;</a>
        
          <br />
        </div>

    </div>
</div>

<div class="v50"></div>


        </div>

        <div class="col-md-4" style="text-align: center;">
<a name="a_archive"></a>


        <div class="well">

            <h2>March 2019</h2>

            <p class="archive">
            <a href="/five-letter-words-part-5-the-try-trie-tree.html">Five Letter Words: Part 5: The Try Trie Tree</a>
            </p>
            <p class="archive">
            <a href="/five-letter-words-part-4-revisiting-diff-by-one.html">Five Letter Words: Part 4: Revisiting Diff by One</a>
            </p>
            <p class="archive">
            <a href="/centillion-a-document-search-engine.html">centillion: a document search engine</a>
            </p>

        </div>

        <div class="v20"></div>


        <div class="well">

            <h2>February 2019</h2>

            <p class="archive">
            <a href="/any-color-you-like-as-long-as-its-00add8.html">Any Color You Like, As Long As It's 00ADD8</a>
            </p>
            <p class="archive">
            <a href="/a-few-of-my-favorite-peps.html">A Few of My Favorite PEPs</a>
            </p>
            <p class="archive">
            <a href="/context-managers-in-python.html">Context Managers in Python</a>
            </p>

        </div>

        <div class="v20"></div>


        <div class="well">

            <h2>January 2019</h2>

            <p class="archive">
            <a href="/building-snakemake-command-line-wrappers-for-kubernetes-workflows.html">Building Snakemake Command Line Wrappers for Kubernetes Workflows</a>
            </p>
            <p class="archive">
            <a href="/building-snakemake-command-line-wrappers-for-workflows.html">Building Snakemake Command Line Wrappers for Workflows</a>
            </p>
            <p class="archive">
            <a href="/recursive-backtracking-in-go-for-bioinformatics-applications-3-go-implementation-of-backtracking.html">Recursive Backtracking in Go for Bioinformatics Applications: 3. Go Implementation of Backtracking</a>
            </p>

        </div>

        <div class="v20"></div>


        <div class="well">

            <h2>December 2018</h2>

            <p class="archive">
            <a href="/recursive-backtracking-in-go-for-bioinformatics-applications-2-generating-variations.html">Recursive Backtracking in Go for Bioinformatics Applications: 2. Generating Variations</a>
            </p>
            <p class="archive">
            <a href="/recursive-backtracking-in-go-for-bioinformatics-applications-1-counting-variations.html">Recursive Backtracking in Go for Bioinformatics Applications: 1. Counting Variations</a>
            </p>
            <p class="archive">
            <a href="/basic-data-structures-in-go-maps.html">Basic Data Structures in Go: Maps</a>
            </p>
            <p class="archive">
            <a href="/learning-bioinformatics-with-go-and-rosalind.html">Learning Bioinformatics with Go and Rosalind</a>
            </p>

        </div>

        <div class="v20"></div>


        <div class="well">

            <h2>October 2018</h2>

            <p class="archive">
            <a href="/first-post-of-the-fall-part-2-flaskadillo.html">First Post of the Fall, Part 2: Flaskadillo</a>
            </p>
            <p class="archive">
            <a href="/first-post-of-the-fall-part-1-data-commons.html">First Post of the Fall, Part 1: Data Commons</a>
            </p>

        </div>

        <div class="v20"></div>


        <div class="well">

            <h2>May 2018</h2>

            <p class="archive">
            <a href="/current-projects.html">Current Projects</a>
            </p>

        </div>

        <div class="v20"></div>


        <div class="well">

            <h2>March 2018</h2>

            <p class="archive">
            <a href="/charlesreid1com-stack.html">Charlesreid1.com Stack</a>
            </p>

        </div>

        <div class="v20"></div>


        <div class="well">

            <h2>February 2018</h2>

            <p class="archive">
            <a href="/d3-calendar-visualizations.html">D3 Calendar Visualizations</a>
            </p>
            <p class="archive">
            <a href="/project-euler-problem-172.html">Project Euler Problem 172</a>
            </p>

        </div>

        <div class="v20"></div>


        <div class="well">

            <h2>January 2018</h2>

            <p class="archive">
            <a href="/4x4-rubiks-cube-part-4-sequence-order.html">4x4 Rubik's Cube: Part 4: Sequence Order</a>
            </p>
            <p class="archive">
            <a href="/4x4-rubiks-cube-part-3-factoring-permutations.html">4x4 Rubik's Cube: Part 3: Factoring Permutations</a>
            </p>
            <p class="archive">
            <a href="/4x4-rubiks-cube-part-2-permutations.html">4x4 Rubik's Cube: Part 2: Permutations</a>
            </p>
            <p class="archive">
            <a href="/4x4-rubiks-cube-part-1-representations.html">4x4 Rubik's Cube: Part 1: Representations</a>
            </p>
            <p class="archive">
            <a href="/lets-generate-permutations.html">Let's Generate Permutations!</a>
            </p>

        </div>

        <div class="v20"></div>


        <div class="well">

            <h2>September 2017</h2>

            <p class="archive">
            <a href="/five-letter-words-part-3-letter-coverage-and-dynamic-programming.html">Five Letter Words: Part 3: Letter Coverage and Dynamic Programming</a>
            </p>
            <p class="archive">
            <a href="/five-letter-words-part-2-more-five-word-algorithms.html">Five Letter Words: Part 2: More Five-Word Algorithms</a>
            </p>
            <p class="archive">
            <a href="/five-letter-words-part-1-getting-familiar-with-the-list.html">Five Letter Words: Part 1: Getting Familiar With The List</a>
            </p>

        </div>

        <div class="v20"></div>


        <div class="well">

            <h2>August 2017</h2>

            <p class="archive">
            <a href="/eulers-theorem-the-totient-function-and-calculating-totients-by-hand.html">Euler's Theorem, the Totient Function, and Calculating Totients By Hand</a>
            </p>

        </div>

        <div class="v20"></div>


        <div class="well">

            <h2>July 2017</h2>

            <p class="archive">
            <a href="/mad-combinatoric-castles.html">Mad Combinatoric Castles</a>
            </p>
            <p class="archive">
            <a href="/project-euler-problem-1.html">Project Euler Problem 1</a>
            </p>
            <p class="archive">
            <a href="/shortest-lattice-paths-and-multiset-permutations.html">Shortest Lattice Paths and Multiset Permutations</a>
            </p>
            <p class="archive">
            <a href="/computing-square-roots-part-2-using-continued-fractions.html">Computing Square Roots: Part 2: Using Continued Fractions</a>
            </p>
            <p class="archive">
            <a href="/computing-square-roots-part-1-using-newtons-method.html">Computing Square Roots: Part 1: Using Newton's Method</a>
            </p>

        </div>

        <div class="v20"></div>


        <div class="well">

            <h2>June 2017</h2>

            <p class="archive">
            <a href="/cse-143-final-project-hilbert-sort-3-the-code.html">CSE 143 Final Project: Hilbert Sort: 3. The Code</a>
            </p>
            <p class="archive">
            <a href="/cse-143-final-project-hilbert-sort-2-the-solution-algorithm.html">CSE 143 Final Project: Hilbert Sort: 2. The Solution Algorithm</a>
            </p>
            <p class="archive">
            <a href="/cse-143-final-project-hilbert-sort-1-the-problem.html">CSE 143 Final Project: Hilbert Sort: 1. The Problem</a>
            </p>
            <p class="archive">
            <a href="/cse-143-final-project-classy.html">CSE 143 Final Project: Classy</a>
            </p>
            <p class="archive">
            <a href="/cse-143-final-project-checkers.html">CSE 143 Final Project: Checkers</a>
            </p>

        </div>

        <div class="v20"></div>


        <div class="well">

            <h2>May 2017</h2>

            <p class="archive">
            <a href="/teaching-recursion-with-the-n-queens-problem.html">Teaching Recursion with the N Queens Problem</a>
            </p>
            <p class="archive">
            <a href="/undergraduate-research-project-wireless-sensor-networks-for-internet-of-things-applications-part-2-the-technologies.html">Undergraduate Research Project: Wireless Sensor Networks for Internet of Things Applications (Part 2: The Technologies)</a>
            </p>
            <p class="archive">
            <a href="/undergraduate-research-project-wireless-sensor-networks-for-internet-of-things-applications-part-1-the-project.html">Undergraduate Research Project: Wireless Sensor Networks for Internet of Things Applications (Part 1: The Project)</a>
            </p>

        </div>

        <div class="v20"></div>


        <div class="well">

            <h2>April 2017</h2>

            <p class="archive">
            <a href="/stunnel.html">Stunnel</a>
            </p>
            <p class="archive">
            <a href="/traveling-schoolteacher-problem.html">Traveling Schoolteacher Problem</a>
            </p>
            <p class="archive">
            <a href="/the-z-machine-a-simple-turing-machine.html">The Z-Machine: A Simple Turing Machine</a>
            </p>
            <p class="archive">
            <a href="/awsome-day-seattle-notes-part-2-networking-security-and-miscellany.html">AWSome Day Seattle Notes: Part 2: Networking, Security, and Miscellany</a>
            </p>
            <p class="archive">
            <a href="/awsome-day-seattle-notes-part-1-the-basics.html">AWSome Day Seattle Notes: Part 1: The Basics</a>
            </p>
            <p class="archive">
            <a href="/setting-up-a-self-hosted-github-clone-with-gitea.html">Setting Up a Self-Hosted Github Clone with Gitea</a>
            </p>
            <p class="archive">
            <a href="/better-timing-of-guava-traveling-salesperson-problem-code-timing-scripts.html">Better Timing of Guava Traveling Salesperson Problem Code: Timing Scripts</a>
            </p>

        </div>

        <div class="v20"></div>


        <div class="well">

            <h2>March 2017</h2>

            <p class="archive">
            <a href="/fixing-bottlenecks-in-the-guava-traveling-salesperson-problem-code.html">Fixing Bottlenecks in the Guava Traveling Salesperson Problem Code</a>
            </p>
            <p class="archive">
            <a href="/python-vs-perl-n-queens-problem.html">Python vs. Perl: N Queens Problem</a>
            </p>
            <p class="archive">
            <a href="/solving-the-traveling-salesperson-problem-with-java-and-guava.html">Solving the Traveling Salesperson Problem with Java and Guava</a>
            </p>
            <p class="archive">
            <a href="/perl-vs-java-n-queens-problem.html">Perl vs. Java: N Queens Problem</a>
            </p>
            <p class="archive">
            <a href="/enigma-cipher-implementation-part-4-combinatorics.html">Enigma Cipher Implementation: Part 4: Combinatorics</a>
            </p>
            <p class="archive">
            <a href="/enigma-cipher-implementation-part-3-enigma-in-java-without-objects.html">Enigma Cipher Implementation: Part 3: Enigma in Java Without Objects</a>
            </p>
            <p class="archive">
            <a href="/enigma-cipher-implementation-part-2-pseudocode.html">Enigma Cipher Implementation: Part 2: Pseudocode</a>
            </p>
            <p class="archive">
            <a href="/enigma-cipher-implementation-part-1-how-it-works.html">Enigma Cipher Implementation: Part 1: How It Works</a>
            </p>

        </div>

        <div class="v20"></div>



<div class="v100"></div>
        </div>

    </div>



</div>



<script type="text/javascript" src="/theme/js/jquery-1.11.2.js"></script>
<script type="text/javascript" src="/theme/js/bootstrap-3.3.4.js"></script>
<script type="text/javascript" src="/theme/js/d3-3.5.5.js"></script><script type="text/javascript" src="/theme/js/jquery-1.11.2.js"></script>
<script type="text/javascript" src="/theme/js/bootstrap-3.3.4.js"></script>

<footer id="contentinfo" class="body">
<p>&nbsp;</p>
<p>&nbsp;</p>
<center>
	<hr />
</center>
<p>&nbsp;</p>
<p style="text-align: center">
    <span class="fa-stack fa-lg">
        <i class="fa fa-square fa-stack-2x" style="color:#000;"></i>
        <i class="fa fa-terminal fa-stack-1x fa-inverse"></i>
    </span>
    Made from the command line with vim by 
    <a href="http://charlesreid1.com">charlesreid1</a><br />
    with help from <a href="https://getbootstrap.com/">Bootstrap</a> and <a href="http://getpelican.com">Pelican</a>.
</p>

<br />

<p style="text-align: center">
    <a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/">
    <span class="fa-stack fa-lg">
        <i class="fa fa-square fa-stack-2x" style="color:#000;"></i>
        <i class="fa fa-creative-commons fa-stack-1x fa-inverse"></i>
    </span>
    </a>
    <br />
    Licensed under the <a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/">Creative Commons Attribution-NonCommercial 4.0 License</a>.
</p>

<!-- Start of StatCounter Code for Default Guide -->
<script type="text/javascript">
var sc_project=11611748;
var sc_invisible=1;
var sc_security="9fcba820";
</script>
<script type="text/javascript"
src="https://www.statcounter.com/counter/counter.js"
async></script>

<noscript><div class="statcounter"><a title="Web Analytics"
href="http://statcounter.com/" target="_blank"><img
class="statcounter"
src="//c.statcounter.com/11611748/0/9fcba820/1/" alt="Web
Analytics"></a></div></noscript>
<!-- End of StatCounter Code for Default Guide -->
</footer><!-- /#contentinfo -->
</body>
</html>